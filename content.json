[{"title":"CSS_Secrets","date":"2017-12-13T01:42:03.000Z","path":"2017/12/13/CSS-Secrets/","text":"如果让我推荐基本css方面的书籍，我会推荐精通CSS（第2版）、CSS权威指南以及Lea Verou大神的CSS Secrets最近花了点时间将CSS Secrets看了遍，将所有代码敲了一遍。特在此做个记录，可以右键查看源码，绝大部分都写了注释。可以在https://github.com/BryanAdamss/SourceSave/tree/master/CssSecrets看到所有源文件 CSS_Scerts00_减少代码重复 01_currentColor 02_使用inherit完成一些reset 03_半透明边框 04_多重边框 05_多重边框_outline 06_灵活背景图定位 07_灵活背景图定位_origin 08_灵活背景图定位_calc 09边框内圆角两个元素实现 10边框内圆角一个元素实现 11_水平条纹 12_垂直条纹 13_斜向条纹 14_更好的斜向条纹 15_灵活的同色系条纹 16_渐变生成网格 17_格子可调的网格 18_更加逼真的可调网格 19_径向渐变生成波点 20_错落有致的波点 21_渐变生成棋盘 22_渐变生成棋盘优化 23_伪随机背景 24_连续的背景边框 25_老式信封 26_蚂蚁行军边框 27_脚注 28_椭圆 29_平行四边形 30_菱形图片 31_斜向切角 32_弧形切角 33_梯形标签页 34_饼图 35_饼图_svg 36_饼图_svg优化 37_单侧、邻边、双侧投影 38_不规则投影 39染色效果滤镜 40染色效果混合模式 41_毛玻璃 42_折角效果 43_其它角度折角 44_更加逼真的折角 45_插入换行 46_代码斑马纹 47_控制tab的大小 48_自定义下划线 49_凸版文字 50_空心文字 51_文字发光效果 52_伪3d文字 53_长阴影文字 54_环形文字 55_使用禁用标志标识禁用按钮 56_扩大点击区域 57_自定义复选框 58_模糊背景 59_滚动阴影提示 60_图片对比控件 61_范围输入的图片对比控件 62_自适应内部元素 63_根据兄弟元素的数量来设置样式 64_根据兄弟元素数量范围来匹配元素 65_满幅背景定宽内容 66_弹性过渡 67_延时过渡 68_逐帧动画 69_文字闪烁动画 70_打字动画 71_状态平滑的动画 72_用两个元素实现沿环形路径平移的动画","tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"ES6-learning","date":"2017-09-26T08:56:17.000Z","path":"2017/09/26/ES6-learning/","text":"ES6学习笔记 最近在看阮老师的ES6教程，所以特此记录一些重点。例子使用的大都是阮老师的例子，感谢阮老师的无私奉献。 简介 es6泛指下一代js标准，主要涵盖了es2015,es2016,es2017；一般说的es6主要指的es2015 let let实际为js提供了块级作用域，用法类似var，但它所声明的变量，仅在let所在的代码块中有效。 1234if(true)&#123; let a=3;&#125;console.log(a);// 报错 for循环中的计数变量非常适合使用let 使用var声明的 1234567var a = [];for (var i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 10，因为i是全局变量，全局有效，调用时得到的是最后一次的值 使用let声明的 1234567var a = [];for (let i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 6，使用let后，每轮循环的i，仅在本轮循环中有效，这样其实每轮循环都有一个新的i值。后台负责记录上一次的i值； for循环设置循环变量的部分是一个父作用域，循环体是一个子作用域，使用let声明相同的变量不会相互干扰 1234567for (let i = 0; i &lt; 3; i++) &#123; let i = 'abc'; console.log(i);&#125;// abc// abc// abc 使用let，不存在变量声明提升 1234567// var 的情况console.log(foo); // 输出undefined，因为存在var foo;被提升了var foo = 2;// let 的情况console.log(bar); // 报错ReferenceErrorlet bar = 2; 暂时性死区 个人理解：ES6在执行时，可能存在一个预先检查的过程，只要检查到某个代码块中使用let声明某变量后，那在let声明之前任何使用此变量的操作(包括带有安全防范机制的typeof)都将报错。 123456var tmp = 123;if (true) &#123; tmp = 'abc'; // ReferenceError，检查到这个代码块使用了let声明了temp，所以在let声明之前使用tmp报错，即使外部有全局变量。 let tmp;&#125; 使用typeof也会报错 12typeof x;// 报错，显示x还未定义，如果没有let，因为typeof存在安全防范机制，所以返回的是'undefined'let x; 不允许重复声明 let不允许在相同作用域内，重复声明同一个变量 1234567891011// 报错function func() &#123; let a = 10; var a = 1;&#125;// 报错function func() &#123; let a = 10; let a = 1;&#125; 不能在函数内部重新声明参数 123456789function func(arg) &#123; let arg; // 报错&#125;function func(arg) &#123; &#123; let arg; // 不报错 &#125;&#125; ES6块级作用域 let实际上为 JavaScript 新增了块级作用域 块级作用域的任意嵌套 1&#123;&#123;&#123;&#123;&#123;let insane = 'Hello World'&#125;&#125;&#125;&#125;&#125;; 外层作用域无法读取内层作用域的变量，内层作用域可以定义外层作用域的同名变量 123456789&#123;&#123;&#123;&#123; &#123;let insane = &apos;Hello World&apos;&#125; console.log(insane); // 报错&#125;&#125;&#125;&#125;;&#123;&#123;&#123;&#123; let insane = &apos;Hello World&apos;; &#123;let insane = &apos;Hello World&apos;&#125;&#125;&#125;&#125;&#125;; 最好不要在块级作用域中使用function声明函数(可以使用函数表达式来创建函数) const const基本和let类似，只在声明所在的块级作用域内有效、存在暂时性死区、同一作用域不可重复声明；重要的是一旦声明，常量的值就不能改变。 1234const PI = 3.1415;PI // 3.1415PI = 3; const声明一个变量时，必须立即给其赋值，不能先声明，后期再赋值 12const foo;// SyntaxError: Missing initializer in const declarationfoo=3; 解构赋值 ES6允许按照一定的模式，从数组和对象中提取值，对变量进行赋值，这过程称之为解构过程Destructuring 数组的解构赋值1let [a, b, c] = [1, 2, 3]; 这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。 1234567891011121314151617181920let [foo, [[bar], baz]] = [1, [[2], 3]];foo // 1bar // 2baz // 3let [ , , third] = [\"foo\", \"bar\", \"baz\"];third // \"baz\"let [x, , y] = [1, 2, 3];x // 1y // 3let [head, ...tail] = [1, 2, 3, 4];head // 1tail // [2, 3, 4]let [x, y, ...z] = ['a'];x // \"a\"y // undefinedz // [] 解构不成功时，变量的值就等于undefined 1let [bar, foo] = [1];// bar为1，foo为undefined 不完全解构 等号左边的模式，只匹配一部分的等号右边的数组；解构依然会成功12345678let [x, y] = [1, 2, 3];x // 1y // 2let [a, [b], d] = [1, [2, 3], 4];a // 1b // 2d // 4 如果等号的右边不是数组（或者严格地说，不是可遍历的结构，参见《Iterator》一章），那么将会报错 1234567// 报错let [foo] = 1;// 转为对象以后不具备 Iterator 接口let [foo] = false;// 转为对象以后不具备 Iterator 接口let [foo] = NaN;// 转为对象以后不具备 Iterator 接口let [foo] = undefined;// 转为对象以后不具备 Iterator 接口let [foo] = null;// 转为对象以后不具备 Iterator 接口let [foo] = &#123;&#125;;// 本身就不具备 Iterator 接口 解构时可以有默认值 12345let [foo = true] = [];foo // truelet [x, y = 'b'] = ['a']; // x='a', y='b'let [x, y = 'b'] = ['a', undefined]; // x='a', y='b' 默认值只有在当一个成员严格相等于(===)undefined时(本身值为undefined，或者没有值)，才会生效，这就是上面，最后的y为&#39;b&#39;的原因12345678let [a = 1] = [];// 无值，默认值生效a // 1let [x = 1] = [undefined];// 值为undefined，默认值生效x // 1let [x = 1] = [null];// 因为null!==undefined，默认值并未生效x // null 对象的解构赋值123let &#123; foo, bar &#125; = &#123; foo: \"aaa\", bar: \"bbb\" &#125;;foo // \"aaa\"bar // \"bbb\" 数组是有顺序的，所以解构是按照顺序来匹配，而对象没有固定的顺序，所以结构时变量必须和属性同名，才能取到正确的值 123456let &#123; bar, foo &#125; = &#123; foo: \"aaa\", bar: \"bbb\" &#125;;// 匹配和顺序无关foo // \"aaa\"bar // \"bbb\"let &#123; baz &#125; = &#123; foo: \"aaa\", bar: \"bbb\" &#125;;// 找不到同名的属性，所以变量取值不成功baz // undefined 如果想把取到的值赋给另外一个变量则必须用下面的写法 1234567let &#123; foo: baz &#125; = &#123; foo: 'aaa', bar: 'bbb' &#125;;// foo取到的值'aaa'被赋给了baz变量baz // \"aaa\"let obj = &#123; first: 'hello', last: 'world' &#125;;let &#123; first: f, last: l &#125; = obj;f // 'hello'l // 'world' 对象解构赋值的本质 {模式名:变量名,模式名:变量名…}={属性名:值,属性名:值…} 通过左侧模式名去找对应的属性名，取到对应属性名的值后，将值赋值给模式名后面的变量名； 当左侧模式后面的变量名没有时，会取模式的名字； 12let &#123; foo, bar &#125; = &#123; foo: \"aaa\", bar: \"bbb\" &#125;;// 和下面的是等价的let &#123; foo: foo, bar: bar &#125; = &#123; foo: \"aaa\", bar: \"bbb\" &#125;; 对应关系:模式名-&gt;属性名；变量名-&gt;值 123let &#123; foo: baz &#125; = &#123; foo: \"aaa\", bar: \"bbb\" &#125;;baz // \"aaa\"foo // error: foo is not defined，foo不是变量而是一个模式 对象解构和数组解构一样可以嵌套解构 这时的p是模式并非变量 12345678910let obj = &#123; p: [ 'Hello', &#123; y: 'World' &#125; ]&#125;;let &#123; p: [x, &#123; y &#125;] &#125; = obj;x // \"Hello\"y // \"World\" 取得p的值 1234567891011let obj = &#123; p: [ 'Hello', &#123; y: 'World' &#125; ]&#125;;let &#123; p, p: [x, &#123; y &#125;] &#125; = obj;// 相当于let &#123; p:p, p: [x, &#123; y &#125;] &#125; = objx // \"Hello\"y // \"World\"p // [\"Hello\", &#123;y: \"World\"&#125;] 多层嵌套 12345678910111213const node = &#123; loc: &#123; start: &#123; line: 1, column: 5 &#125; &#125;&#125;;let &#123; loc, loc: &#123; start &#125;, loc: &#123; start: &#123; line &#125;&#125; &#125; = node;// 相当于let &#123; loc:loc, loc: &#123; start:start &#125;, loc: &#123; start: &#123; line:line &#125;&#125; &#125; = nodeline // 1loc // Object &#123;start: Object&#125;start // Object &#123;line: 1, column: 5&#125; 默认值 123456789101112131415var &#123;x = 3&#125; = &#123;&#125;;x // 3var &#123;x, y = 5&#125; = &#123;x: 1&#125;;x // 1y // 5var &#123;x: y = 3&#125; = &#123;&#125;;y // 3var &#123;x: y = 3&#125; = &#123;x: 5&#125;;// 模式是x，变量是y，并且y有个默认值3y // 5var &#123; message: msg = 'Something went wrong' &#125; = &#123;&#125;;msg // \"Something went wrong\" 默认值生效的条件是，对象的属性值严格等于undefined12345var &#123;x = 3&#125; = &#123;x: undefined&#125;;x // 3var &#123;x = 3&#125; = &#123;x: null&#125;;// null!==undefined，所以默认值不生效x // null 解构失败，则变量的值为undefined 12let &#123;foo&#125; = &#123;bar: 'baz'&#125;;foo // undefined 如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错 12// 报错let &#123;foo: &#123;bar&#125;&#125; = &#123;baz: 'baz'&#125;;// 因为foo根本就没找到此时foo为undefined，在undefined下找bar肯定报错 针对已经声明的变量使用解构赋值时，需要在最外围加上括号 1234567// 错误的写法let x;&#123;x&#125; = &#123;x: 1&#125;;// SyntaxError: syntax error 语法块不能被赋值// 正确的写法let x;(&#123;x&#125; = &#123;x: 1&#125;); 可以将原生对象的属性方法解构到变量上 1let &#123; log, sin, cos &#125; = Math; 运用解构获取数组的首个和末尾元素 1234let arr = [1, 2, 3];let &#123;0 : first, [arr.length - 1] : last&#125; = arr;first // 1last // 3 非对象的解构赋值 解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。 12let &#123; prop: x &#125; = undefined; // TypeErrorlet &#123; prop: y &#125; = null; // TypeError 字符串的解构赋值 字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象(包装对象)。12345678const [a, b, c, d, e] = 'hello';a // \"h\"b // \"e\"c // \"l\"d // \"l\"e // \"o\"let &#123;length : len&#125; = 'hello';len // 5 数值和布尔值的解构赋值 解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。12345let &#123;toString: s&#125; = 123;s === Number.prototype.toString // truelet &#123;toString: s&#125; = true;s === Boolean.prototype.toString // true 函数参数的解构赋值 例子 1234567function add([x, y])&#123; return x + y;&#125;add([1, 2]); // 3[[1, 2], [3, 4]].map(([a, b]) =&gt; a + b);// [ 3, 7 ] 参数解构使用默认值 123456789101112131415161718function move(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123; return [x, y];&#125;move(&#123;x: 3, y: 8&#125;); // [3, 8]；&#123;x = 0, y = 0&#125;=&#123;x: 3, y: 8&#125;move(&#123;x: 3&#125;); // [3, 0]；&#123;x = 0, y = 0&#125;=&#123;x: 3&#125;move(&#123;&#125;); // [0, 0]；&#123;x = 0, y = 0&#125;=&#123;&#125;move(); // [0, 0]；&#123;x = 0, y = 0&#125;=&#123;&#125;// 另一种写法function move(&#123;x, y&#125; = &#123; x: 0, y: 0 &#125;) &#123; return [x, y];&#125;move(&#123;x: 3, y: 8&#125;); // [3, 8]；&#123;x, y&#125;=&#123;x: 3, y: 8&#125;move(&#123;x: 3&#125;); // [3, undefined]；&#123;x, y&#125;=&#123;x: 3&#125;move(&#123;&#125;); // [undefined, undefined]；&#123;x, y&#125;=&#123;&#125;move(); // [0, 0]；&#123;x, y&#125;=&#123; x: 0, y: 0 &#125; undefined会触发函数参数的默认值 12[1, undefined, 3].map((x = 'yes') =&gt; x);// 索引1为undefined，所以默认值生效// [ 1, 'yes', 3 ] 圆括号问题 对于编译器来说，一个式子到底是模式，还是表达式，没有办法从一开始就知道，必须解析到（或解析不到）等号才能知道.ES6 的规则是，只要有可能导致解构的歧义，就不得使用圆括号。建议只要有可能，就不要在模式中放置圆括号。 不能用圆括号的情况 变量声明语句 123456789// 全部报错let [(a)] = [1];let &#123;x: (c)&#125; = &#123;&#125;;let (&#123;x: c&#125;) = &#123;&#125;;let &#123;(x: c)&#125; = &#123;&#125;;let &#123;(x): c&#125; = &#123;&#125;;let &#123; o: (&#123; p: p &#125;) &#125; = &#123; o: &#123; p: 2 &#125; &#125;; 函数参数 函数参数也属于变量声明，因此不能带有圆括号1234// 报错function f([(z)]) &#123; return z; &#125;// 报错function f([z,(x)]) &#123; return x; &#125; 赋值语句的模式中 123456// 全部报错(&#123; p: a &#125;) = &#123; p: 42 &#125;;([a]) = [5];// 报错[(&#123; p: a &#125;), &#123; x: c &#125;] = [&#123;&#125;, &#123;&#125;]; 可以使用圆括号的情况 赋值语句的非模式部分，可以使用圆括号。 123[(b)] = [3]; // 正确(&#123; p: (d) &#125; = &#123;&#125;); // 正确[(parseInt.prop)] = [3]; // 正确 解构赋值的用途 交换变量的值 1234let x = 1;let y = 2;[x, y] = [y, x]; 从函数返回多个值 123456789101112131415// 返回一个数组，然后通过解构赋值赋值给变量function example() &#123; return [1, 2, 3];&#125;let [a, b, c] = example();// 返回一个对象，然后通过解构赋值赋值给变量function example() &#123; return &#123; foo: 1, bar: 2 &#125;;&#125;let &#123; foo, bar &#125; = example(); 函数参数的定义 1234567// 参数是一组有次序的值function f([x, y, z]) &#123; ... &#125;f([1, 2, 3]);// 参数是一组无次序的值function f(&#123;x, y, z&#125;) &#123; ... &#125;f(&#123;z: 3, y: 2, x: 1&#125;); 提取JSON数据 12345678910let jsonData = &#123; id: 42, status: \"OK\", data: [867, 5309]&#125;;let &#123; id, status, data: number &#125; = jsonData;console.log(id, status, number);// 42, \"OK\", [867, 5309] 函数参数的默认值 1234567891011jQuery.ajax = function (url, &#123; async = true, beforeSend = function () &#123;&#125;, cache = true, complete = function () &#123;&#125;, crossDomain = false, global = true, // ... more config&#125;) &#123; // ... do stuff&#125;; 遍历Map结构 12345678910111213141516171819const map = new Map();map.set('first', 'hello');map.set('second', 'world');for (let [key, value] of map) &#123; console.log(key + \" is \" + value);&#125;// first is hello// second is world// 获取键名for (let [key] of map) &#123; // ...&#125;// 获取键值for (let [,value] of map) &#123; // ...&#125; 输入模块的指定方法 1const &#123; SourceMapConsumer, SourceNode &#125; = require(\"source-map\"); 字符串的扩展使用大括号表示超过ffff的字符1234567\"𠮷\"的unicode编码为\\u20BB7，超过ffff，在es5中必须拆分成两个来写\"\\uD842\\uDFB7\"// \"𠮷\"es6中可以使用&#123;&#125;包裹来完成超过ffff字符的显示\"\\u&#123;20BB7&#125;\"// \"𠮷\" codePointAt codePointAt方法会正确返回32位的UTF-16字符的十进制表示。对于那些两个字节储存的常规字符，它的返回结果与charCodeAt方法相同 123let s = '𠮷a';s.codePointAt(0).toString(16) // \"20bb7\" codePointAt方法是测试一个字符由两个字节还是由四个字节组成的最简单方法。 123456function is32Bit(c) &#123; return c.codePointAt(0) &gt; 0xFFFF;&#125;is32Bit(\"𠮷\") // trueis32Bit(\"a\") // false String.fromCodePoin String.fromCharCode的升级版本能将超过ffff的编码转换成字符1234String.fromCharCode(0x20BB7)// \"ஷ\"String.fromCodePoint(0x20BB7)// \"𠮷\" at charAt的升级版，返回对应位置字符，可识别超过ffff的字符12345'abc'.charAt(0) // \"a\"'𠮷'.charAt(0) // \"\\uD842\",𠮷是32bit的，它返回的是高16位的编码'abc'.at(0) // \"a\"'𠮷'.at(0) // \"𠮷\" 字符串的遍历器接口 es6为字符串提供遍历接口，可以使用for…of遍历，并能遍历超过ffff编码的字符123456789101112131415161718for (let codePoint of 'foo') &#123; console.log(codePoint)&#125;// \"f\"// \"o\"// \"o\"let text = String.fromCodePoint(0x20BB7);for (let i = 0; i &lt; text.length; i++) &#123; console.log(text[i]);&#125;// \" \"// \" \"for (let i of text) &#123; console.log(i);&#125;// \"𠮷\" includes(), startsWith(), endsWith() includes返回布尔值，表示是否找到了参数字符串 startsWith返回布尔值，表示参数字符串是否在原字符串的头部。 endsWith返回布尔值，表示参数字符串是否在原字符串的尾部。12345let s = 'Hello world!';s.startsWith('Hello') // trues.endsWith('!') // trues.includes('o') // true repeat 重复某个字符串，并返回新的字符串123'x'.repeat(3) // \"xxx\"'hello'.repeat(2) // \"hellohello\"'na'.repeat(0) // \"\" padStart(),padEnd() 补齐字符串长度 123456789101112131415'x'.padStart(5, 'ab') // 'ababx''x'.padStart(4, 'ab') // 'abax''x'.padEnd(5, 'ab') // 'xabab''x'.padEnd(4, 'ab') // 'xaba'// 如果原字符串的长度，等于或大于指定的最小长度，则返回原字符串。'xxx'.padStart(2, 'ab') // 'xxx''xxx'.padEnd(2, 'ab') // 'xxx'// 如果用来补全的字符串与原字符串，两者的长度之和超过了指定的最小长度，则会截去超出位数的补全字符串。'abc'.padStart(10, '0123456789')// '0123456abc'// 如果省略第二个参数，默认使用空格补全长度。'x'.padStart(4) // ' x''x'.padEnd(4) // 'x ' padStart的常见用途是为数值补全指定位数 123'1'.padStart(10, '0') // \"0000000001\"'12'.padStart(10, '0') // \"0000000012\"'123456'.padStart(10, '0') // \"0000123456\" 模板字符串 模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量 12345678910111213// 普通字符串`In JavaScript '\\n' is a line-feed.`// 多行字符串`In JavaScript this is not legal.`console.log(`string text line 1string text line 2`);// 字符串中嵌入变量let name = \"Bob\", time = \"today\";`Hello $&#123;name&#125;, how are you $&#123;time&#125;?` 模板字符串中嵌入变量，需要将变量名写在${}之中。 12345678910111213141516171819202122232425262728293031323334function authorize(user, action) &#123; if (!user.hasPrivilege(action)) &#123; throw new Error( // 传统写法为 // 'User ' // + user.name // + ' is not authorized to do ' // + action // + '.' `User $&#123;user.name&#125; is not authorized to do $&#123;action&#125;.`); &#125;&#125;// 大括号内部可以放入任意的JavaScript表达式，可以进行运算，以及引用对象属性let x = 1;let y = 2;`$&#123;x&#125; + $&#123;y&#125; = $&#123;x + y&#125;`// \"1 + 2 = 3\"`$&#123;x&#125; + $&#123;y * 2&#125; = $&#123;x + y * 2&#125;`// \"1 + 4 = 5\"let obj = &#123;x: 1, y: 2&#125;;`$&#123;obj.x + obj.y&#125;`// \"3\"// 模板字符串之中还能调用函数function fn() &#123; return \"Hello World\";&#125;`foo $&#123;fn()&#125; bar`// foo Hello World bar 模板字符串甚至还能嵌套 123456789101112131415161718192021222324const tmpl = addrs =&gt; ` &lt;table&gt; $&#123;addrs.map(addr =&gt; ` &lt;tr&gt;&lt;td&gt;$&#123;addr.first&#125;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;$&#123;addr.last&#125;&lt;/td&gt;&lt;/tr&gt; `).join('')&#125; &lt;/table&gt;`;const data = [ &#123; first: '&lt;Jane&gt;', last: 'Bond' &#125;, &#123; first: 'Lars', last: '&lt;Croft&gt;' &#125;,];console.log(tmpl(data));// &lt;table&gt;//// &lt;tr&gt;&lt;td&gt;&lt;Jane&gt;&lt;/td&gt;&lt;/tr&gt;// &lt;tr&gt;&lt;td&gt;Bond&lt;/td&gt;&lt;/tr&gt;//// &lt;tr&gt;&lt;td&gt;Lars&lt;/td&gt;&lt;/tr&gt;// &lt;tr&gt;&lt;td&gt;&lt;Croft&gt;&lt;/td&gt;&lt;/tr&gt;//// &lt;/table&gt; 标签模板 函数名后紧跟一个模板字符串 标签模板其实不是模板，而是函数调用的一种特殊形式。“标签”指的就是函数，紧跟在后面的模板字符串就是它的参数。 123alert`123`// 等同于alert(123) 如果模板字符里面有变量，就不是简单的调用了，而是会将模板字符串先处理成多个参数，再调用函数 会将除模板字符串中变量以外的字符串分隔成一个个字符串保存到数组中并传入函数中，并将模板字符串中变量按顺序依次传入函数中 1234567891011121314151617let a = 5;let b = 10;tag`Hello $&#123; a + b &#125; world $&#123; a * b &#125;`;// 等同于tag(['Hello ', ' world ', ''], 15, 50);function tag(stringArr, value1, value2)&#123; // stringArr为['Hello ', ' world ', ''],value1为15,value2为50 // ...&#125;// 等同于function tag(stringArr, ...values)&#123; // stringArr为['Hello ', ' world ', ''],values[15,20] // ...&#125; 用途 过滤用户恶意输入、i18n国际化12345678910111213141516171819202122232425// 一般$&#123;sender&#125;为用户的输入let message = SaferHTML`&lt;p&gt;$&#123;sender&#125; has sent you a message.&lt;/p&gt;`;function SaferHTML(templateData) &#123; let s = templateData[0];// 原有字符串数组 for (let i = 1; i &lt; arguments.length; i++) &#123;// i从1开始 let arg = String(arguments[i]);// 实际取到的为用户输入 // 转义用户输入中的特殊符号 s += arg.replace(/&amp;/g, \"&amp;amp;\") .replace(/&lt;/g, \"&amp;lt;\") .replace(/&gt;/g, \"&amp;gt;\"); // 拼接上原有字符串的后面部分 s += templateData[i]; &#125; return s;&#125;let sender = '&lt;script&gt;alert(\"abc\")&lt;/script&gt;'; // 恶意代码let message = SaferHTML`&lt;p&gt;$&#123;sender&#125; has sent you a message.&lt;/p&gt;`;console.log(message);// &lt;p&gt;&amp;lt;script&amp;gt;alert(\"abc\")&amp;lt;/script&amp;gt; has sent you a message.&lt;/p&gt; String.raw 返回用\\转移的字符串串12345String.raw`Hi\\n$&#123;2+3&#125;!`;// \"Hi\\\\n5!\"String.raw`Hi\\u000A!`;// 'Hi\\\\u000A!' 正则的扩展 老正则还不会用…先放着，后期再补吧(希望我能想起来吧…) 数值的扩展 扩展了一大批方法…(先过一遍，留个印象，用的时候再查吧) 函数的扩展函数参数的默认值 利用=直接写在形参后面 1234567function log(x, y = 'World') &#123;// y如果===undefined，则y的默认值生效 console.log(x, y);&#125;log('Hello') // Hello Worldlog('Hello', 'China') // Hello Chinalog('Hello', '') // Hello 参数变量是默认声明的，所以不能用let或const再次声明。 1234function foo(x = 5) &#123; let x = 1; // error const x = 2; // error&#125; 参数默认值不是传值的，而是每次都重新计算默认值表达式的值 123456789let x = 99;function foo(p = x + 1) &#123; console.log(p);&#125;foo() // 100x = 100;foo() // 101 与解构赋值默认值结合使用 1234567891011121314function foo(&#123;x, y = 5&#125;) &#123;// 解构赋值默认值 console.log(x, y);&#125;foo(&#123;&#125;) // undefined 5；&#123;x, y = 5&#125;=&#123;&#125;foo(&#123;x: 1&#125;) // 1 5；&#123;x, y = 5&#125;=&#123;x:1&#125;foo(&#123;x: 1, y: 2&#125;) // 1 2；&#123;x, y = 5&#125;:&#123;x:1,y:2&#125;foo() // TypeError: Cannot read property 'x' of undefined；&#123;x, y = 5&#125;=undefined所以报错function foo(&#123;x, y = 5&#125; = &#123;&#125;) &#123;// 解构赋值默认值+形参默认值，就不会出现报错 console.log(x, y);&#125;foo() // undefined 5 不同写法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// 写法1function m1(x,y) &#123;// 形参(无默认值) return [x, y];&#125;m1(1,3);//[1,3]m1();//[undefined,undefined]// 写法2function m1(x,y=5) &#123;// 形参(有默认值) return [x, y];&#125;m1(1,3);//[1,3]m1(3);//[3,5]m1();//[undefined,5]// 写法3function m1(&#123;x , y&#125;) &#123;// 解构赋值(无默认值) return [x, y];&#125;m1(1,3);//[undefined,undefined];&#123;x,y&#125;=1,3;左右模式不一致，所以解构赋值不成功，得到undefinedm1(&#123;x:1,y:3&#125;);//[1,3]；&#123;x,y&#125;=&#123;x:1,y:3&#125;m1(&#123;x:1&#125;);//[1,undefined]；&#123;x,y&#125;=&#123;x:1&#125;m1(&#123;&#125;);[undefined,undefined]；&#123;x , y&#125;=&#123;&#125;；未找到对应属性名，所以得到undefinedm1();// err；&#123;x,y&#125;=undefined-&gt;所以报错// 写法4function m1(&#123;x = 0, y = 5&#125;) &#123;// 解构赋值(有默认值) return [x, y];&#125;m1(1,3);//[0,5];&#123;x = 0, y = 5&#125;=1,3；左右模式不匹配，得到undefined，因而解构默认值生效m1(&#123;x:1,y:3&#125;);//[1,3]；&#123;x = 0, y = 5&#125;=&#123;x:1,y:3&#125;m1(&#123;x:1&#125;);//[1,undefined]；&#123;x,y&#125;=&#123;x:1&#125;m1(&#123;&#125;);//[0,5]；&#123;x = 0, y = 5&#125;=&#123;&#125;；未找到对应属性名，所以得到undefined，因而解构默认值生效m1();// err；&#123;x = 0, y = 5&#125;=undefined-&gt;所以报错// 写法5function m1(&#123;x , y&#125;=&#123;&#125;) &#123;// 解构赋值(无默认值)+形参(有默认值，空对象) return [x, y];&#125;m1(1,3);//[undefined,undefined];&#123;x,y&#125;=1,3;左右模式不一致，所以解构赋值不成功，得到undefinedm1(&#123;x:1,y:3&#125;);//[1,3]；&#123;x , y&#125;=&#123;x:1,y:3&#125;m1(&#123;x:1&#125;);//[1,undefined]；&#123;x , y&#125;=&#123;x:1&#125;m1(&#123;&#125;);//[undefined,undefined]；&#123;x , y&#125;=&#123;&#125;；未找到对应属性名，所以得到undefinedm1();//[undefined,undefined]；&#123;x , y&#125;=&#123;&#125;// 写法6function m1(&#123;x , y&#125;=&#123;x:3,y:4&#125;) &#123;// 解构赋值(无默认值)+形参(有默认值，非空对象) return [x, y];&#125;m1(1,3);//[undefined,undefined];&#123;x,y&#125;=1,3;左右模式不一致，所以解构赋值不成功，得到undefinedm1(&#123;x:1,y:3&#125;);//[1,3]；&#123;x , y&#125;=&#123;x:1,y:3&#125;m1(&#123;x:1&#125;);//[1,undefined]；&#123;x , y&#125;=&#123;x:1&#125;m1(&#123;&#125;);//[undefined,undefined]；&#123;x , y&#125;=&#123;&#125;；未找到对应属性名，所以得到undefinedm1();//[3,4]；&#123;x , y&#125;=&#123;x:3,y:4&#125;；未传参数，所以形参的默认值&#123;x:3,y:4&#125;生效，参与解构// 写法7function m1(&#123;x = 0, y = 5&#125;=&#123;&#125;) &#123;// 解构赋值(有默认值)+形参(有默认值，空对象) return [x, y];&#125;m1(1,3);//[0,5];传入参数跟想要的类型不一致，所以行参默认值生效&#123;x = 0, y = 5&#125;=&#123;&#125;;未找到对应属性名，所以解构默认值生效m1(&#123;x:1,y:3&#125;);//[1,3]；&#123;x = 0, y = 5&#125;=&#123;x:1,y:3&#125;// 默认值&#123;&#125;不生效m1(&#123;x:1&#125;);//[1,5]；&#123;x = 0, y = 5&#125;=&#123;x:1&#125; m1(&#123;&#125;);//[0,5]；&#123;x = 0, y = 5&#125;=&#123;&#125;；未找到对应属性名，所以得到undefined，解构的默认值生效m1();//[0,5]；&#123;x = 0, y = 5&#125;=&#123;&#125;；未传参数，所以形参的默认值&#123;&#125;生效，参与解构，未解构到对应属性名，所以解构的默认值生效// 写法8function m1(&#123;x = 0, y = 5&#125;=&#123;x:4,y:8&#125;) &#123;// 解构赋值(有默认值)+形参(有默认值，非空对象) return [x, y];&#125;m1(1,3);//[0,5];传入参数跟想要的类型不一致，所以行参默认值生效&#123;x = 0, y = 5&#125;=&#123;&#125;;未找到对应属性名，所以解构默认值生效m1(&#123;x:1,y:3&#125;);//[1,3]；&#123;x = 0, y = 5&#125;=&#123;x:1,y:3&#125;m1(&#123;x:1&#125;);//[1,5]；&#123;x = 0, y = 5&#125;=&#123;x:1&#125; m1(&#123;&#125;);//[0,5]；&#123;x = 0, y = 5&#125;=&#123;&#125;；未找到对应属性名，所以得到undefined，解构的默认值生效m1();//[4,8]；&#123;x = 0, y = 5&#125;=&#123;x:4,y:8&#125;；未传参数，所以形参的默认值&#123;x:4,y:8&#125;生效，参与解构 参数默认值的位置 要设置默认值的参数，应该放在参数列表的尾部，因为这样方便看出调用时省略了哪些参数12345678910111213141516171819// 例一function f(x = 1, y) &#123; return [x, y];&#125;f() // [1, undefined]f(2) // [2, undefined])f(, 1) // 报错f(undefined, 1) // [1, 1]// 例二function f(x, y = 5, z) &#123; return [x, y, z];&#125;f() // [undefined, 5, undefined]f(1) // [1, 5, undefined]f(1, ,2) // 报错f(1, undefined, 2) // [1, 5, 2] 函数的length 返回没有指定默认值的参数个数，指定了默认值后，length属性将失真 123(function (a) &#123;&#125;).length // 1(function (a = 5) &#123;&#125;).length // 0(function (a, b, c = 5) &#123;&#125;).length // 2 如果设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了。 12(function (a = 0, b, c) &#123;&#125;).length // 0(function (a, b = 1, c) &#123;&#125;).length // 1 作用域 一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）。等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的； 设置默认值时，会在形参声明处生成一个单独的作用域。它只可以受全局作用影响，不受函数体内的作用域影响123456789101112131415161718192021222324252627282930313233var x = 1;function f(x, y = x) &#123;// 等价于let x;let y=x;因为形参处已经声明了x，所以y=x后，xy都为同一个值-&gt;实际传进来的值，而不是全局的x console.log(x,y);&#125;f(2) // 2function f(y = x) &#123;// let y=x;外部没有定义x所以报错(形参不受函数体内影响) let x = 2; console.log(y);&#125;f() // ReferenceError: x is not definedvar x = 1;function foo(x = x) &#123;// let x=x;由于tdz，x在声明结束前无法使用x // ...&#125;foo() // ReferenceError: x is not definedlet foo = 'outer';function bar(func = () =&gt; foo) &#123; let foo = 'inner'; console.log(func());&#125;bar(); // outervar x = 1;function foo(x, y = function() &#123; x = 2; &#125;) &#123;// 因为形参出已经有了x,所以y的匿名函数中的x指向的也就是形参处的x，它就不会再受外界影响了 var x = 3;// 在函数体内重新声明了一个x和外界的x不是同一个 y();//调用后，改变的是形参的x console.log(x);// 根据就近原则，找到的是函数体中的x，所以打印不是行参的x，如果去掉var x=3;则打印的是形参的x&#125;foo() // 3x // 1 参数默认值的应用 利用参数默认值，可以指定某一个参数不得省略，如果省略就抛出一个错误12345678910function throwIfMissing() &#123; throw new Error('Missing parameter');&#125;function foo(mustBeProvided = throwIfMissing()) &#123; return mustBeProvided;&#125;foo()// Error: Missing parameter rest参数 用于获取函数的剩余参数，将其保存到一个数组中，这样就不需要使用arguments对象了 1234567891011function add(...values) &#123; let sum = 0; for (var val of values) &#123; sum += val; &#125; return sum;&#125;add(2, 5, 3) // 10 和arguments的区别 arguments是一个类数组，并不是真正的数组 rest得到的是一个真正的数组，可以直接调用数组的方法1234567// arguments变量的写法function sortNumbers() &#123; return Array.prototype.slice.call(arguments).sort();&#125;// rest参数的写法const sortNumbers = (...numbers) =&gt; numbers.sort(); rest参数必须放在形参列表的尾部 1234// 报错function f(a, ...b, c) &#123; // ...&#125; 函数的length属性，不包括 rest 参数。 123(function(a) &#123;&#125;).length // 1(function(...a) &#123;&#125;).length // 0(function(a, ...b) &#123;&#125;).length // 1 严格模式 只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。 12345678910111213141516171819202122232425// 报错function doSomething(a, b = a) &#123; 'use strict'; // code&#125;// 报错const doSomething = function (&#123;a, b&#125;) &#123; 'use strict'; // code&#125;;// 报错const doSomething = (...a) =&gt; &#123; 'use strict'; // code&#125;;const obj = &#123; // 报错 doSomething(&#123;a, b&#125;) &#123; 'use strict'; // code &#125;&#125;; 解决方法 设置全局的严格模式，不推荐 12345'use strict';function doSomething(a, b = a) &#123; // code&#125; 函数包在一个无参数的立即执行函数里面 123456const doSomething = (function () &#123; 'use strict'; return function(value = 42) &#123; return value; &#125;;&#125;()); name属性 返回函数名，es5就有，但es6做了一些修改123456789101112131415161718var f = function () &#123;&#125;;// ES5f.name // \"\"// ES6f.name // \"f\"const bar = function baz() &#123;&#125;;// ES5bar.name // \"baz\"// ES6bar.name // \"baz\"(new Function).name // \"anonymous\"function foo() &#123;&#125;;foo.bind(&#123;&#125;).name // \"bound foo\"(function()&#123;&#125;).bind(&#123;&#125;).name // \"bound \" 箭头函数 基础语法 1234567891011(param1, param2, paramN) =&gt; &#123; 多条语句；return 表达式; &#125;(param1, param2, paramN) =&gt; 表达式// 等价于：(param1, param2, paramN) =&gt; &#123; return 表达式; &#125;/* 当删除大括号时，它将是一个隐式的返回值，这意味着我们不需要指定我们返回*/// 如果只有一个参数，圆括号是可选的:(singleParam) =&gt; &#123; statements;return 表达式; &#125;singleParam =&gt; &#123; statements; return 表达式;&#125;// 如果箭头函数 无参数 , 必须使用 ()圆括号:() =&gt; &#123; statements; return 表达式;&#125; 高级语法 123456789//返回一个对象时，函数体外要加圆括号，否则会被当成语法块，进而语法错误params =&gt; (&#123;foo: bar&#125;)// 支持 剩余参数和默认参数:(param1, param2, ...rest) =&gt; &#123; statements; return 表达式; &#125;(param1 = defaultValue1, param2, …, paramN = defaultValueN) =&gt; &#123; statements; return 表达式; &#125;// 也支持参数列表中的解构赋值let f = ([a, b] = [1, 2], &#123;x: c&#125; = &#123;x: a + b&#125;) =&gt; a + b + c; // a=1; b=2; x=c; c=a+b=3;f(); // 6 注意事项 函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象 准确的说应该是，箭头函数本身没有this，它的this是继承最近父作用域的(更准确的说是直接使用的最近父作用域的this)，即最近父作用域被调用时的this是什么，它的this就是什么；这过程类似变量的溯源查找过程。 1234567891011121314151617181920212223242526// 正常情况function foo()&#123; setTimeout(function()&#123; console.log('id',this.id); &#125;,100); // 会输出21，setTimeout内部是这样的 function setTimeout(fn,delay)&#123; fn();// fn不是做为方法调用，也不是new，更没有使用call、apply、bind做显示绑定，而是属于直接调用，所以内部this指向了window，进而最终输出21 &#125;&#125;var id = 21;foo.call(&#123; id: 42 &#125;);// 21// 箭头函数function foo() &#123; setTimeout(() =&gt; &#123; console.log('id:', this.id); &#125;, 100); // 箭头函数没有this,它的this是用的最近父作用域foo被调用时的this， // foo调用时，this被绑定到了&#123; id: 42 &#125;，所以箭头函数用的this也是&#123; id: 42 &#125;，进而最终输出了42&#125;var id = 21;foo.call(&#123; id: 42 &#125;);// 42 如何快速判断箭头函数的this，直接找它定义时的直接父函数或者直接父对象 12345678function foo() &#123; setTimeout(() =&gt; &#123;// 这个箭头函数定义时，直接父函数为foo，所以它的this是foo被调用时的this console.log(&apos;id:&apos;, this.id); &#125;, 100);&#125;var id = 21;foo.call(&#123; id: 42 &#125;);// 42 箭头函数没有arguments、super、new.target，如果要使用arguments，可以用rest参数代替 12345678function foo() &#123; setTimeout(() =&gt; &#123; console.log('args:', arguments); &#125;, 100);&#125;foo(2, 4, 6, 8)// args: [2, 4, 6, 8] 箭头函数没有自己的this，所以更不能使用call、apply、bind，这些方法无法改变this的指向 123456(function() &#123; return [ (() =&gt; this.x).bind(&#123; x: &apos;inner&apos; &#125;)() ];&#125;).call(&#123; x: &apos;outer&apos; &#125;);// [&apos;outer&apos;] 箭头函数不能使用new，否则会报错 尾调用优化 尾调用 指某个函数的最后一步是调用另一个函数 12345678910111213141516171819function f(x)&#123; return g(x);&#125;// 情况一function f(x)&#123; let y = g(x); return y;&#125;// 情况二function f(x)&#123; return g(x) + 1;&#125;// 情况三function f(x)&#123; g(x);&#125; 尾调用不一定出现在函数尾部，只要是最后一步操作即可 123456function f(x) &#123; if (x &gt; 0) &#123; return m(x) &#125; return n(x);&#125; 尾调用优化 如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。如果函数B内部还调用函数C，那就还有一个C的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。 尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。 123456789101112131415function f() &#123; let m = 1; let n = 2; return g(m + n);&#125;f();// 等同于function f() &#123; return g(3);&#125;f();// 等同于g(3); 上面代码中，如果函数g不是尾调用，函数f就需要保存内部变量m和n的值、g的调用位置等信息。但由于调用g之后，函数f就结束了，所以执行到最后一步，完全可以删除f(x)的调用帧，只保留g(3)的调用帧。 只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。 尾递归 函数调用自身，称为递归。如果尾调用自身，就称为尾递归 递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误1234567891011121314// 普通递归function factorial(n) &#123; if (n === 1) return 1; return n * factorial(n - 1);&#125;factorial(5) // 120// 尾递归function factorial(n, total) &#123; if (n === 1) return total; return factorial(n - 1, n * total);&#125;factorial(5, 1) // 120 递归函数的改写 尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。 比如上面的例子，阶乘函数 factorial 需要用到一个中间变量total，那就把这个中间变量改写成函数的参数。123456function factorial(n, total = 1) &#123; if (n === 1) return total; return factorial(n - 1, n * total);&#125;factorial(5) // 120 ES6 的尾调用优化只在严格模式下开启，正常模式是无效的 非严格模式下，可以通过将递归改写成循环，进而模拟尾递归调用的优化效果(减少调用帧) 数组的扩展扩展运算符 可以理解为rest参数的逆运算；rest参数是将逗号分隔的参数列表转换成数组，而扩展运算符号则是将数组转换成逗号分隔的列表 1234567891011121314151617console.log(...[1, 2, 3])// 1 2 3console.log(1, ...[2, 3, 4], 5)// 1 2 3 4 5[...document.querySelectorAll('div')]// [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;]let arr=[];const numbers = [4, 38];function push(array, ...items) &#123;// arr,[4,38] array.push(...items);// items为数组，无法做为push的参数，所以使用了扩展运算符，转换成了参数列表&#125;push(arr,...numbers);// 相当于push(arr,4,38)console.log(arr);//[4,38] 扩展运算符与正常的函数参数可以结合使用，非常灵活 123function f(v, w, x, y, z) &#123; &#125;const args = [0, 1];f(-1, ...args, 2, ...[3]); 用途 替代数组的apply方法 1234567891011121314151617181920212223// ES5 的写法function f(x, y, z) &#123; // ...&#125;var args = [0, 1, 2];f.apply(null, args);// ES6的写法function f(x, y, z) &#123; // ...&#125;let args = [0, 1, 2];f(...args);// 取最大值// ES5 的写法Math.max.apply(null, [14, 3, 77])// ES6 的写法Math.max(...[14, 3, 77])// 等同于Math.max(14, 3, 77); 合并数组 12345678910111213141516// ES5[1, 2].concat(more)// ES6[1, 2, ...more]var arr1 = ['a', 'b'];var arr2 = ['c'];var arr3 = ['d', 'e'];// ES5的合并数组arr1.concat(arr2, arr3);// [ 'a', 'b', 'c', 'd', 'e' ]// ES6的合并数组[...arr1, ...arr2, ...arr3]// [ 'a', 'b', 'c', 'd', 'e' ] 扩展运算符可以与解构赋值结合起来，用于生成数组 12345678910111213141516// ES5a = list[0], rest = list.slice(1)// ES6[a, ...rest] = listconst [first, ...rest] = [1, 2, 3, 4, 5];first // 1rest // [2, 3, 4, 5]const [first, ...rest] = [];first // undefinedrest // []const [first, ...rest] = [\"foo\"];first // \"foo\"rest // [] 如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。12345const [...butLast, last] = [1, 2, 3, 4, 5];// 报错const [first, ...middle, last] = [1, 2, 3, 4, 5];// 报错 函数返回值 12let dateFields = readDateFields(database);let d = new Date(...dateFields);// Data不接收数组，所以转换成参数列表 字符串转数组 12[...'hello']// [ \"h\", \"e\", \"l\", \"l\", \"o\" ] 实现了Iterator接口的对象，都能转换成数组 12345678910111213141516let nodeList = document.querySelectorAll('div');// nodelist有Iterator接口，所以可以转换成数组let array = [...nodeList];let map = new Map([// Map有Iterator接口 [1, 'one'], [2, 'two'], [3, 'three'],]);let arr = [...map.keys()]; // [1, 2, 3]const go = function*()&#123;// Generator 函数运行后，返回一个遍历器对象，因此也可以使用扩展运算符。 yield 1; yield 2; yield 3;&#125;;[...go()] // [1, 2, 3] Array.from 将类似数组的对象（array-like object）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map）转换成数组 所谓类似数组的对象，本质特征只有一点，即必须有length属性。因此，任何有length属性的对象，都可以通过Array.from方法转为数组，而此时扩展运算符就无法转换12345678910111213141516171819202122232425262728293031let arrayLike = &#123; '0': 'a', '1': 'b', '2': 'c', length: 3&#125;;// ES5的写法var arr1 = [].slice.call(arrayLike); // ['a', 'b', 'c']// ES6的写法let arr2 = Array.from(arrayLike); // ['a', 'b', 'c']// NodeList对象let ps = document.querySelectorAll('p');Array.from(ps).forEach(function (p) &#123; console.log(p);&#125;);// arguments对象function foo() &#123; var args = Array.from(arguments); // ...&#125;Array.from('hello')// es6中字符串有Iterator接口// ['h', 'e', 'l', 'l', 'o']let namesSet = new Set(['a', 'b'])Array.from(namesSet) // ['a', 'b']Array.from(&#123; length: 2 &#125;, () =&gt; 'jack')// 对象有length，所以是类数组对象，可以用from转换// ['jack', 'jack'] Array.of() Array.of方法用于将一组值，转换为数组。弥补数组构造函数Array()的不足，因为参数个数的不同，会导致Array()的行为有差异。 Array.of总是返回参数值组成的数组。如果没有参数，就返回一个空数组。1234567Array() // []Array(3) // [, , ,]，只有一个参数时，是指定的数组长度Array(3, 11, 8) // [3, 11, 8]Array.of(3, 11, 8) // [3,11,8]Array.of(3) // [3]Array.of(3).length // 1 数组实例的 copyWithin() 将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组，所以会修改当前数组1234567891011121314151617181920212223242526272829Array.prototype.copyWithin(target, start = 0, end = this.length)target（必需）：从该位置开始替换数据。start（可选）：从该位置开始读取数据，默认为0。如果为负值，表示倒数。end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。[1, 2, 3, 4, 5].copyWithin(0, 3)// 读取从索引3开始到结束的数据4,5并替换从0开始的数据// [4, 5, 3, 4, 5]// 将3号位复制到0号位[1, 2, 3, 4, 5].copyWithin(0, 3, 4)// [4, 2, 3, 4, 5]// -2相当于3号位，-1相当于4号位[1, 2, 3, 4, 5].copyWithin(0, -2, -1)// [4, 2, 3, 4, 5]// 将3号位复制到0号位[].copyWithin.call(&#123;length: 5, 3: 1&#125;, 0, 3)// &#123;0: 1, 3: 1, length: 5&#125;// 将2号位到数组结束，复制到0号位let i32a = new Int32Array([1, 2, 3, 4, 5]);i32a.copyWithin(0, 2);// Int32Array [3, 4, 5, 4, 5]// 对于没有部署 TypedArray 的 copyWithin 方法的平台// 需要采用下面的写法[].copyWithin.call(new Int32Array([1, 2, 3, 4, 5]), 0, 3, 4);// Int32Array [4, 2, 3, 4, 5] 数组实例的 find() 和 findIndex() 数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined 123456[1, 4, -5, 10].find((n) =&gt; n &lt; 0)// -5[1, 5, 10, 15].find(function(value, index, arr) &#123;//当前值，索引，原数组 return value &gt; 9;&#125;) // 10 返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1 123[1, 5, 10, 15].findIndex(function(value, index, arr) &#123; return value &gt; 9;&#125;) // 2 数组实例的fill() fill方法使用给定值，填充一个数组。12345678['a', 'b', 'c'].fill(7)// [7, 7, 7]new Array(3).fill(7)// [7, 7, 7]['a', 'b', 'c'].fill(7, 1, 2)// 将7填充到[1,2)区间// ['a', 7, 'c'] 数组实例的 entries()，keys() 和 values() entries()，keys()和values()——用于遍历数组。它们都返回一个遍历器对象，可以用for…of循环进行遍历，唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。1234567891011121314151617for (let index of ['a', 'b'].keys()) &#123; console.log(index);&#125;// 0// 1for (let elem of ['a', 'b'].values()) &#123; console.log(elem);&#125;// 'a'// 'b'for (let [index, elem] of ['a', 'b'].entries()) &#123; console.log(index, elem);&#125;// 0 \"a\"// 1 \"b\" 数组实例的 includes() Array.prototype.includes方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似123[1, 2, 3].includes(2) // true[1, 2, 3].includes(4) // false[1, 2, NaN].includes(NaN) // true 数组的空位 数组的空位指，数组的某一个位置没有任何值。比如，Array构造函数返回的数组都是空位。 1Array(3) // [, , ,] 空位不是undefined，一个位置的值等于undefined，依然是有值的。空位是没有任何值，in运算符可以说明这一点 120 in [undefined, undefined, undefined] // true0 in [, , ,] // false ES5 对空位的处理，已经很不一致了，大多数情况下会忽略空位；ES6 则是明确将空位转为undefined。 12345678910111213141516171819202122232425262728293031Array.from(['a',,'b'])// [ \"a\", undefined, \"b\" ][...['a',,'b']]// [ \"a\", undefined, \"b\" ][,'a','b',,].copyWithin(2,0) // [,\"a\",,\"a\"]new Array(3).fill('a') // [\"a\",\"a\",\"a\"]let arr = [, ,];for (let i of arr) &#123; console.log(1);&#125;// 1// 1// entries()[...[,'a'].entries()] // [[0,undefined], [1,\"a\"]]// keys()[...[,'a'].keys()] // [0,1]// values()[...[,'a'].values()] // [undefined,\"a\"]// find()[,'a'].find(x =&gt; true) // undefined// findIndex()[,'a'].findIndex(x =&gt; true) // 0 对象的扩展属性的简洁表示法 ES6允许直接写入变量和函数，作为对象的属性和方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576const foo = 'bar';const baz = &#123;foo&#125;;baz // &#123;foo: \"bar\"&#125;// 等同于const baz = &#123;foo: foo&#125;;// 属性简写function f(x, y) &#123; return &#123;x, y&#125;;&#125;// 等同于function f(x, y) &#123; return &#123;x: x, y: y&#125;;&#125;f(1, 2) // Object &#123;x: 1, y: 2&#125;// 方法简写const o = &#123; method() &#123; return \"Hello!\"; &#125;&#125;;// 等同于const o = &#123; method: function() &#123; return \"Hello!\"; &#125;&#125;;// 实际例子let birth = '2000/01/01';const Person = &#123; name: '张三', //等同于birth: birth birth, // 等同于hello: function ()... hello() &#123; console.log('我的名字是', this.name); &#125;&#125;;// 用在函数返回值function getPoint() &#123; const x = 1; const y = 10; return &#123;x, y&#125;;&#125;getPoint()// &#123;x:1, y:10&#125;// 属性的赋值器（setter）和取值器（getter），事实上也是采用这种写法const cart = &#123; _wheels: 4, get wheels () &#123; return this._wheels; &#125;, set wheels (value) &#123; if (value &lt; this._wheels) &#123; throw new Error('数值太小了！'); &#125; this._wheels = value; &#125;&#125;// 简洁写法的属性名总是字符串，这会导致一些看上去比较奇怪的结果const obj = &#123; class () &#123;&#125;&#125;;// 等同于var obj = &#123; 'class': function() &#123;&#125;&#125;;// 如果某个方法的值是一个 Generator 函数，前面需要加上星号const obj = &#123; * m() &#123; yield 'hello world'; &#125;&#125;; 属性名表达式 ES6 允许字面量定义对象时，用表达式作为对象的属性名，即把表达式放在方括号内。12345678910111213141516171819202122232425262728293031323334let lastWord = 'last word';const a = &#123; 'first word': 'hello', [lastWord]: 'world'&#125;;a['first word'] // \"hello\"a[lastWord] // \"world\"a['last word'] // \"world\"// 表达式还可以用于定义方法名let obj = &#123; ['h' + 'ello']() &#123; return 'hi'; &#125;&#125;;obj.hello() // hi// 属性名表达式与简洁表示法，不能同时使用，会报错// 报错const foo = 'bar';const bar = 'abc';const baz = &#123; [foo] &#125;;// 正确const foo = 'bar';const baz = &#123; [foo]: 'abc'&#125;;// 属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串[object Object]const keyA = &#123;a: 1&#125;;const keyB = &#123;b: 2&#125;;const myObject = &#123; [keyA]: 'valueA', [keyB]: 'valueB'&#125;;myObject // Object &#123;[object Object]: \"valueB\"&#125; 方法的 name 属性 函数的name属性，返回函数名。对象方法也是函数，因此也有name属性123456789101112const person = &#123; sayName() &#123; console.log('hello!'); &#125;,&#125;;person.sayName.name // \"sayName\"(new Function()).name // \"anonymous\"var doSomething = function() &#123; // ...&#125;;doSomething.bind().name // \"bound doSomething\" Object.is() ES5 比较两个值是否相等，只有两个运算符：相等运算符（==）和严格相等运算符（===）。它们都有缺点，前者会自动转换数据类型，后者的NaN不等于自身，以及+0等于-0。 Object.is它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。和===不同点在于一是+0不等于-0，二是NaN等于自身12345+0 === -0 //trueNaN === NaN // falseObject.is(+0, -0) // falseObject.is(NaN, NaN) // true Object.assign() 类似jQuery的$.extend()方法，可用来合并对象 1234567891011121314const target = &#123; a: 1 &#125;;const source1 = &#123; b: 2 &#125;;const source2 = &#123; c: 3 &#125;;Object.assign(target, source1, source2);target // &#123;a:1, b:2, c:3&#125;// 重名属性，后面对象会覆盖前面的const target = &#123; a: 1, b: 1 &#125;;const source1 = &#123; b: 2, c: 2 &#125;;const source2 = &#123; c: 3 &#125;;Object.assign(target, source1, source2);target // &#123;a:1, b:2, c:3&#125; Object.assign拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（enumerable: false） 1234567Object.assign(&#123;b: 'c'&#125;, Object.defineProperty(&#123;&#125;, 'invisible', &#123; enumerable: false, value: 'hello' &#125;))// &#123; b: 'c' &#125; Object.assign方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用 12345678910const obj1 = &#123;a: &#123;b: 1&#125;&#125;;const obj2 = Object.assign(&#123;&#125;, obj1);obj1.a.b = 2;obj2.a.b // 2// 同名属性，直接替换引用const target = &#123; a: &#123; b: 'c', d: 'e' &#125; &#125;const source = &#123; a: &#123; b: 'hello' &#125; &#125;Object.assign(target, source);// &#123; a: &#123; b: 'hello' &#125; &#125; Object.assign可以用来处理数组，但是会把数组视为对象 12Object.assign([1, 2, 3], [4, 5])// [4, 5, 3] 用途 为对象添加属性 12345class Point &#123; constructor(x, y) &#123; Object.assign(this, &#123;x, y&#125;);// 将x属性和y属性添加到Point类的对象实例 &#125;&#125; 为对象添加方法 12345678910111213141516Object.assign(SomeClass.prototype, &#123; someMethod(arg1, arg2) &#123; ··· &#125;, anotherMethod() &#123; ··· &#125;&#125;);// 等同于下面的写法SomeClass.prototype.someMethod = function (arg1, arg2) &#123; ···&#125;;SomeClass.prototype.anotherMethod = function () &#123; ···&#125;; 克隆对象 12345678910// 克隆原始对象自身的值，不能克隆它继承的值function clone(origin) &#123; return Object.assign(&#123;&#125;, origin);&#125;// 克隆同时保持继承链function clone(origin) &#123; let originProto = Object.getPrototypeOf(origin); return Object.assign(Object.create(originProto), origin);&#125; 合并多个对象 12345// 将多个对象合并到某个对象const merge = (target, ...sources) =&gt; Object.assign(target, ...sources);// 合并后返回一个新对象const merge = (...sources) =&gt; Object.assign(&#123;&#125;, ...sources); 为属性指定默认值 12345678910const DEFAULTS = &#123; logLevel: 0, outputFormat: 'html'&#125;;function processContent(options) &#123; options = Object.assign(&#123;&#125;, DEFAULTS, options); console.log(options); // ...&#125; 属性的可枚举性和遍历 Object.getOwnPropertyDescriptor方法可以获取该属性的描述对象 12345678let obj = &#123; foo: 123 &#125;;Object.getOwnPropertyDescriptor(obj, 'foo')// &#123;// value: 123,// writable: true,// enumerable: true,// configurable: true// &#125; 四个操作会忽略enumerable为false的属性 for…in循环：只遍历对象自身的和继承的可枚举的属性。 Object.keys()：返回对象自身的所有可枚举的属性的键名。 JSON.stringify()：只串行化对象自身的可枚举的属性。 Object.assign()： 忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性。 只有for…in会返回继承的属性，其他三个方法都会忽略继承的属性，只处理对象自身的属性 总的来说，操作中引入继承的属性会让问题复杂化，大多数时候，我们只关心对象自身的属性。所以，尽量不要用for…in循环，而用Object.keys()代替。 属性遍历 for…in for…in循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性） Object.keys(obj) Object.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性） Object.getOwnPropertyNames(obj) Object.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性） Object.getOwnPropertySymbols(obj) Object.getOwnPropertySymbols返回一个数组，包含对象自身的所有 Symbol 属性。 Reflect.ownKeys(obj) Reflect.ownKeys返回一个数组，包含对象自身的所有属性，不管属性名是 Symbol 或字符串，也不管是否可枚举。 遍历规则 首先遍历所有属性名为数值的属性，按照数字排序。 其次遍历所有属性名为字符串的属性，按照生成时间排序。 最后遍历所有属性名为 Symbol 值的属性，按照生成时间排序。12Reflect.ownKeys(&#123; [Symbol()]:0, b:0, 10:0, 2:0, a:0 &#125;)// ['2', '10', 'b', 'a', Symbol()] Object.getOwnPropertyDescriptors 返回指定对象所有自身属性（非继承属性）的描述对象。 12345678910111213141516const obj = &#123; foo: 123, get bar() &#123; return 'abc' &#125;&#125;;Object.getOwnPropertyDescriptors(obj)// &#123; foo:// &#123; value: 123,// writable: true,// enumerable: true,// configurable: true &#125;,// bar:// &#123; get: [Function: bar],// set: undefined,// enumerable: true,// configurable: true &#125; &#125; 主要是为了解决Object.assign()无法正确拷贝get属性和set属性的问题。 1234567891011121314151617181920212223242526272829303132const source = &#123; set foo(value) &#123; console.log(value); &#125;&#125;;const target1 = &#123;&#125;;Object.assign(target1, source);Object.getOwnPropertyDescriptor(target1, 'foo')// &#123; value: undefined,// writable: true,// enumerable: true,// configurable: true &#125;// 正确拷贝set方法const source = &#123; set foo(value) &#123; console.log(value); &#125;&#125;;const target2 = &#123;&#125;;Object.defineProperties(target2, Object.getOwnPropertyDescriptors(source));Object.getOwnPropertyDescriptor(target2, 'foo')// &#123; get: undefined,// set: [Function: foo],// enumerable: true,// configurable: true &#125;// 上面代码中，两个对象合并的逻辑可以写成一个函数。const shallowMerge = (target, source) =&gt; Object.defineProperties( target, Object.getOwnPropertyDescriptors(source)); 配合Object.create方法，将对象属性克隆到一个新对象。这属于浅拷贝 1234567const clone = Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));// 或者const shallowClone = (obj) =&gt; Object.create( Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj)); proto属性，Object.setPrototypeOf()，Object.getPrototypeOf() proto属性（前后各两个下划线），用来读取或设置当前对象的prototype对象，浏览器内部方法 123456789// es6的写法const obj = &#123; method: function() &#123; ... &#125;&#125;;obj.__proto__ = someOtherObj;// es5的写法var obj = Object.create(someOtherObj);obj.method = function() &#123; ... &#125;; Object.setPrototypeOf() Object.setPrototypeOf方法的作用与proto相同，用来设置一个对象的prototype对象，返回参数对象本身。它是 ES6 正式推荐的设置原型对象的方法12345678910// 格式Object.setPrototypeOf(object, prototype)// 用法const o = Object.setPrototypeOf(&#123;&#125;, null);// 等同于function (obj, proto) &#123; obj.__proto__ = proto; return obj;&#125; Object.getPrototypeOf() 该方法与Object.setPrototypeOf方法配套，用于读取一个对象的原型对象123456789101112function Rectangle() &#123; // ...&#125;const rec = new Rectangle();Object.getPrototypeOf(rec) === Rectangle.prototype// trueObject.setPrototypeOf(rec, Object.prototype);Object.getPrototypeOf(rec) === Rectangle.prototype// false Object.keys()，Object.values()，Object.entries() Object.keys方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名 Object.values方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值 Object.entries方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组 123456789101112131415161718var obj = &#123; foo: 'bar', baz: 42 &#125;;Object.keys(obj)// [\"foo\", \"baz\"]let &#123;keys, values, entries&#125; = Object;let obj = &#123; a: 1, b: 2, c: 3 &#125;;for (let key of keys(obj)) &#123; console.log(key); // 'a', 'b', 'c'&#125;for (let value of values(obj)) &#123; console.log(value); // 1, 2, 3&#125;for (let [key, value] of entries(obj)) &#123; console.log([key, value]); // ['a', 1], ['b', 2], ['c', 3]&#125; Object.entries的基本用途是遍历对象的属性 12345678let obj = &#123; one: 1, two: 2 &#125;;for (let [k, v] of Object.entries(obj)) &#123; console.log( `$&#123;JSON.stringify(k)&#125;: $&#123;JSON.stringify(v)&#125;` );&#125;// \"one\": 1// \"two\": 2 对象的扩展运算符 解构赋值 123456789101112let &#123; x, y, ...z &#125; = &#123; x: 1, y: 2, a: 3, b: 4 &#125;;x // 1y // 2z // &#123; a: 3, b: 4 &#125;// 解构赋值不会拷贝继承自原型对象的属性。let o1 = &#123; a: 1 &#125;;let o2 = &#123; b: 2 &#125;;o2.__proto__ = o1;let &#123; ...o3 &#125; = o2;o3 // &#123; b: 2 &#125;o3.a // undefined 可用于取出参数对象的所有可遍历属性，拷贝到当前对象之中，这等同于使用Object.assign方法。它只拷贝了对象实例的属性 1234567891011121314151617181920let z = &#123; a: 3, b: 4 &#125;;let n = &#123; ...z &#125;;n // &#123; a: 3, b: 4 &#125;let aClone = &#123; ...a &#125;;// 等同于let aClone = Object.assign(&#123;&#125;, a);// 想完整克隆一个对象，还拷贝对象原型的属性// 写法一const clone1 = &#123; __proto__: Object.getPrototypeOf(obj), ...obj&#125;;// 写法二const clone2 = Object.assign( Object.create(Object.getPrototypeOf(obj)), obj); 用于合并两个对象 123let ab = &#123; ...a, ...b &#125;;// 等同于let ab = Object.assign(&#123;&#125;, a, b); Null 传导运算符 如果读取对象内部的某个属性，往往需要判断一下该对象是否存在 123456789101112131415// 以前写法const firstName = (message &amp;&amp; message.body &amp;&amp; message.body.user &amp;&amp; message.body.user.firstName) || 'default';// 现在写法// 如果 a 是 null 或 undefined, 返回 undefined// 否则返回 a.b.c().da?.b.c().d// 如果 a 是 null 或 undefined，下面的语句不产生任何效果// 否则执行 a.b = 42a?.b = 42// 如果 a 是 null 或 undefined，下面的语句不产生任何效果delete a?.b Symbol是啥？ Symbol 是一种特殊的、不可变的数据类型，可以作为对象属性的标识符使用，用它创建的属性名是绝对唯一的，不会产生冲突；Symbol 数据类型是一个原始数据类型； 创建 12345let s = Symbol();typeof s // \"symbol\"let s1 = Symbol('foo');s1 // Symbol(foo) 通过Symbol()创建的symbol与其他任何值都不相等 123456789// 没有参数的情况let s1 = Symbol();let s2 = Symbol();s1 === s2 // false// 有参数的情况let s1 = Symbol('foo');let s2 = Symbol('foo');s1 === s2 // false Symbol 值不能与其他类型的值进行运算 12345let sym = Symbol('My symbol');\"your symbol is \" + sym// TypeError: can't convert symbol to string`your symbol is $&#123;sym&#125;`// TypeError: can't convert symbol to string Symbol 值可以显式转为字符串，也可以转为布尔值，但是不能转为数值。 123456789101112131415// Symbol 值可以显式转为字符串let sym = Symbol('My symbol');String(sym) // 'Symbol(My symbol)'sym.toString() // 'Symbol(My symbol)'let sym = Symbol();Boolean(sym) // true!sym // falseif (sym) &#123; // ...&#125;Number(sym) // TypeErrorsym + 2 // TypeError 做为属性名使用 1234567891011121314151617let mySymbol = Symbol();// 第一种写法let a = &#123;&#125;;a[mySymbol] = 'Hello!';// 第二种写法let a = &#123;// 对象的增强属性名写法 [mySymbol]: 'Hello!'&#125;;// 第三种写法let a = &#123;&#125;;Object.defineProperty(a, mySymbol, &#123; value: 'Hello!' &#125;);// 以上写法都得到同样结果a[mySymbol] // \"Hello!\" 做为属性名使用时，不能使用.语法，使用点语法会被当成字符串处理123456const mySymbol = Symbol();const a = &#123;&#125;;a.mySymbol = 'Hello!';a[mySymbol] // undefineda['mySymbol'] // \"Hello!\" 属性名的遍历 Symbol 作为属性名，该属性不会出现在for…in、for…of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回。但是，它也不是私有属性，有一个Object.getOwnPropertySymbols方法，可以获取指定对象的所有 Symbol 属性名。1234567891011const obj = &#123;&#125;;let a = Symbol('a');let b = Symbol('b');obj[a] = 'Hello';obj[b] = 'World';const objectSymbols = Object.getOwnPropertySymbols(obj);objectSymbols// [Symbol(a), Symbol(b)] Symbol的共享(重复使用) 有时，我们想重复使用某个Symbol，我们知道通过Symbol()方法，生成的symbol是绝对唯一的，即使描述符一样 123let s1 = Symbol('foo');let s2 = Symbol('foo');s1===s2 // false Symbol.for方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的Symbol值。如果有，就返回这个Symbol值，否则就新建并返回一个以该字符串为名称的Symbol值 123456789let s1 = Symbol.for('foo');let s2 = Symbol.for('foo');s1 === s2 // trueSymbol.for(\"bar\") === Symbol.for(\"bar\")// trueSymbol(\"bar\") === Symbol(\"bar\")// false 用Symbol实现单例模式 传统实现 123456789101112// mod.jsfunction A() &#123; this.foo = 'hello';&#125;if (!global._foo) &#123; global._foo = new A();&#125;module.exports = global._foo;// 加载const a = require('./mod.js');console.log(a.foo); 全局变量global._foo是可写的，任何文件都可以修改 使用Symbol 123456789101112// mod.jsconst FOO_KEY = Symbol.for('foo');function A() &#123; this.foo = 'hello';&#125;if (!global[FOO_KEY]) &#123; global[FOO_KEY] = new A();&#125;module.exports = global[FOO_KEY]; 上面代码中，可以保证global[FOO_KEY]不会被无意间覆盖，但还是可以被改写12const a = require('./mod.js');global[Symbol.for('foo')] = 123; Set和Map数据结构Set数据结构 它类似于数组，但是成员的值都是唯一的，没有重复的值。 使用new Set()创建 12345678const s = new Set();[2, 3, 5, 4, 5, 2, 2].forEach(x =&gt; s.add(x));for (let i of s) &#123; console.log(i);&#125;// 2 3 5 4，重复值不会被保留 Set 函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化 1234567891011121314151617181920// 例一const set = new Set([1, 2, 3, 4, 4]);[...set]// [1, 2, 3, 4]，自动删除了重复的值，可利用这方法实现数组去重// 例二const items = new Set([1, 2, 3, 4, 5, 5, 5, 5]);items.size // 5// 例三function divs () &#123; return [...document.querySelectorAll('div')];&#125;const set = new Set(divs());set.size // 56// 类似于divs().forEach(div =&gt; set.add(div));set.size // 56 Set判断值是否重复，类似===，不过NaN等于自身；任意两个对象是不相等的 123456789101112let set = new Set();let a = NaN;let b = NaN;set.add(a);set.add(b);set // Set &#123;NaN&#125;let set = new Set();set.add(&#123;&#125;);set.size // 1set.add(&#123;&#125;);set.size // 2 属性和方法 属性 Set.prototype.constructor：构造函数，默认就是Set函数。 Set.prototype.size：返回Set实例的成员总数。 操作方法 add(value)：添加某个值，返回Set结构本身。 delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。 has(value)：返回一个布尔值，表示该值是否为Set的成员。 clear()：清除所有成员，没有返回值。 遍历方法 keys()：返回键名的遍历器 values()：返回键值的遍历器 entries()：返回键值对的遍历器 forEach()：使用回调函数遍历每个成员12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455s.add(1).add(2).add(2);// 注意2被加入了两次s.size // 2s.has(1) // trues.has(2) // trues.has(3) // falses.delete(2);s.has(2) // falselet set = new Set(['red', 'green', 'blue']);for (let item of set.keys()) &#123; console.log(item);&#125;// red// green// bluefor (let item of set.values()) &#123; console.log(item);&#125;// red// green// bluefor (let item of set.entries()) &#123; console.log(item);&#125;// [\"red\", \"red\"]// [\"green\", \"green\"]// [\"blue\", \"blue\"]// 可直接使用for..of遍历let set = new Set(['red', 'green', 'blue']);for (let x of set) &#123; console.log(x);&#125;// red// green// bluelet set = new Set([1, 2, 3]);set.forEach((value, key) =&gt; console.log(value * 2) )// 使用forEach做附加操作// 2// 4// 6// set配合filter完成交集、并集、差集let a = new Set([1, 2, 3]);let b = new Set([4, 3, 2]);// 并集let union = new Set([...a, ...b]);// Set &#123;1, 2, 3, 4&#125;// 交集let intersect = new Set([...a].filter(x =&gt; b.has(x)));// set &#123;2, 3&#125;// 差集let difference = new Set([...a].filter(x =&gt; !b.has(x)));// Set &#123;1&#125; Array.from方法可以将 Set 结构转为数组。 12345678const items = new Set([1, 2, 3, 4, 5]);const array = Array.from(items);// 利用from方法完成数组的去重function dedupe(array) &#123; return Array.from(new Set(array));&#125;dedupe([1, 1, 2, 3]) // [1, 2, 3] WeakSet WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别 WeakSet 的成员只能是对象，而不能是其他类型的值 垃圾回收机制不考虑 WeakSet 对该对象的引用；如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中 WeakSet 适合临时存放一组对象，以及存放跟对象绑定的信息。只要这些对象在外部消失，它在 WeakSet 里面的引用就会自动消失 WeakSet 的成员是不适合引用的，因为它会随时消失 由于 WeakSet 内部有多少个成员，取决于垃圾回收机制有没有运行，运行前后很可能成员个数是不一样的，而垃圾回收机制何时运行是不可预测的，因此 ES6 规定 WeakSet 不可遍历1234567891011121314const ws = new WeakSet();ws.add(1)// TypeError: Invalid value used in weak setws.add(Symbol())// TypeError: invalid value used in weak set// WeakSet 可以接受一个数组或类似数组的对象作为参数(实际上，任何具有 Iterable 接口的对象，都可以作为 WeakSet 的参数)const a = [[1, 2], [3, 4]];const ws = new WeakSet(a);// 会将a数组的成员添加到ws中，而不是a数组自身；所以数组成员必须是对象// WeakSet &#123;[1, 2], [3, 4]&#125;const b = [3, 4];const ws = new WeakSet(b); // b的成员不是对象，所以会出错// Uncaught TypeError: Invalid value used in weak set(…) 方法 add、delete、has，同set相比没有clear方法1234567891011121314151617const ws = new WeakSet();const obj = &#123;&#125;;const foo = &#123;&#125;;ws.add(window);ws.add(obj);ws.has(window); // truews.has(foo); // falsews.delete(window);ws.has(window); // false// WeakSet没有size属性，没有办法遍历它的成员。ws.size // undefinedws.forEach // undefinedws.forEach(function(item)&#123; console.log('WeakSet has ' + item)&#125;)// TypeError: undefined is not a function Map数据结构 类似Object结构，都是key-value结构，不同的地方是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。 提供了一种更加灵活方便的一一映射的结构 123456789101112131415161718192021222324252627282930const m = new Map();const o = &#123;p: 'Hello World'&#125;;m.set(o, 'content')m.get(o) // \"content\"m.has(o) // truem.delete(o) // truem.has(o) // false// 接收数组做为参数const map = new Map([ ['name', '张三'], ['title', 'Author']]);map.size // 2map.has('name') // truemap.get('name') // \"张三\"map.has('title') // truemap.get('title') // \"Author\"// 上面的等同于const items = [ ['name', '张三'], ['title', 'Author']];const map = new Map();items.forEach(// 取得每个item的key,value，然后再添加到map中 ([key, value]) =&gt; map.set(key, value)); 属性和方法 属性 size属性返回 Map 结构的成员总数。 操作方法 set方法设置键名key对应的键值为value，然后返回整个 Map 结构。如果key已经有值，则键值会被更新，否则就新生成该键。 get方法读取key对应的键值，如果找不到key，返回undefined。 has方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。 delete方法删除某个键，返回true。如果删除失败，返回false。 clear方法清除所有成员，没有返回值。 遍历方法 keys()：返回键名的遍历器。 values()：返回键值的遍历器。 entries()：返回所有成员的遍历器。 forEach()：遍历 Map 的所有成员12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697// sizeconst map = new Map();map.set('foo', true);map.set('bar', false);map.size // 2// setconst m = new Map();m.set('edition', 6) // 键是字符串m.set(262, 'standard') // 键是数值m.set(undefined, 'nah') // 键是 undefined// set方法返回的是当前的Map对象，因此可以采用链式写法。let map = new Map() .set(1, 'a') .set(2, 'b') .set(3, 'c');// getconst m = new Map();const hello = function() &#123;console.log('hello');&#125;;m.set(hello, 'Hello ES6!') // 键是函数m.get(hello) // Hello ES6!// hasconst m = new Map();m.set('edition', 6);m.set(262, 'standard');m.set(undefined, 'nah');m.has('edition') // truem.has('years') // falsem.has(262) // truem.has(undefined) // true// deleteconst m = new Map();m.set(undefined, 'nah');m.has(undefined) // truem.delete(undefined)m.has(undefined) // false// clearlet map = new Map();map.set('foo', true);map.set('bar', false);map.size // 2map.clear()map.size // 0// 遍历方法const map = new Map([ ['F', 'no'], ['T', 'yes'],]);for (let key of map.keys()) &#123; console.log(key);&#125;// \"F\"// \"T\"for (let value of map.values()) &#123; console.log(value);&#125;// \"no\"// \"yes\"for (let item of map.entries()) &#123; console.log(item[0], item[1]);&#125;// \"F\" \"no\"// \"T\" \"yes\"// 或者for (let [key, value] of map.entries()) &#123; console.log(key, value);&#125;// \"F\" \"no\"// \"T\" \"yes\"// 等同于使用map.entries()for (let [key, value] of map) &#123; console.log(key, value);&#125;// \"F\" \"no\"// \"T\" \"yes\"// forEach，第二个参数可以绑定thisconst reporter = &#123; report: function(key, value) &#123; console.log(\"Key: %s, Value: %s\", key, value); &#125;&#125;;map.forEach(function(value, key, map) &#123; this.report(key, value);&#125;, reporter); map转数组可以使用...扩展运算符 1234567891011121314151617const map = new Map([ [1, 'one'], [2, 'two'], [3, 'three'],]);[...map.keys()]// [1, 2, 3][...map.values()]// ['one', 'two', 'three'][...map.entries()]// [[1,'one'], [2, 'two'], [3, 'three']][...map]// [[1,'one'], [2, 'two'], [3, 'three']] 结合数组的map方法、filter方法，可以实现 Map 的遍历和过滤（Map 本身没有map和filter方法） 1234567891011121314const map0 = new Map() .set(1, 'a') .set(2, 'b') .set(3, 'c');const map1 = new Map( [...map0].filter(([k, v]) =&gt; k &lt; 3));// 产生 Map 结构 &#123;1 =&gt; 'a', 2 =&gt; 'b'&#125;const map2 = new Map( [...map0].map(([k, v]) =&gt; [k * 2, '_' + v]) );// 产生 Map 结构 &#123;2 =&gt; '_a', 4 =&gt; '_b', 6 =&gt; '_c'&#125; 与其他数据结构的互相转换 Map 转为数组 12345const myMap = new Map() .set(true, 7) .set(&#123;foo: 3&#125;, ['abc']);[...myMap]// [ [ true, 7 ], [ &#123; foo: 3 &#125;, [ 'abc' ] ] ] 数组 转为 Map 12345678new Map([ [true, 7], [&#123;foo: 3&#125;, ['abc']]])// Map &#123;// true =&gt; 7,// Object &#123;foo: 3&#125; =&gt; ['abc']// &#125; Map 转为对象 12345678910111213function strMapToObj(strMap) &#123; let obj = Object.create(null); for (let [k,v] of strMap) &#123; obj[k] = v; &#125; return obj;&#125;const myMap = new Map() .set('yes', true) .set('no', false);strMapToObj(myMap)// &#123; yes: true, no: false &#125; 对象转为 Map 12345678910function objToStrMap(obj) &#123; let strMap = new Map(); for (let k of Object.keys(obj)) &#123; strMap.set(k, obj[k]); &#125; return strMap;&#125;objToStrMap(&#123;yes: true, no: false&#125;)// Map &#123;\"yes\" =&gt; true, \"no\" =&gt; false&#125; Map 转为 JSON 12345678910111213141516// Map 的键名都是字符串，这时可以选择转为对象 JSON。function strMapToJson(strMap) &#123; return JSON.stringify(strMapToObj(strMap));&#125;let myMap = new Map().set('yes', true).set('no', false);strMapToJson(myMap)// '&#123;\"yes\":true,\"no\":false&#125;'// Map 的键名有非字符串，这时可以选择转为数组 JSONfunction mapToArrayJson(map) &#123; return JSON.stringify([...map]);&#125;let myMap = new Map().set(true, 7).set(&#123;foo: 3&#125;, ['abc']);mapToArrayJson(myMap)// '[[true,7],[&#123;\"foo\":3&#125;,[\"abc\"]]]' JSON 转为 Map 123456function jsonToStrMap(jsonStr) &#123; return objToStrMap(JSON.parse(jsonStr));&#125;jsonToStrMap('&#123;\"yes\": true, \"no\": false&#125;')// Map &#123;'yes' =&gt; true, 'no' =&gt; false&#125; WeakMap 类似WeakSet 123456789101112// WeakMap 可以使用 set 方法添加成员const wm1 = new WeakMap();const key = &#123;foo: 1&#125;;wm1.set(key, 2);wm1.get(key) // 2// WeakMap 也可以接受一个数组，// 作为构造函数的参数const k1 = [1, 2, 3];const k2 = [4, 5, 6];const wm2 = new WeakMap([[k1, 'foo'], [k2, 'bar']]);wm2.get(k2) // \"bar\" WeakMap与Map的区别有两点。 WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名 WeakMap的键名所指向的对象，不计入垃圾回收机制1234567const map = new WeakMap();map.set(1, 2)// TypeError: 1 is not an object!map.set(Symbol(), 2)// TypeError: Invalid value used as weak map keymap.set(null, 2)// TypeError: Invalid value used as weak map key WeakMap的专用场合就是，它的键所对应的对象，可能会在将来消失。WeakMap结构有助于防止内存泄漏 WeakMap 应用的典型场合就是 DOM 节点作为键名 1234567891011let myElement = document.getElementById('logo');let myWeakmap = new WeakMap();myWeakmap.set(myElement, &#123;timesClicked: 0&#125;);myElement.addEventListener('click', function() &#123; let logoData = myWeakmap.get(myElement); logoData.timesClicked++;&#125;, false);// 上面代码中，myElement是一个 DOM 节点，每当发生click事件，就更新一下状态。我们将这个状态作为键值放在 WeakMap 里，对应的键名就是myElement。一旦这个 DOM 节点删除，该状态就会自动消失，不存在内存泄漏风险。 部署私有属性 123456789101112131415161718192021222324const _counter = new WeakMap();const _action = new WeakMap();class Countdown &#123; constructor(counter, action) &#123; _counter.set(this, counter); _action.set(this, action); &#125; dec() &#123; let counter = _counter.get(this); if (counter &lt; 1) return; counter--; _counter.set(this, counter); if (counter === 0) &#123; _action.get(this)(); &#125; &#125;&#125;const c = new Countdown(2, () =&gt; console.log('DONE'));c.dec()c.dec()// DONE Proxy Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器” Proxy相当于在目标对象上添加了一层拦截器，在某些操作生效之前，可以在拦截器中做一些操作，例如在设置某个值前，检查值是否符合要求123456789101112131415161718192021222324252627282930313233343536var proxy = new Proxy(&#123;&#125;, &#123;// 代理了&#123;&#125;对象的所有get操作，在实际操作生效前，拦截了并返回新值 get: function(target, property) &#123; return 35; &#125;&#125;);proxy.time // 35proxy.name // 35proxy.title // 35// 拦截器可以代理很多类型的操作，在这些操作真正生效前，进行拦截var handler = &#123; get: function(target, name) &#123; if (name === 'prototype') &#123; return Object.prototype; &#125; return 'Hello, ' + name; &#125;, apply: function(target, thisBinding, args) &#123; return args[0]; &#125;, construct: function(target, args) &#123; return &#123;value: args[1]&#125;; &#125;&#125;;var fproxy = new Proxy(function(x, y) &#123; return x + y;&#125;, handler);fproxy(1, 2) // 1new fproxy(1,2) // &#123;value: 2&#125;fproxy.prototype === Object.prototype // truefproxy.foo // \"Hello, foo\" Proxy中的this问题 在 Proxy 代理的情况下，目标对象内部的this关键字会指向 Proxy 代理。1234567891011const target = &#123; m: function () &#123; console.log(this === proxy); &#125;&#125;;const handler = &#123;&#125;;const proxy = new Proxy(target, handler);target.m() // falseproxy.m() // true，代理后，this指向了proxy而不是原先的target Reflect 应该是js在设计之初有些不合理的地方，例如将一些明显是语言内部的方法放到了Object上，现在要改正，需要一个容器来装载这些方法，所以将这些改良方法都放在了Reflect对象上 特点 现阶段，某些方法同时在Object和Reflect对象上部署，未来的新方法将只部署在Reflect对象上。也就是说，从Reflect对象上可以拿到语言内部的方法。 修改某些Object方法的返回结果，让其变得更合理。 让Object操作都变成函数行为。 Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。 Promise对象 可以和jQuery中的延迟对象以及promise对比理解 基本用法 123456789101112131415var promise = new Promise(function(resolve, reject) &#123; // ... some code if (/* 异步操作成功 */)&#123; return resolve(value); &#125; else &#123; return reject(error); &#125;&#125;);promise.then(function(value) &#123; // success&#125;, function(error) &#123; // failure&#125;); Promise新建后就会立即执行 1234567891011121314let promise = new Promise(function(resolve, reject) &#123; console.log('Promise'); return resolve();&#125;);promise.then(function() &#123; console.log('resolved.');&#125;);console.log('Hi!');// Promise// Hi!// resolved 返回另一个异步操作 12345678var p1 = new Promise(function (resolve, reject) &#123; // ...&#125;);var p2 = new Promise(function (resolve, reject) &#123; // ... return resolve(p1);// p1和p2都是 Promise 的实例，但是p2的resolve方法将p1作为参数，即一个异步操作的结果是返回另一个异步操作，这时p1的状态就会传递给p2，也就是说，p1的状态决定了p2的状态。如果p1的状态是pending，那么p2的回调函数就会等待p1的状态改变；如果p1的状态已经是resolved或者rejected，那么p2的回调函数将会立刻执行&#125;); p.then promise.then(resolvedFn,rejectFn); 基于前一个promise的状态分别调用不同的回调函数1234567getJSON(\"/post/1.json\").then(function(post) &#123; return getJSON(post.commentURL);&#125;).then(function funcA(comments) &#123; console.log(\"resolved: \", comments);&#125;, function funcB(err)&#123; console.log(\"rejected: \", err);&#125;); p.catch Promise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。123456p.then((val) =&gt; console.log('fulfilled:', val)) .catch((err) =&gt; console.log('rejected', err));// 等同于p.then((val) =&gt; console.log('fulfilled:', val)) .then(null, (err) =&gt; console.log(\"rejected:\", err)); p.all Promise.all方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。 当多个promise都resolve了，则调用then的resolvFn，否则都调用rejectFn1234567891011// promises是包含6个 Promise 实例的数组，只有这6个实例的状态都变成fulfilled，或者其中有一个变为rejected，才会调用Promise.all方法后面的回调函数。// 生成一个Promise对象的数组var promises = [2, 3, 5, 7, 11, 13].map(function (id) &#123; return getJSON('/post/' + id + \".json\");&#125;);Promise.all(promises).then(function (posts) &#123; // ...&#125;).catch(function(reason)&#123; // ...&#125;); p.race Promise.race方法同样是将多个Promise实例，包装成一个新的Promise实例，哪个promise状态先改变，则后面的回调将根据其状态做不同的调用123456789101112var p = Promise.race([p1, p2, p3]);// 只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。const p = Promise.race([ fetch('/resource-that-may-take-a-while'), new Promise(function (resolve, reject) &#123; setTimeout(() =&gt; reject(new Error('request timeout')), 5000) &#125;)]);p.then(response =&gt; console.log(response));p.catch(error =&gt; console.log(error));// 如果5秒之内fetch方法无法返回结果，变量p的状态就会变为rejected，从而触发catch方法指定的回调函数 Promise.resolve 用来将一个对象转换成ES6的Promise对象 参数是一个Promise实例，则直接返回这个Promise实例 参数是一个thenable对象，Promise.resolve方法会将这个对象转为Promise对象，然后就立即执行thenable对象的then方法 12345678910let thenable = &#123; then: function(resolve, reject) &#123; resolve(42); &#125;&#125;;let p1 = Promise.resolve(thenable);p1.then(function(value) &#123; console.log(value); // 42&#125;); 参数不是具有then方法的对象，或根本就不是对象，则Promise.resolve方法返回一个新的Promise对象，状态为resolved 123456var p = Promise.resolve('Hello');p.then(function (s)&#123; console.log(s)&#125;);// Hello 不带有任何参数，直接返回一个resolved状态的Promise对象。 12345var p = Promise.resolve();p.then(function () &#123; // ...&#125;); Promise.reject() Promise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为rejected。12345678var p = Promise.reject('出错了');// 等同于var p = new Promise((resolve, reject) =&gt; reject('出错了'))p.then(null, function (s) &#123; console.log(s)&#125;);// 出错了 Iterator 和 for…of 循环Iterator 遍历器（Iterator）它是一种接口，为各种不同的数据结构提供统一的访问机制； 默认的 Iterator 接口部署在数据结构的Symbol.iterator属性，或者说，一个数据结构只要具有Symbol.iterator属性，就可以认为是“可遍历的”（iterable） 123456let arr = ['a', 'b', 'c'];let iter = arr[Symbol.iterator]();iter.next() // &#123; value: 'a', done: false &#125;iter.next() // &#123; value: 'b', done: false &#125;iter.next() // &#123; value: 'c', done: false &#125;iter.next() // &#123; value: undefined, done: true &#125;// done表示本次遍历结束 原生具备 Iterator 接口的数据结构如下，对于原生部署 Iterator 接口的数据结构，不用自己写遍历器生成函数，原生的Obj不具备遍历器接口 Array Map Set String TypedArray 函数的 arguments 对象 NodeList 对象 某些情况下，会默认调用Iterator 接口 解构赋值 扩展运算符 yield* 任何接受数组作为参数的场合，其实都调用了遍历器接口 for…of 所有部署了Iterator接口的数据结构，都可以使用for…of来进行遍历 所有原生具备Iterator接口的都可以直接使用for…of遍历 123456789101112131415161718192021222324252627282930313233// 数组const arr = ['red', 'green', 'blue'];for(let v of arr) &#123; console.log(v); // red green blue&#125;const obj = &#123;&#125;;obj[Symbol.iterator] = arr[Symbol.iterator].bind(arr);for(let v of obj) &#123; console.log(v); // red green blue&#125;// Set、Mapvar engines = new Set([\"Gecko\", \"Trident\", \"Webkit\", \"Webkit\"]);for (var e of engines) &#123; console.log(e);&#125;// Gecko// Trident// Webkitvar es6 = new Map();es6.set(\"edition\", 6);es6.set(\"committee\", \"TC39\");es6.set(\"standard\", \"ECMA-262\");for (var [name, value] of es6) &#123; console.log(name + \": \" + value);&#125;// edition: 6// committee: TC39// standard: ECMA-262 有些数据结构是在现有数据结构的基础上，计算生成的。比如，ES6的数组、Set、Map 都部署了keys()、values()、entries方法，调用后都返回遍历器对象 1234567let arr = ['a', 'b', 'c'];for (let pair of arr.entries()) &#123; console.log(pair);&#125;// [0, 'a']// [1, 'b']// [2, 'c'] 类似数组的对象 1234567891011121314151617181920212223// 字符串let str = \"hello\";for (let s of str) &#123; console.log(s); // h e l l o&#125;// DOM NodeList对象let paras = document.querySelectorAll(\"p\");for (let p of paras) &#123; p.classList.add(\"test\");&#125;// arguments对象function printArgs() &#123; for (let x of arguments) &#123; console.log(x); &#125;&#125;printArgs('a', 'b');// 'a'// 'b' 对象不可直接使用for…of遍历 1234567891011121314151617let es6 = &#123; edition: 6, committee: \"TC39\", standard: \"ECMA-262\"&#125;;for (let e in es6) &#123; console.log(e);&#125;// edition// committee// standardfor (let e of es6) &#123; console.log(e);&#125;// TypeError: es6[Symbol.iterator] is not a function 使用Object.keys方法将对象的键名生成一个数组，然后遍历这个数组。123for (var key of Object.keys(someObject)) &#123; console.log(key + ': ' + someObject[key]);&#125; 遍历语法的对比 for 繁琐123for (var index = 0; index &lt; myArray.length; index++) &#123; console.log(myArray[index]);&#125; forEach方法 无法中途跳出forEach循环，break命令或return命令都不能奏效。123myArray.forEach(function (value) &#123; console.log(value);&#125;); for…in for…in循环不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键 遍历顺序在某些情况下还不固定 主要是为对象部署的 for…of 只要部署了遍历接口的数据结构都可使用 不同于forEach方法，它可以与break、continue和return配合使用。12345for (var n of fibonacci) &#123; if (n &gt; 1000) break; console.log(n);&#125; Generator 函数的语法基本概念 Generator函数总是返回一个遍历器对象，通过调用遍历器对象的next()方法，让函数一步一步的执行 语法形式 123456789101112131415161718function* helloWorldGenerator() &#123;// function后跟一个* yield 'hello'; yield 'world'; return 'ending';&#125;var hw = helloWorldGenerator();// 被调用时，返回一个遍历器对象，可在遍历器对象上调用next()方法hw.next() // 每次调用next()返回的对象的value值都是yield后表达式对应的值// &#123; value: 'hello', done: false &#125;hw.next() // 每次调用next()时，会寻找下一个yield表达式// &#123; value: 'world', done: false &#125;hw.next()// &#123; value: 'ending', done: true &#125;hw.next()// &#123; value: undefined, done: true &#125; yield 表达式 yield是暂停标志，调用next()时，遇到yield会暂停，并将后面表达式的值返回，下次调用next()时会按顺序寻找下一个yield；如果是最后一个yield，则继续执行，直到遇到return，将return后面的值做为返回的对象的value值，如果没有return，则返回对象的value值为undefined yield后面的表达式是惰性求值 123function* gen() &#123; yield 123 + 456; // yield后面的表达式123 + 456，不会立即求值，只会在next方法将指针移到这一句时，才会求值&#125; yield表达式只能用在 Generator 函数里面，用在其他地方都会报错。 1234(function ()&#123; yield 1;&#125;)()// SyntaxError: Unexpected number 与 Iterator 接口的关系 由于Generator 函数返回的是一个遍历器对象，所以可以把 Generator 赋值给对象的Symbol.iterator属性，从而使得该对象具有 Iterator 接口12345678var myIterable = &#123;&#125;;myIterable[Symbol.iterator] = function* () &#123; yield 1; yield 2; yield 3;&#125;;[...myIterable] // [1, 2, 3] next方法的参数 yield表达式本身没有返回值，或者说总是返回undefined next方法的参数代表上一个yield表达式返回的值123456789101112function* f() &#123; for(var i = 0; true; i++) &#123; var reset = yield i; if(reset) &#123; i = -1; &#125; &#125;&#125;var g = f();g.next() // &#123; value: 0, done: false &#125;，第一次调用next，找到yield，此时i为0，暂停后面的执行并返回0做为返回对象的value值g.next() // &#123; value: 1, done: false &#125;，在上一次yield后继续执行寻找下一个yield，由于第一次yield默认返回undefined，所以rest为undefined,所以i=-1并未执行，进入第二轮循环，找到yield，此时i为1，暂停后面的执行并返回1做为返回对象的value值g.next(true) // &#123; value: 0, done: false &#125;，传入参数true，true被当成上一个yield表达式的返回值，所以rest为true，进而i=-1被执行，进入第三次循环(此时i已经加1了为0)，找到yield，此时i为0，暂停后面的执行并返回0做为返回对象的value值 for…of for…of循环可以自动遍历 Generator 函数时生成的Iterator对象，且此时不再需要调用next方法12345678910111213function *foo() &#123; yield 1; yield 2; yield 3; yield 4; yield 5; return 6;&#125;for (let v of foo()) &#123; console.log(v);&#125;// 1 2 3 4 5，不会返回return后的值，所以for...of只会按顺序返回yield后的值 Generator.prototype.throw()、Generator.prototype.return() throw用来抛出错误 return可以返回给定的值，并且终结遍历 Generator 函数 在Generator函数内调用另外一个Generator函数 使用yield*表达式12345678910111213141516171819202122232425function* inner() &#123; yield 'hello!';&#125;function* outer1() &#123; yield 'open'; yield inner(); yield 'close';&#125;var gen = outer1()gen.next().value // \"open\"gen.next().value // 返回一个遍历器对象gen.next().value // \"close\"function* outer2() &#123; yield 'open' yield* inner() yield 'close'&#125;var gen = outer2()gen.next().value // \"open\"gen.next().value // \"hello!\"gen.next().value // \"close\" 作为对象属性的Generator函数可以采用简写形式 123456789101112let obj = &#123; myGeneratorMethod: function* () &#123; // ··· &#125;&#125;;// 简写形式let obj = &#123; * myGeneratorMethod() &#123; ··· &#125;&#125;; 应用 异步操作的同步化表达 1234567891011121314function* main() &#123; var result = yield request(\"http://some.url\");// 1.此处被暂停，进行request异步请求 var resp = JSON.parse(result);// 对2处异步请求的返回值做相应处理 console.log(resp.value);&#125;function request(url) &#123; makeAjaxCall(url, function(response)&#123;// 异步请求成功 it.next(response);// 2.手动调用next，并将异步请求的返回值做为上一次yield表达式的值 &#125;);&#125;var it = main();// 返回遍历器对象it.next();// 执行next，寻找第一个yield 控制流管理 123456789101112131415161718192021222324252627282930313233343536373839404142434445step1(function (value1) &#123; step2(value1, function(value2) &#123; step3(value2, function(value3) &#123; step4(value3, function(value4) &#123; // Do something with value4 &#125;); &#125;); &#125;);&#125;);// promise改写Promise.resolve(step1) .then(step2) .then(step3) .then(step4) .then(function (value4) &#123; // Do something with value4 &#125;, function (error) &#123; // Handle any error from step1 through step4 &#125;) .done();// generator改写function* longRunningTask(value1) &#123; try &#123; var value2 = yield step1(value1); var value3 = yield step2(value2); var value4 = yield step3(value3); var value5 = yield step4(value4); // Do something with value4 &#125; catch (e) &#123; // Handle any error from step1 through step4 &#125;&#125;scheduler(longRunningTask(initialValue));function scheduler(task) &#123; var taskObj = task.next(task.value); // 如果Generator函数未结束，就继续调用 if (!taskObj.done) &#123; task.value = taskObj.value scheduler(task); &#125;&#125; 部署 Iterator 接口 原生obj上因为没有Iterator 接口无法使用for…of，可以利用Generator 函数，可以在任意对象上部署 Iterator 接口。12345678910111213141516function* iterEntries(obj) &#123; let keys = Object.keys(obj); for (let i=0; i &lt; keys.length; i++) &#123; let key = keys[i]; yield [key, obj[key]]; &#125;&#125;let myObj = &#123; foo: 3, bar: 7 &#125;;for (let [key, value] of iterEntries(myObj)) &#123; console.log(key, value);&#125;// foo 3// bar 7 作为数据结构 Generator 可以看作是数据结构，更确切地说，可以看作是一个数组结构，因为 Generator 函数可以返回一系列的值，这意味着它可以对任意表达式，提供类似数组的接口。123456789function *doStuff() &#123; yield fs.readFile.bind(null, 'hello.txt'); yield fs.readFile.bind(null, 'world.txt'); yield fs.readFile.bind(null, 'and-such.txt');&#125;for (task of doStuff()) &#123; // task是一个函数，可以像回调函数那样使用它&#125; Generator 函数的异步应用传统方法完成异步 回调 容易出现callback hell12345fs.readFile(fileA, 'utf-8', function (err, data) &#123; fs.readFile(fileB, 'utf-8', function (err, data) &#123; // ... &#125;);&#125;); Promise 允许将回调函数的嵌套，改成链式调用 123456789101112131415var readFile = require('fs-readfile-promise');readFile(fileA).then(function (data) &#123; console.log(data.toString());&#125;).then(function () &#123; return readFile(fileB);&#125;).then(function (data) &#123; console.log(data.toString());&#125;).catch(function (err) &#123; console.log(err);&#125;); Promise 的最大问题是代码冗余，原来的任务被 Promise 包装了一下，不管什么操作，一眼看去都是一堆then，原来的语义变得很不清楚 Generator 函数完成异步任务 利用Generator中的yield暂停函数的执行，等到恢复后，继续从此处执行； 遇到yield命令就暂停，等到执行权返回，再从暂停的地方继续往后执行。它的最大优点，就是代码的写法非常像同步操作，如果去除yield命令，简直一模一样 整个 Generator 函数就是一个封装的异步任务，或者说是异步任务的容器。异步操作需要暂停的地方，都用yield语句注明。 通过next方法接收参数，向Generator函数体内输入数据。12345678910111213141516var fetch = require('node-fetch');function* gen()&#123; var url = 'https://api.github.com/users/github'; var result = yield fetch(url);// 返回的结果保存在result中 console.log(result.bio);&#125;var g = gen();var result = g.next();// 得到异步读取的结果result.value.then(function(data)&#123;// Fetch模块返回的是一个Promise对象，因此要用then方法调用下一个next方法。 return data.json();// 转换为json&#125;).then(function(data)&#123; g.next(data);// 传入Generator函数&#125;); async 函数async函数是Generator函数的语法糖12345678910111213141516171819202122232425const fs = require('fs');const readFile = function (fileName) &#123; return new Promise(function (resolve, reject) &#123; fs.readFile(fileName, function(error, data) &#123; if (error) return reject(error); resolve(data); &#125;); &#125;);&#125;;const gen = function* () &#123; const f1 = yield readFile('/etc/fstab'); const f2 = yield readFile('/etc/shells'); console.log(f1.toString()); console.log(f2.toString());&#125;;// 使用async改写const asyncReadFile = async function () &#123; const f1 = await readFile('/etc/fstab'); const f2 = await readFile('/etc/shells'); console.log(f1.toString()); console.log(f2.toString());&#125;; 改进 内置执行器 Generator必须手动一步一步的调用next()方法或者是用第三方的执行器自动执行，而async函数内部了执行器，能自动执行 更好的语义 更广的适用性 如果使用第三放的执行器，例如co则yield后只能是Thunk 函数或 Promise 对象，而async函数内的await命令后面，可以是Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作） async返回值是Promise，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用then方法指定下一步的操作 async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖 基本用法 async函数返回一个 Promise 对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句 123456789async function getStockPriceByName(name) &#123; const symbol = await getStockSymbol(name);// 等待getStockSymbol异步完成，再执行下面的 const stockPrice = await getStockPrice(symbol); return stockPrice;&#125;getStockPriceByName('goog').then(function (result) &#123;// getStockPriceByName是一个async函数，所以返回的是Promise，可以使用then console.log(result);&#125;); async 函数有多种使用形式 123456789101112131415161718192021222324252627// 函数声明async function foo() &#123;&#125;// 函数表达式const foo = async function () &#123;&#125;;// 对象的方法let obj = &#123; async foo() &#123;&#125; &#125;;obj.foo().then(...)// Class 的方法class Storage &#123; constructor() &#123; this.cachePromise = caches.open('avatars'); &#125; async getAvatar(name) &#123; const cache = await this.cachePromise; return cache.match(`/avatars/$&#123;name&#125;.jpg`); &#125;&#125;const storage = new Storage();storage.getAvatar('jake').then(…);// 箭头函数const foo = async () =&gt; &#123;&#125;; 语法 async函数返回一个 Promise 对象。async函数内部return语句返回的值，会成为then方法回调函数的参数。 123456async function f() &#123;// 整体返回一个Promise对象 return 'hello world';// 内部的return返回的值将当做then方法回调的参数&#125;f().then(v =&gt; console.log(v))// 'heollo world'传递给了v// \"hello world\" 正常情况下，await命令后面是一个 Promise 对象。如果不是，会被转成一个立即resolve的 Promise 对象 123456async function f() &#123; return await 123;// 123会被转换成Promise对象，并立即resolved&#125;f().then(v =&gt; console.log(v))// 123 async函数返回的 Promise 对象，必须等到内部所有await命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到return语句或者抛出错误。也就是说，只有async函数内部的异步操作执行完，才会执行then方法指定的回调函数 1234567async function getTitle(url) &#123;// 所有await命令都执行完成，才会执行then的回调 let response = await fetch(url); let html = await response.text(); return html.match(/&lt;title&gt;([\\s\\S]+)&lt;\\/title&gt;/i)[1];&#125;getTitle('https://tc39.github.io/ecma262/').then(console.log)// \"ECMAScript 2017 Language Specification\" 注意点 async函数内部抛出错误，会导致返回的 Promise 对象变为reject状态。抛出的错误对象会被catch方法回调函数接收到 123456789async function f() &#123; throw new Error('出错了');&#125;f().then( v =&gt; console.log(v), e =&gt; console.log(e))// Error: 出错了 await命令后面的 Promise 对象如果变为reject状态，则reject的参数会被catch方法的回调函数接收到。 12345678async function f() &#123; await Promise.reject('出错了');&#125;f().then(v =&gt; console.log(v)).catch(e =&gt; console.log(e))// 出错了 只要一个await语句后面的 Promise 变为reject，那么整个async函数都会中断执行 1234async function f() &#123; await Promise.reject('出错了'); await Promise.resolve('hello world'); // 不会执行&#125; 前一个异步操作失败，也不要中断后面的异步操作，可以将第一个await放在try…catch结构里面，这样不管这个异步操作是否成功，第二个await都会执行。或者await后面的 Promise 对象再跟一个catch方法，处理前面可能出现的错误。 123456789101112131415161718192021async function f() &#123; try &#123; await Promise.reject('出错了'); &#125; catch(e) &#123; &#125; return await Promise.resolve('hello world');&#125;f().then(v =&gt; console.log(v))// hello world// await后面的 Promise 对象再跟一个catch方法，处理前面可能出现的错误async function f() &#123; await Promise.reject('出错了') .catch(e =&gt; console.log(e)); return await Promise.resolve('hello world');&#125;f().then(v =&gt; console.log(v))// 出错了// hello world 多个await命令后面的异步操作，如果不存在继发关(依赖)系，最好让它们同时触发。 123456// getBar、getFoo这两个异步请求并无依赖关系，但这种写法getBar必须在getFoo完成后再请求let foo = await getFoo();let bar = await getBar();// 使用Promise.alllet [foo, bar] = await Promise.all([getFoo(), getBar()]);// 二者可以同时请求 await命令只能用在async函数之中，如果用在普通函数，就会报错 12345678async function dbFuc(db) &#123; let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;]; // 报错 docs.forEach(function (doc) &#123;// forEach参数为普通函数，所以无法使用await await db.post(doc); &#125;);&#125; 实例:按顺序完成异步操作 Promise 的写法如下 12345678910111213// 使用fetch方法，同时远程读取一组 URL。每个fetch操作都返回一个 Promise 对象，放入textPromises数组。然后，reduce方法依次处理每个 Promise 对象，然后使用then，将所有 Promise 对象连起来，因此就可以依次输出结果function logInOrder(urls) &#123; // 远程读取所有URL const textPromises = urls.map(url =&gt; &#123; return fetch(url).then(response =&gt; response.text()); &#125;); // 按次序输出 textPromises.reduce((chain, textPromise) =&gt; &#123; return chain.then(() =&gt; textPromise) .then(text =&gt; console.log(text)); &#125;, Promise.resolve());&#125; async写法 1234567891011121314151617181920async function logInOrder(urls) &#123; for (const url of urls) &#123; const response = await fetch(url); console.log(await response.text()); &#125;&#125;// 上面的代码，下一个请求必须在上一个请求完成后再请求，而请求之间无依赖关系，所以可以同时请求，优化如下async function logInOrder(urls) &#123; // 并发读取远程URL const textPromises = urls.map(async url =&gt; &#123; const response = await fetch(url); return response.text(); &#125;); // 按次序输出 for (const textPromise of textPromises) &#123; console.log(await textPromise); &#125;&#125;// 上面代码中，虽然map方法的参数是async函数，但它是并发执行的，因为只有async函数内部是继发执行，外部不受影响。后面的for..of循环内部使用了await，因此实现了按顺序输出。 异步遍历器 类似同步遍历器，不过它调用next()方法后返回的是一个Promise对象，可以使用then方法 12345asyncIterator .next() .then( (&#123; value, done &#125;) =&gt; /* ... */ ); 异步遍历器接口返回的是一个异步遍历器，可以使用for await...of来遍历 1234567async function f() &#123; for await (const x of createAsyncIterable(['a', 'b'])) &#123; console.log(x); &#125;&#125;// a// b 异步 Generator 函数 Generator 函数返回一个同步遍历器对象一样，异步 Generator 函数的作用，是返回一个异步遍历器对象。 语法上，异步 Generator 函数就是async函数与 Generator 函数的结合 123456789101112131415161718192021222324252627// gen是一个异步 Generator 函数，执行后返回一个异步 Iterator 对象。对该对象调用next方法，返回一个 Promise 对象async function* gen() &#123; yield 'hello';&#125;const genObj = gen();genObj.next().then(x =&gt; console.log(x));// &#123; value: 'hello', done: false &#125;// 同步 Generator 函数function* map(iterable, func) &#123; const iter = iterable[Symbol.iterator](); while (true) &#123; const &#123;value, done&#125; = iter.next(); if (done) break; yield func(value); &#125;&#125;// 异步 Generator 函数async function* map(iterable, func) &#123; const iter = iterable[Symbol.asyncIterator](); while (true) &#123; const &#123;value, done&#125; = await iter.next(); if (done) break; yield func(value); &#125;&#125; 异步 Generator 函数出现以后，JavaScript 就有了四种函数形式：普通函数、async 函数、Generator 函数和异步 Generator 函数。请注意区分每种函数的不同之处。基本上，如果是一系列按照顺序执行的异步操作（比如读取文件，然后写入新内容，再存入硬盘）存在明显的先后顺序才能得到正确结果时，可以使用 async 函数；如果是一系列产生相同数据结构的异步操作（比如一行一行读取文件），可以使用异步 Generator 函数 Class的基本语法Class ES6的class(类)可以看做是ES5中类写法的一个语法糖 12345678910111213141516171819202122232425//ES5function Point(x, y) &#123; this.x = x; this.y = y;&#125;Point.prototype.toString = function () &#123; return '(' + this.x + ', ' + this.y + ')';&#125;;var p = new Point(1, 2);//ES6class Point &#123; constructor(x, y) &#123;// 使用new时，会自动调用这个方法 this.x = x; this.y = y; &#125; toString() &#123;// toString实际是定义在原型对象上的，所以所有实例对象都可以使用此方法 return '(' + this.x + ', ' + this.y + ')'; &#125;&#125;var p=new Point(1,2); 类的所有方法都定义在类的prototype属性上面，所以所有实例对象都可以使用此方法 123456789101112131415161718192021class Point &#123; constructor() &#123; // ... &#125; toString() &#123; // ... &#125; toValue() &#123; // ... &#125;&#125;// 等同于Point.prototype = &#123; constructor() &#123;&#125;, toString() &#123;&#125;, toValue() &#123;&#125;,&#125;; 类的内部所有定义的方法，都是不可枚举的（non-enumerable） 1234567891011121314151617181920212223242526272829// ES6class Point &#123; constructor(x, y) &#123; // ... &#125; toString() &#123; // ... &#125;&#125;Object.keys(Point.prototype)// []Object.getOwnPropertyNames(Point.prototype)// [\"constructor\",\"toString\"]//ES5写法中，方法是可枚举的var Point = function (x, y) &#123; // ...&#125;;Point.prototype.toString = function() &#123; // ...&#125;;Object.keys(Point.prototype)// [\"toString\"]Object.getOwnPropertyNames(Point.prototype)// [\"constructor\",\"toString\"] 类内，默认采用严格模式 与函数一样，类也可以使用表达式的形式定义。123456789101112const MyClass = class Me &#123; getClassName() &#123; return Me.name; &#125;&#125;;let inst = new MyClass();inst.getClassName() // MeMe.name // ReferenceError: Me is not defined// 如果类的内部没用到的话，可以省略Me，也就是可以写成下面的形式const MyClass = class &#123; /* ... */ &#125;; constructor方法 类中的constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法；一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加；constructor方法默认返回的实例对象 12345678// 没有显示添加constructor方法，会默认添加class Point &#123;&#125;// 等同于class Point &#123; constructor() &#123;&#125;&#125; 类必须使用new调用，否则会出错 12class B&#123;&#125;B();// error 不存在变量提升 类不存在变量提升（hoist），这一点与 ES5 完全不同。12new Foo(); // ReferenceErrorclass Foo &#123;&#125; 私有属性、方法 ES6暂不提供私有属性、方法，不过可以模拟123456789101112131415161718192021// 私有方法class Widget &#123; foo (baz) &#123; bar.call(this, baz); &#125; // ...&#125;function bar(baz) &#123; return this.snaf = baz;&#125;// 私有属性，新提案使用#标识class Point &#123; #x; constructor(x = 0) &#123; #x = +x; // 写成 this.#x 亦可 &#125;&#125; this 类的方法内部如果含有this，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错123456789101112131415161718192021222324252627282930313233class Logger &#123; printName(name = 'there') &#123; this.print(`Hello $&#123;name&#125;`); &#125; print(text) &#123; console.log(text); &#125;&#125;const logger = new Logger();const &#123; printName &#125; = logger;// 将logger的printName方法单独提取出来printName(); // TypeError: Cannot read property 'print' of undefined，因为此时this已经不指向logger实例了，所以找不到print方法，解决方法如下// 直接绑定thisclass Logger &#123; constructor() &#123; this.printName = this.printName.bind(this); &#125; // ...&#125;// 使用箭头函数class Logger &#123; constructor() &#123; this.printName = (name = 'there') =&gt; &#123; this.print(`Hello $&#123;name&#125;`); &#125;; &#125; // ...&#125; Class 的取值函数（getter）和存值函数（setter） 存值函数和取值函数是设置在属性的 Descriptor 对象上的1234567891011121314151617181920class CustomHTMLElement &#123; constructor(element) &#123; this.element = element; &#125; get html() &#123; return this.element.innerHTML; &#125; set html(value) &#123; this.element.innerHTML = value; &#125;&#125;var descriptor = Object.getOwnPropertyDescriptor( CustomHTMLElement.prototype, \"html\");\"get\" in descriptor // true\"set\" in descriptor // true Class 的 Generator 方法 如果某个方法之前加上星号（*），就表示该方法是一个 Generator 函数12345678910111213141516class Foo &#123; constructor(...args) &#123; this.args = args; &#125; * [Symbol.iterator]() &#123;// 返回一个同步遍历器对象，可以使用for...of遍历 for (let arg of this.args) &#123; yield arg; &#125; &#125;&#125;for (let x of new Foo('hello', 'world')) &#123; console.log(x);&#125;// hello// world 类的静态方法 如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。 1234567891011class Foo &#123; static classMethod() &#123; return 'hello'; &#125;&#125;Foo.classMethod() // 'hello'var foo = new Foo();foo.classMethod()// TypeError: foo.classMethod is not a function，无法在实例上调用 静态方法包含this关键字，这个this指的是类，而不是实例 12345678910111213class Foo &#123; static bar () &#123; this.baz(); &#125; static baz () &#123; console.log('hello'); &#125; baz () &#123; console.log('world'); &#125;&#125;Foo.bar() // hello 父类的静态方法，可以被子类继承 12345678910class Foo &#123; static classMethod() &#123; return 'hello'; &#125;&#125;class Bar extends Foo &#123;&#125;Bar.classMethod() // 'hello' 类的静态属性 静态属性指的是 Class 本身的属性，即Class.propName，而不是定义在实例对象（this）上的属性。 1234567891011121314151617// 暂时只能用下面这种写法class Foo &#123;&#125;Foo.prop = 1;Foo.prop // 1// 以下两种写法都无效class Foo &#123; // 写法一 prop: 2 // 写法二 static prop: 2&#125;Foo.prop // undefined 新提案对实例属性和静态属性都规定了新的写法 1234567891011121314151617// 类的实例属性可以用等式，写入类的定义之中。以前，我们定义实例属性，只能写在类的constructor方法里面。class MyClass &#123; myProp = 42; constructor() &#123; console.log(this.myProp); // 42 &#125;&#125;// 类的静态属性，类的静态属性只要在上面的实例属性写法前面，加上static关键字就可以了。class MyClass &#123; static myStaticProp = 42; constructor() &#123; console.log(MyClass.myStaticProp); // 42 &#125;&#125; new.target属性 一般用在构造函数之中，返回new命令调用的那个构造函数。如果构造函数不是通过new命令调用的，new.target会返回undefined，因此这个属性可以用来确定构造函数是怎么调用的。 12345678910111213141516171819function Person(name) &#123; if (new.target !== undefined) &#123; this.name = name; &#125; else &#123; throw new Error('必须使用new生成实例'); &#125;&#125;// 另一种写法function Person(name) &#123; if (new.target === Person) &#123; this.name = name; &#125; else &#123; throw new Error('必须使用 new 生成实例'); &#125;&#125;var person = new Person('张三'); // 正确var notAPerson = Person.call(person, '张三'); // 构造函数不是通过new调用的，报错 用在ES6中的class时，new.target返回的是new后跟着的类名(其实本质一样) 123456789class Rectangle &#123; constructor(length, width) &#123; console.log(new.target === Rectangle); this.length = length; this.width = width; &#125;&#125;var obj = new Rectangle(3, 4); // 输出 true 子类继承父类时，new.target会返回子类，而不是父类。 1234567891011121314class Rectangle &#123; constructor(length, width) &#123; console.log(new.target === Rectangle); // ... &#125;&#125;class Square extends Rectangle &#123; constructor(length) &#123; super(length, length); &#125;&#125;var obj = new Square(3); // Square===Rectangle，所以输出 false， 利用这个特点，可以写出不能独立使用、必须继承后才能使用的类 1234567891011121314151617class Shape &#123; constructor() &#123; if (new.target === Shape) &#123; throw new Error('本类不能实例化'); &#125; &#125;&#125;class Rectangle extends Shape &#123; constructor(length, width) &#123; super(); // ... &#125;&#125;var x = new Shape(); // 报错var y = new Rectangle(3, 4); // 正确 class的继承extends Class 可以通过extends关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。123456// 定义了一个ColorPoint类，该类通过extends关键字，继承了Point类的所有属性和方法。class Point &#123;&#125;class ColorPoint extends Point &#123;&#125; super ES5 的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。ES6 的继承机制完全不同，实质是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。 123456class ColorPoint extends Point &#123; constructor(x, y, color) &#123; super(x, y); // 调用父类的constructor(x, y)，获取父类的实例(this对象) this.color = color; &#125;&#125; 子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。 12345678class Point &#123; /* ... */ &#125;class ColorPoint extends Point &#123; constructor() &#123;// 指定了constructor，但没有调用super方法 &#125;&#125;let cp = new ColorPoint(); // ReferenceError 当未显示指定constructor方法时，会默认添加constructor方法，并在内部自动调用super方法 123456789class ColorPoint extends Point &#123;&#125;// 等同于class ColorPoint extends Point &#123; constructor(...args) &#123; super(...args); &#125;&#125; 只有调用super之后，才可以使用this关键字，否则会报错。这是因为子类实例的构建，是基于对父类实例加工，只有super方法才能返回父类实例 1234567891011121314class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125;&#125;class ColorPoint extends Point &#123; constructor(x, y, color) &#123; this.color = color; // ReferenceError，子类没有自己的this，必须先获得父类的this super(x, y); this.color = color; // 正确 &#125;&#125; super的使用 super关键字可以当函数使用，也可以当作对象使用 super作为函数调用时，代表父类的构造函数 1234567class A &#123;&#125;class B extends A &#123; constructor() &#123; super();// 调用父类的constructor，得到父类的this(实例对象)，进而可以进行加工得到自己的实例对象 &#125;&#125; super虽然代表了父类A的构造函数，但是返回的是子类B的实例，即super内部的this指的是B，因此super()在这里相当于A.prototype.constructor.call(this)。这里其实就可以理解为，先调用父类的构造函数方法创建一个父类的实例对象，然后拷贝一份给子类，这样子类就拥有了自己的实例对象，然后通过子类自己的构造函数对拷贝过来的实例对象进行修改加工。 123456789101112class A &#123; constructor() &#123; console.log(new.target.name); &#125;&#125;class B extends A &#123; constructor() &#123; super(); &#125;&#125;new A() // Anew B() // B 作为函数时，super()只能用在子类的构造函数之中，用在其他地方就会报错。 1234567class A &#123;&#125;class B extends A &#123; m() &#123; super(); // 报错 &#125;&#125; super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 普通方法中// 子类B当中的super.p()，就是将super当作一个对象使用。这时，super在普通方法之中，指向A.prototype，所以super.p()就相当于A.prototype.p()class A &#123; p() &#123; return 2; &#125;&#125;class B extends A &#123; constructor() &#123; super(); console.log(super.p()); // 2 &#125;&#125;let b = new B();// 由于super指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过super调用的class A &#123; constructor() &#123; this.p = 2; &#125;&#125;class B extends A &#123; get m() &#123; return super.p;// super代表的是A.prototype，实例方法无法引用到 &#125;&#125;let b = new B();b.m // undefined// 如果属性定义在父类的原型对象上，super就可以取到。class A &#123;&#125;A.prototype.x = 2;class B extends A &#123; constructor() &#123; super(); console.log(super.x) // 2 &#125;&#125;let b = new B(); ES6 规定，通过super调用父类的方法时，super会绑定子类的this 123456789101112131415161718192021class A &#123; constructor() &#123; this.x = 1; &#125; print() &#123; console.log(this.x); &#125;&#125;class B extends A &#123; constructor() &#123; super(); this.x = 2; &#125; m() &#123; super.print();// 调用父类原型对象上的print方法，但是this绑定的是子类的，实际上执行的是super.print.call(this) &#125;&#125;let b = new B();b.m() // 2 由于绑定子类的this，所以如果通过super对某个属性赋值，这时super就是this，赋值的属性会变成子类实例的属性 1234567891011121314151617class A &#123; constructor() &#123; this.x = 1; &#125;&#125;class B extends A &#123; constructor() &#123; super(); this.x = 2; super.x = 3; console.log(super.x); // undefined console.log(this.x); // 3 &#125;&#125;let b = new B(); 如果super作为对象，用在静态方法之中，这时super将指向父类，而不是父类的原型对象 123456789101112131415161718192021222324class Parent &#123; static myMethod(msg) &#123; console.log('static', msg); &#125; myMethod(msg) &#123; console.log('instance', msg); &#125;&#125;class Child extends Parent &#123; static myMethod(msg) &#123; super.myMethod(msg); &#125; myMethod(msg) &#123; super.myMethod(msg); &#125;&#125;Child.myMethod(1); // static 1var child = new Child();child.myMethod(2); // instance 2 使用super的时候，必须显式指定是作为函数、还是作为对象使用，否则会报错。 12345678class A &#123;&#125;class B extends A &#123; constructor() &#123; super(); console.log(super); // 报错 &#125;&#125; 原生构造函数的继承 ES5中是无法继承原生构造函数，或者继承出来的行为不一致 123456789101112131415161718192021// 子类无法获得原生构造函数的内部属性，通过Array.apply()或者分配给原型对象都不行。原生构造函数会忽略apply方法传入的this，也就是说，原生构造函数的this无法绑定，导致拿不到内部属性。// ES5 是先新建子类的实例对象this，再将父类的属性添加到子类上，由于父类的内部属性无法获取，导致无法继承原生的构造函数。比如，Array构造函数有一个内部属性[[DefineOwnProperty]]，用来定义新属性时，更新length属性，这个内部属性无法在子类获取，导致子类的length属性行为不正常function MyArray() &#123; Array.apply(this, arguments);&#125;MyArray.prototype = Object.create(Array.prototype, &#123; constructor: &#123; value: MyArray, writable: true, configurable: true, enumerable: true &#125;&#125;);var colors = new MyArray();colors[0] = \"red\";colors.length // 0colors.length = 0;colors[0] // \"red\" ES6 允许继承原生构造函数定义子类，因为 ES6 是先新建父类的实例对象this，然后再用子类的构造函数修饰this，使得父类的所有行为都可以继承。 123456789101112class MyArray extends Array &#123; constructor(...args) &#123; super(...args); &#125;&#125;var arr = new MyArray();arr[0] = 12;arr.length // 1arr.length = 0;arr[0] // undefined Decorator修饰器 用来修改类、方法的行为 修饰类 1234567891011121314151617181920212223242526272829303132@testableclass MyTestableClass &#123; // ...&#125;function testable(target) &#123;// target就是要修饰的类 target.isTestable = true;&#125;MyTestableClass.isTestable // true// 等同于class MyTestableClass &#123; // ...&#125;MyTestableClass = testable(MyTestableClass) || MyTestableClass;// 一个参数不够用，可以在修饰器外面再封装一层函数function testable(isTestable) &#123; return function(target) &#123; target.isTestable = isTestable; &#125;&#125;@testable(true) // 返回一个函数，用这个函数来修饰MyTestableClassclass MyTestableClass &#123;&#125;MyTestableClass.isTestable // true@testable(false)class MyClass &#123;&#125;MyClass.isTestable // false 修饰方法 1234567891011121314151617181920class Person &#123; @readonly name() &#123; return `$&#123;this.first&#125; $&#123;this.last&#125;` &#125;&#125;function readonly(target, name, descriptor)&#123; // descriptor对象原来的值如下 // &#123; // value: specifiedFunction, // enumerable: false, // configurable: true, // writable: true // &#125;; descriptor.writable = false; return descriptor;&#125;readonly(Person.prototype, 'name', descriptor);// 类似于Object.defineProperty(Person.prototype, 'name', descriptor); 修饰器只能用于类和类的方法，不能用于函数，因为存在函数提升 1234567891011121314151617181920212223var counter = 0;var add = function () &#123; counter++;&#125;;@addfunction foo() &#123;&#125;// 等同于@addfunction foo() &#123;&#125;var counter;var add;counter = 0;add = function () &#123; counter++;&#125;; Module语法简介 ES6 模块不是对象，而是通过export命令显式指定输出的代码，再通过import命令输入。 import、export命令实现的是静态加载，是在编译阶段加载，而不是运行时再加载，所以效率要比CommonJS 模块的加载方式高12// ES6模块import &#123; stat, exists, readFile &#125; from 'fs'; 严格模式 ES6 的模块自动采用严格模式 ES6 模块之中，顶层的this指向undefined，即不应该在顶层代码使用this。 export命令 export命令用于规定模块的对外接口 123456789101112// profile.jsexport var firstName = 'Michael';export var lastName = 'Jackson';export var year = 1958;// 等同于下面的// profile.jsvar firstName = 'Michael';var lastName = 'Jackson';var year = 1958;export &#123;firstName, lastName, year&#125;; export命令除了输出变量，还可以输出函数或类（class）。 1234567export function multiply(x, y) &#123; return x * y;&#125;;export class Person&#123; ...&#125; 使用as关键字给对外接口重新取名 12345678function v1() &#123; ... &#125;function v2() &#123; ... &#125;export &#123;// v2对外有两个接口名 v1 as streamV1, v2 as streamV2, v2 as streamLatestVersion&#125;; export命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。 123456789101112131415161718192021222324252627282930// 报错export 1;// 报错var m = 1;export m;// 正确写法// 写法一export var m = 1;// 写法二var m = 1;export &#123;m&#125;;// 写法三var n = 1;export &#123;n as m&#125;;// function、class也必须遵守// 报错function f() &#123;&#125;export f;// 正确export function f() &#123;&#125;;// 正确function f() &#123;&#125;export &#123;f&#125;; export语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值 12export var foo = 'bar';setTimeout(() =&gt; foo = 'baz', 500); export、import命令可以出现在模块的任何位置，只要处于模块顶层就可以。如果处于块级作用域内，就会报错 1234function foo() &#123; export default 'bar' // SyntaxError&#125;foo() import命令 使用export命令定义了模块的对外接口以后，其他 JS 文件就可以通过import命令加载这个模块 123456// main.jsimport &#123;firstName, lastName, year&#125; from './profile';// 使用解构赋值获得./profile导出值function setName(element) &#123; element.textContent = firstName + ' ' + lastName;&#125; 同export一样，可对导入的变量使用as重新取名 1import &#123; lastName as surname &#125; from './profile'; import命令具有提升效果，会提升到整个模块的头部，首先执行 123foo();import &#123; foo &#125; from 'my_module'; import命令是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构 12345678910111213// 报错import &#123; 'f' + 'oo' &#125; from 'my_module';// 报错let module = 'my_module';import &#123; foo &#125; from module;// 报错if (x === 1) &#123; import &#123; foo &#125; from 'module1';&#125; else &#123; import &#123; foo &#125; from 'module2';&#125; 模块的整体加载 用星号（*）指定一个对象，所有export输出值都加载在这个对象上面。 12345678910111213141516171819// circle.jsexport function area(radius) &#123; return Math.PI * radius * radius;&#125;export function circumference(radius) &#123; return 2 * Math.PI * radius;&#125;// main.js，单独加载import &#123; area, circumference &#125; from './circle';console.log('圆面积：' + area(4));console.log('圆周长：' + circumference(14));// main.js，整体加载import * as circle from './circle';console.log('圆面积：' + circle.area(4));console.log('圆周长：' + circle.circumference(14)); 用于挂载输出值的对象不可以改写 12345import * as circle from './circle';// 下面两行都是不允许的circle.foo = 'hello';circle.area = function () &#123;&#125;; 注意，直接使用import * as xxx时，是不会导入默认值，会忽略默认值，如果需要同时导入默认值和所有的非默认值需要这么写 1import myDefault,* as myObj from './a' export default 命令 使用export命令时，可以添加default来指定默认输出值，import加载时可用任意的变量名来接收输出值 显然，一个模块只能有一个默认输出，因此export default命令只能使用一次 12345678910111213141516171819202122// export-default.jsexport default function () &#123; console.log('foo');&#125;// import-default.jsimport customName from './export-default';// 这时import命令后面，不使用大括号。customName(); // 'foo'// export default可用在非匿名函数前，加载的时候，视同匿名函数加载。// export-default.jsexport default function foo() &#123; console.log('foo');&#125;// 或者写成function foo() &#123; console.log('foo');&#125;export default foo; 默认输出值，在导入时，不用加{}，非默认导出值需要添加{} 12345678910111213// 第一组export default function crc32() &#123; // 输出 // ...&#125;import crc32 from 'crc32'; // 输入// 第二组export function crc32() &#123; // 输出 // ...&#125;;import &#123;crc32&#125; from 'crc32'; // 输入 本质上，export default就是输出一个叫做default的变量或方法，然后系统允许你为它取任意名字 123456789101112// modules.jsfunction add(x, y) &#123; return x * y;&#125;export &#123;add as default&#125;;// 等同于// export default add;// app.jsimport &#123; default as xxx &#125; from 'modules';// 等同于// import xxx from 'modules'; 如果想在一条import语句中，同时输入默认方法和其他接口，可以写成下面这样 1import _, &#123; each, each as forEach &#125; from 'lodash'; export 与 import 的复合写法 用在一个模块之中，先输入后输出同一个模块 注意，export *命令会忽略模块的default方法1234567891011121314151617181920212223export &#123; foo, bar &#125; from 'my_module';// 等同于import &#123; foo, bar &#125; from 'my_module';export &#123; foo, bar &#125;;// 模块的接口改名和整体输出，也可以采用这种写法// 接口改名export &#123; foo as myFoo &#125; from 'my_module';// 整体输出export * from 'my_module';// 默认接口的写法export &#123; default &#125; from 'foo';// 具名接口改为默认接口的写法export &#123; es6 as default &#125; from './someModule';// 等同于import &#123; es6 &#125; from './someModule';export default es6;// 默认接口也可以改名为具名接口export &#123; default as es6 &#125; from './someModule'; 模块的继承123456789101112131415// circle.jsexport function area(radius) &#123; return Math.PI * radius * radius;&#125;export function circumference(radius) &#123; return 2 * Math.PI * radius;&#125;// circleplus.jsexport * from 'circle';export var e = 2.71828182846;export default function(x) &#123; return Math.exp(x);&#125;// 上面代码中的export *，表示再输出circle模块的所有属性和方法。注意，export *命令会忽略circle模块的default方法(因为后面有自己的默认方法)。然后，上面代码又输出了自定义的e变量和默认方法。 跨模块常量 可以将不同常量放在不同的js文件中，然后集中导入到一个js文件中，并集体输出；使用时只用导入集中的js文件即可12345678910111213141516// constants/db.jsexport const db = &#123; url: 'http://my.couchdbserver.local:5984', admin_username: 'admin', admin_password: 'admin password'&#125;;// constants/user.jsexport const users = ['root', 'admin', 'staff', 'ceo', 'chief', 'moderator'];// constants/index.js，将不同常量导入到一个文件，并到处export &#123;db&#125; from './db';export &#123;users&#125; from './users';// script.js，使用时直接导入集中的文件import &#123;db, users&#125; from './index'; import() import命令是编译时加载，无法做到运行时加载(动态加载)，新提案通过import()函数实现运行时加载 import()返回一个 Promise 对象 123456789const main = document.querySelector('main');import(`./section-modules/$&#123;someVariable&#125;.js`) .then(module =&gt; &#123; module.loadPageInto(main); &#125;) .catch(err =&gt; &#123; main.textContent = err.message; &#125;); 场景 123456789101112131415161718192021// 按需加载button.addEventListener('click', event =&gt; &#123; import('./dialogBox.js') .then(dialogBox =&gt; &#123; dialogBox.open(); &#125;) .catch(error =&gt; &#123; /* Error handling */ &#125;)&#125;);// 条件加载if (condition) &#123; import('moduleA').then(...);&#125; else &#123; import('moduleB').then(...);&#125;// 动态的模块路径import(f()).then(...); Module 的加载实现浏览器加载ES6模块 传统方法，加载普通模块 12345678910111213&lt;!-- 页面内嵌的脚本 --&gt;&lt;script type=\"application/javascript\"&gt; // module code&lt;/script&gt;&lt;!-- 外部脚本 --&gt;&lt;script type=\"application/javascript\" src=\"path/to/myModule.js\"&gt;&lt;/script&gt;&lt;!-- defer是“渲染完再执行” --&gt;&lt;script src=\"path/to/myModule.js\" defer&gt;&lt;/script&gt;&lt;!-- async是“下载完就执行” --&gt;&lt;script src=\"path/to/myModule.js\" async&gt;&lt;/script&gt; 浏览器上加载ES6模块 12345&lt;!-- 需要指定type为module，异步加载，不会造成堵塞浏览器，即等到整个页面渲染完，再执行模块脚本，等同于打开了&lt;script&gt;标签的defer属性。 --&gt;&lt;script type=\"module\" src=\"foo.js\"&gt;&lt;/script&gt;&lt;!-- 等同于 --&gt;&lt;script type=\"module\" src=\"foo.js\" defer&gt;&lt;/script&gt; 对于外部的模块脚本（上例是foo.js），有几点需要注意。 代码是在模块作用域之中运行，而不是在全局作用域运行。模块内部的顶层变量，外部不可见。 模块脚本自动采用严格模式，不管有没有声明use strict。 模块之中，可以使用import命令加载其他模块（.js后缀不可省略，需要提供绝对 URL 或相对 URL），也可以使用export命令输出对外接口。 模块之中，顶层的this关键字返回undefined，而不是指向window。也就是说，在模块顶层使用this关键字，是无意义的。 同一个模块如果加载多次，将只执行一次。12345678import utils from 'https://example.com/js/utils.js';const x = 1;console.log(x === window.x); //falseconsole.log(this === undefined); // truedelete x; // 句法错误，严格模式禁止删除变量 ES6 模块与 CommonJS 模块的差异 CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。ES6模块输出的变量是实时更新的 CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。 ES6模块的循环加载 注意，ES6输出的是一个引用 当一个模块已经加载后，不会重复执行12345678910111213141516171819202122// a.js如下import &#123;bar&#125; from './b.js';console.log('a.js');console.log(bar);export let foo = 'foo';// b.jsimport &#123;foo&#125; from './a.js';console.log('b.js');console.log(foo);export let bar = 'bar';// 执行a.js$ babel-node a.jsb.jsundefineda.jsbar// 由于a.js的第一行是加载b.js，所以先执行的是b.js。而b.js的第一行又是加载a.js，这时由于a.js已经开始执行了，所以不会重复执行，而是继续往下执行b.js，所以第一行输出的是b.js。// 接着，b.js要打印变量foo，这时a.js还没执行完，取不到foo的值，导致打印出来是undefined。b.js执行完，开始执行a.js，这时就一切正常了。 ArrayBuffer简介 先做个简单了解，后期用到再补 ArrayBuffer对象、TypedArray视图和DataView视图是 JavaScript 操作二进制数据的一个接口 这个接口的原始设计目的，与 WebGL 项目有关，与显卡交换数据使用传统文本格式，需要转换效率低下，直接使用二进制交流，效率高 编程风格块级作用域 let 取代 var 123456789'use strict';if (true) &#123; let x = 'hello';&#125;for (let i = 0; i &lt; 10; i++) &#123; console.log(i);&#125; 在全局环境，不应该设置变量，只应设置常量。建议优先使用const 所有的函数都应该设置为常量123456789101112// badvar a = 1, b = 2, c = 3;// goodconst a = 1;const b = 2;const c = 3;// bestconst [a, b, c] = [1, 2, 3];const add=(x,y)=&gt;x+y; 字符串 静态字符串一律使用单引号或反引号，不使用双引号。动态字符串使用反引号。1234567891011// badconst a = \"foobar\";const b = 'foo' + a + 'bar';// acceptableconst c = `foobar`;// goodconst a = 'foobar';const b = `foo$&#123;a&#125;bar`;const c = 'foobar'; 解构赋值 使用数组成员对变量赋值时，优先使用解构赋值。 12345678const arr = [1, 2, 3, 4];// badconst first = arr[0];const second = arr[1];// goodconst [first, second] = arr; 函数的参数如果是对象的成员，优先使用解构赋值。 1234567891011121314// badfunction getFullName(user) &#123; const firstName = user.firstName; const lastName = user.lastName;&#125;// goodfunction getFullName(obj) &#123; const &#123; firstName, lastName &#125; = obj;&#125;// bestfunction getFullName(&#123; firstName, lastName &#125;) &#123;&#125; 如果函数返回多个值，优先使用对象的解构赋值，而不是数组的解构赋值。这样便于以后添加返回值，以及更改返回值的顺序 1234567891011// badfunction processInput(input) &#123; return [left, right, top, bottom];&#125;// goodfunction processInput(input) &#123; return &#123; left, right, top, bottom &#125;;&#125;const &#123; left, right &#125; = processInput(input); 对象 多行定义的对象，最后一个成员以逗号结尾。 12345678910111213// badconst a = &#123; k1: v1, k2: v2, &#125;;const b = &#123; k1: v1, k2: v2&#125;;// goodconst a = &#123; k1: v1, k2: v2 &#125;;const b = &#123; k1: v1, k2: v2,&#125;; 对象尽量静态化，一旦定义，就不得随意添加新的属性。如果添加属性不可避免，要使用Object.assign方法 1234567891011// badconst a = &#123;&#125;;a.x = 3;// if reshape unavoidableconst a = &#123;&#125;;Object.assign(a, &#123; x: 3 &#125;);// goodconst a = &#123; x: null &#125;;a.x = 3; 如果对象的属性名是动态的，可以在创造对象的时候，使用属性表达式定义 12345678910111213// badconst obj = &#123; id: 5, name: 'San Francisco',&#125;;obj[getKey('enabled')] = true;// goodconst obj = &#123; id: 5, name: 'San Francisco', [getKey('enabled')]: true,&#125;; 对象的属性和方法，尽量采用简洁表达法，这样易于描述和书写 1234567891011121314151617181920212223var ref = 'some value';// badconst atom = &#123; ref: ref, value: 1, addValue: function (value) &#123; return atom.value + value; &#125;,&#125;;// goodconst atom = &#123; ref, value: 1, addValue(value) &#123; return atom.value + value; &#125;,&#125;; 数组 使用扩展运算符（…）拷贝数组 1234567891011// badconst len = items.length;const itemsCopy = [];let i;for (i = 0; i &lt; len; i++) &#123; itemsCopy[i] = items[i];&#125;// goodconst itemsCopy = [...items]; Array.from方法，将类似数组的对象转为数组。 12const foo = document.querySelectorAll('.foo');const nodes = Array.from(foo); 函数 立即执行函数可以写成箭头函数的形式 123(() =&gt; &#123; console.log('Welcome to the Internet.');&#125;)(); 那些需要使用函数表达式的场合，尽量用箭头函数代替 123456789101112// bad[1, 2, 3].map(function (x) &#123; return x * x;&#125;);// good[1, 2, 3].map((x) =&gt; &#123; return x * x;&#125;);// best[1, 2, 3].map(x =&gt; x * x); 箭头函数取代Function.prototype.bind，不应再用self/_this/that绑定 this 1234567891011// badconst self = this;const boundMethod = function(...params) &#123; return method.apply(self, params);&#125;// acceptableconst boundMethod = method.bind(this);// bestconst boundMethod = (...params) =&gt; method.apply(this, params); 所有配置项都应该集中在一个对象，放在最后一个参数，布尔值不可以直接作为参数 1234567// badfunction divide(a, b, option = false ) &#123;&#125;// goodfunction divide(a, b, &#123; option = false &#125; = &#123;&#125;) &#123;&#125; 不要在函数体内使用arguments变量，使用rest运算符（…）代替 12345678910// badfunction concatenateAll() &#123; const args = Array.prototype.slice.call(arguments); return args.join('');&#125;// goodfunction concatenateAll(...args) &#123; return args.join('');&#125; 使用默认值语法设置函数参数的默认值 123456789// badfunction handleThings(opts) &#123; opts = opts || &#123;&#125;;&#125;// goodfunction handleThings(opts = &#123;&#125;) &#123; // ...&#125; Map 只有模拟现实世界的实体对象时，才使用Object。如果只是需要key: value的数据结构，使用Map结构。因为Map有内建的遍历机制12345678910111213let map = new Map(arr);for (let key of map.keys()) &#123; console.log(key);&#125;for (let value of map.values()) &#123; console.log(value);&#125;for (let item of map.entries()) &#123; console.log(item[0], item[1]);&#125; Class 总是用Class，取代需要prototype的操作； 123456789101112131415161718192021// badfunction Queue(contents = []) &#123; this._queue = [...contents];&#125;Queue.prototype.pop = function() &#123; const value = this._queue[0]; this._queue.splice(0, 1); return value;&#125;// goodclass Queue &#123; constructor(contents = []) &#123; this._queue = [...contents]; &#125; pop() &#123; const value = this._queue[0]; this._queue.splice(0, 1); return value; &#125;&#125; 使用extends实现继承 12345678910111213141516// badconst inherits = require('inherits');function PeekableQueue(contents) &#123; Queue.apply(this, contents);&#125;inherits(PeekableQueue, Queue);PeekableQueue.prototype.peek = function() &#123; return this._queue[0];&#125;// goodclass PeekableQueue extends Queue &#123; peek() &#123; return this._queue[0]; &#125;&#125; 模块 Module语法是JavaScript模块的标准写法，坚持使用这种写法。使用import取代require，使用export取代module.exports。 1234567891011121314151617181920212223242526272829// badconst moduleA = require('moduleA');const func1 = moduleA.func1;const func2 = moduleA.func2;// goodimport &#123; func1, func2 &#125; from 'moduleA';// commonJS的写法var React = require('react');var Breadcrumbs = React.createClass(&#123; render() &#123; return &lt;nav /&gt;; &#125;&#125;);module.exports = Breadcrumbs;// ES6的写法import React from 'react';class Breadcrumbs extends React.Component &#123; render() &#123; return &lt;nav /&gt;; &#125;&#125;;export default Breadcrumbs; 如果模块只有一个输出值，就使用export default，如果模块有多个输出值，就不使用export default，export default与普通的export不要同时使用 12345678910111213// badconst add=(x,y)=&gt;x+y;const PI=3.14;export add;export default PI;// goodconst add=(x,y)=&gt;x+y;const PI=3.14;export add;export PI; 不要在模块输入中使用通配符。因为这样可以确保你的模块之中，有一个默认输出（export default）。因为import *会忽略模块的默认值 12345// badimport * as myObject from './importModule';// goodimport myObject from './importModule'; 东西很多，先做个大概了解，后期用到再做更加细致的了解。以上。","tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"Deferred_Promise","date":"2017-09-07T12:56:31.000Z","path":"2017/09/07/Deferred-Promise/","text":"在最近项目中经常会遇到异步处理的相关问题，在查阅相关资料后，特在此做一篇笔记。 使用Deferred、Promise解决jQuery中异步相关问题问题 ABC是3个异步请求，现在要求C在AB三个异步请求都成功返回的情况下再执行。这种就比较麻烦，可以尝试设置请求完成状态变量，当AB的请求完成变量都true时再请求C；如果不只3个请求，这种方法就会很糟糕。 ABC是3个异步请求，现在要求ABC3个请求按顺序依次执行，A-&gt;B-&gt;C。这种用传统方法可能就需要用回调嵌套的方法来实现 以上两种情况是在异步中经常遇到的，用传统方法编写，会导致嵌套层次过多，不仅影响可读性，还不易于维护。为了解决这种问题，CommonJs组织制定了异步编程规范Promises/A。这个规范有很多实现，如when.js、ES6的Promise等。今天就借助jQuery的Deferred、Promise对象来做个简单了解。 Promise状态Promise对象存在3种状态 pending(未完成状态) resolved(肯定状态) rejected(否定状态) 这三种状态的转换关系 pending-&gt;resolved pending-&gt;rejected pending-&gt;pending 当转换到resolved或者rejected状态时，状态是无法再发生变化，即下面的状态转换都是不可行的 resolved-&gt;rejected resolved-&gt;pending rejected-&gt;resolved rejected-&gt;pending 创建一个Promise对象在jQuery中Deferred可以理解为Promise的加强版，先不做区分，可以将Deferred当成就是Promise，后面会介绍二者区别。123456789var dfr=$.Deferred();// 创建一个Deferred对象(就是Promise对象)console.log(dfr.state());// 获取当前状态,pendingdfr.resolve();// 将Deferred对象状态改变为resolvedconsole.log(dfr.state());// resolvedvar dfr2=$.Deferred();console.log(dfr2.state());// 获取当前状态,pendingdfr.reject();// 将Deferred对象状态改变为rejectedconsole.log(dfr2.state());// rejected 状态的作用 通过上面的例子，我们可以知道，可以人为的改变Deferred对象的状态。状态不一样有什么用呢？我们可以根据不同的状态进行不同的操作(添加不同的回调函数)。 给Promise对象添加回调添加回调，并触发12345678910111213var dfr=$.Deferred();// 创建Deferred对象dfr.done(function()&#123;// Deferred对象状态变为resolved时的回调 alert('成功');&#125;).fail(function()&#123;// Deferred对象状态变为reject时的回调 alert('失败');&#125;).progress(function()&#123;// Deferred对象状态为pending时的回调 alert('进行中...');&#125;);dfr.notify(); // 触发Deferred对象pending状态的回调dfr.resolve();// 触发Deferred对象resolved状态的回调 通过done()、fail()、progress()给Deferred对象的不同状态分别添加了回调，并通过notify()、resolve触发了响应的回调 传递数据 通过done()、fail()、progress()触发Deferred对象的回调时，可传递一些数据(任何类型)给回调函数12345678910111213var dfr2=$.Deferred();// 创建Deferred对象dfr2.done(function(msg)&#123;// Deferred对象状态变为resolved时的回调 alert(msg+'成功');&#125;).fail(function(msg)&#123;// Deferred对象状态变为reject时的回调 alert(msg+'失败');&#125;).progress(function(msg)&#123;// Deferred对象状态为pending时的回调 alert(msg+'进行中...');&#125;);dfr2.notify('dfr2'); // dfr2进行中...dfr2.reject('dfr2');// dfr2失败 链式调用 done()、fail()、progress()会返回调用者对象Deferred对象，因此可以进行无限的链式调用；可以在done()后再添加done()、fail()、progress()，他们会在对应状态被激活时，依次按照添加顺序调用。12345678910111213141516var dfr=$.Deferred();dfr.done(function()&#123; // 回调1 alert('成功1');&#125;).fail(function()&#123; alert('失败');&#125;).progress(function()&#123; alert('进行中...');&#125;).done(function()&#123;// 回调2 alert('成功2');&#125;);dfr.resolve();// 成功1-&gt;成功2 deferred.always() 通过deferred.always()添加的回调，无论状态是resolved还是rejected都会在最后被调用12345678910111213141516var dfr=$.Deferred();dfr.done(function()&#123;// alert('成功1');&#125;).fail(function()&#123; alert('失败');&#125;).progress(function()&#123; alert('进行中...');&#125;).always(function()&#123; alert('我总会被执行');&#125;);dfr.resolve();// 成功1-&gt;我总会被执行 Deferred对象使用方式1234567891011var dfr = $.Deferred();// 创建一个Deferred对象var task = function(dtd) &#123; setTimeout(function() &#123; console.log('timeOut'); dtd.resolve(); // 异步任务结束，手动resolve &#125;, 3000); return dtd;// 返回Deferred对象，供$.when()使用&#125;;$.when(task(dfr)).done(function() &#123; alert('success');// 3s后弹出&#125;); 上面例子由于dfr是全局对象，并且包含改变状态的方法resolve、reject，所以可以在外部提前终止任务 123456789101112var dfr = $.Deferred();// 创建一个Deferred对象var task = function(dtd) &#123; setTimeout(function() &#123; console.log('timeOut'); dtd.resolve(); // 异步任务结束，手动resolve &#125;, 3000); return dtd;// 返回Deferred对象，供$.when()使用&#125;;$.when(task(dfr)).done(function() &#123; alert('success');// 立即弹出&#125;);dfr.resolve();// 外部resolve后会立即执行done 防止外部终止，可以将全局的dfr放到函数内部 123456789101112var task = function() &#123; var dfr = $.Deferred();// 创建一个Deferred对象 setTimeout(function() &#123; console.log('timeOut'); dfr.resolve(); // 异步任务结束，手动resolve &#125;, 3000); return dfr;// 返回Deferred对象，供$.when()使用&#125;;$.when(task()).done(function() &#123; alert('success');// 立即弹出&#125;);dfr.resolve();// 无法调用 jQuery中Deferred和Promise的区别 Deferred对象可以理解为Promise对象的加强版。 Deferred对象包含改变状态的方法，如dfr.resolve()、dfr.reject()、dfr.notify() Promise对象则不包含以上方法； 要想改变状态必须在Deferred对象上调用相关方法，Promise对象没有相关方法。 通过deferred.promise()可以将Deferred对象转换为Promise对象 在ajax中使用Promiseajax和Promise的关系 在jQuery1.5之前$.ajax()返回的是一个jqXHR对象，1.5之后返回的是一个类Promise对象，它在原先的jqXHR对象基础上又添加一些Promise方法，因此我们能在$.ajax()之后链式调用Promise相关方法； 注意返回的是一个类Promise对象，因此它不包含改变状态的相关方法； 改变相关状态由ajax内部完成，无需手动调用相关方法(也无法调用)；1234567891011121314151617// 老的ajax写法 $.ajax(&#123; url: \"a.html\", success: function()&#123; alert(\"成功\"); &#125;, error:function()&#123; alert(\"错误\"); &#125; &#125;); // 使用promise后的写法 $.ajax(\"test.html\") .done(function()&#123;&#125;) .fail(function()&#123;&#125;) .done(function()&#123;&#125;) .fail(function()&#123;&#125;); 解决问题1 问题1要求C在AB都执行完后再执行。即A&amp;&amp;B-&gt;C；这时候就需要使用jQuery提供的$.when()函数。$.when()返回一个Promise对象。所以可以调用done、fail、progress等函数 12345678$.when($.ajax(url1),$.ajax(url2)).done(function()&#123; console.log('url1、url2都请求成功'); $.ajax(url3)&#125;).fail(function()&#123; console.log('url1、url2有一个或者两个没请求成功');&#125;); $.when()实现了多个ajax请求完成后再执行某些操作；即实现了A&amp;&amp;B-&gt;C的效果 解决问题2 问题2的要求是ABC3个异步请求顺序执行。传统写法可能是 1234567891011121314$.ajax(&#123; url:'a.json', success:function()&#123; $.ajax(&#123; url:'b.json', success:function()&#123; $.ajax(&#123; url:'c.json', success:function()&#123; console.log('gg'); &#125; &#125; &#125;&#125;); 可读性很差，还不方便维护。为解决问题2需要使用到jQuery提供的Deferred.then()方法； then方法可以传入3个回调，分别是resolved、rejected、pending状态的回调； 123456789101112131415161718192021222324252627function success(data) &#123; alert(\"success data = \" + data); &#125; function fail(data) &#123; alert(\"fail data = \" + data); &#125; function progress(data) &#123; alert(\"progress data = \" + data); &#125; var deferred = $.Deferred(); // 一起注册回调 deferred.then(success, fail, progress); // 分别注册回调 deferred.done(success); deferred.fail(fail); deferred.progress(progress); deferred.notify(\"10%\"); deferred.resolve(\"ok\"); 其实在执行then方法后将返回一个新的Promise对象 可以在后面无限级联调用相关Promise方法.then().then().done().fail()…. 这就意味着在then后就无法在返回对象(返回的是Promise对象)上手动改变状态了。 必须在原先的Deferred对象上调用方法改变状态12345678910111213141516171819202122232425function success(data) &#123; alert(\"success data = \" + data); &#125; function fail(data) &#123; alert(\"fail data = \" + data); &#125; function progress(data) &#123; alert(\"progress data = \" + data); &#125; var dfr=$.Deferred();var pro=dfr.then(success,fail,progress);console.log(dfr===pro);// false// 没有改变状态的方法console.log('resolve' in pro); // falseconsole.log('reject' in pro); // falseconsole.log('notify' in pro); // false// 只能在原先的Deferred对象调用相关方法dfr.resolve('resolved'); // success data = resolved 其实then()中传入的不是回调函数，官方说法又叫做过滤函数；前面说过Deferred对象在调用改变状态方法时，可以传递数据，其实通过then注册的回调可以对数据进行过滤，然后通过return将数据传递给下一个回调函数(done、fail、progress)，如果下一个回调函数是通过then注册的，则可以继续对数据进行过滤，并传递给下一个对应状态的回调函数； 我们知道deferred.resolve()、deferred.reject()、deferred.notify()可以指定参数值，这个参数会传递给相应状态下的回调函数。 如果我们使用的是done()、fail()、progress()注册的回调函数，那么某个状态下的所有回调函数得到的都是相同参数。 不是通过then注册的回调函数，无法对数据过滤并通过return传递给下一个回调，他们得到的都是相同值，可看下面例子 1234567891011121314var dfr = $.Deferred();dfr.done(function(type) &#123; console.log(type);// resolved return type + 'first';&#125;).done(function(type) &#123; console.log(type);// resolved return type + 'last';&#125;).done(function(type) &#123; console.log(type);// resolved&#125;);dfr.resolve('resolved'); 但是如果我们使用了then()注册回调函数，那么第一回调函数的返回值将作为第二个回调函数的参数，同样的第二个函数的返回值是第三个回调函数的参数。 12345678910111213141516var deferred = $.Deferred(); // then()返回的是一个新Promise对象 //then注册的回调函数的返回值将作为这个新Promise的参数 var then_ret = deferred.then(function(data)&#123; alert(\"data=\"+data);//5 对数据进行过滤 return 2 * data; // 并通过return 传递给下一个done&#125;); alert(then_ret == deferred);//false then_ret.done(function(data)&#123; alert(\"data=\"+data);//10 &#125;); deferred.resolve( 5 ); 如果仔细观察，会发现在上面例子中，我们返回的是普通值，如果我们返回的是Deferred或者Promise对象，它会将返回的Deferred、Promise对象的状态和返回值传递给下一个回调函数，做为其触发依据和参数。可以用这种方法解决问题2 12345678910var promise1 = $.ajax(url1); var promise2 = promise1.then(function(data)&#123; return $.ajax(url2, &#123; \"data\": data &#125;);// 返回一个promise，它的状态将决定触发promise2.then中的哪个回调，它的返回值将传递给对应的回调函数&#125;); var promise3 = promise2.then(function(data)&#123; return $.ajax(url3);// 返回一个promise，它的状态将决定触发promise3中的哪个回调，它的返回值将传递给对应的回调函数&#125;); promise3.done(function(data)&#123; console.log(data);&#125;); 这样其实我们可以得到一个范式，处理有依赖关系的异步请求时，可以.then().then().done().fail()，通过then中的回调(过滤)函数，对数据进行加工，最后交给不是通过then注册的done或者fail来进行最后处理；done其实就预示着对传过来的数据不进行加工了； 总结 jQuery中的Deferred、Promise对象主要用来解决异步任务中嵌套问题 Deferred可以理解为Promise对象的加强版 Deferred对象拥有方法resolve、reject、notify来手动改变状态 Promise对象无法手动改变状态 deferred.promise()可以将一个Deferred对象转换成Promise对象 jQuery中异步任务返回的都是Promise对象或者类Promise对象(ajax返回的)，它们都无法手动改变状态，它们状态的改变是jQuery在内部自动完成的 $.Deferred()返回一个Deferred对象 deferred.done、deferred.fail、deferred.progress用来定义Deferred对象状态对应的回调函数 deferred.always()来用定义无论成功还是失败都会调用回调函数 deferred.resolve()、deferred.reject()手动改变Deferred对象的状态 改变状态时，可以传递数据给回调函数 deferred.resolve(‘msg’) 防止改变状态方法在异步任务外调用 可将Deferred对象定义为异步任务内的局部变量 可以使用deferred.promise()转换成Promise对象 deferred.notify()用来触发deferred.progress定义的回调函数，实际可以用来完成进度条效果 deferred.then()会返回一个新的promise对象 then中定义的回调函数可以理解为过滤函数，可对resolve、reject中传递的数据进行加工、过滤，然后通过return传递给下一个回调函数 如果return的是Deferred或者Promise对象，它会将返回的Deferred、Promise对象的状态和返回值传递给下一个回调函数，做为其触发依据和参数。 A&amp;&amp;B-&gt;C类型异步任务可以使用$.when()来解决；见上面例子 范式123456$.when($.ajax(url1),$.ajax(url2)).done(function()&#123; $.ajax(url3);&#125;).fail(function()&#123; console.log('出错');); A-&gt;B-&gt;C类型异步任务可以使用Promise对象的then()来解决；见上面例子 范式12345678910111213$.ajax(url1).then(function(url1Data)&#123; return $.ajax(url2);&#125;).then(function(url2Data)&#123; return $.ajax(url3);&#125;).done(function(url3Data)&#123; // 最终成功处理&#125;).fail(function(url3Data)&#123; // 最终失败处理&#125;);","tags":[{"name":"异步","slug":"异步","permalink":"http://yoursite.com/tags/异步/"},{"name":"Promise","slug":"Promise","permalink":"http://yoursite.com/tags/Promise/"}]},{"title":"Bootstrap-table_API","date":"2017-09-07T12:44:29.000Z","path":"2017/09/07/Bootstrap-table-API/","text":"最近在项目中需要使用到表格控件，调研几个常用的表格控件(jquery-dataTable、list.js、jqGrid、Bootstrap-table)后，决定使用Bootstrap-table，特意将常用API记录下来，以备后用。源码可在这https://github.com/BryanAdamss/SourceSave/tree/master/Practice 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 引入bootstrap样式 --&gt; &lt;link rel=\"stylesheet\" href=\"./vendors/bootstrap-3.3.7-dist/css/bootstrap.min.css\"&gt; &lt;!-- 引入bootstrap-table样式 --&gt; &lt;link rel=\"stylesheet\" href=\"./vendors/bootstrap-table/bootstrap-table.css\"&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"btn-group hidden-xs\" id=\"js_caremaTableToolBar\" role=\"group\"&gt; &lt;a href=\"#\" class=\"btn btn-outline btn-default\"&gt;&lt;i class=\"glyphicon glyphicon-plus\" aria-hidden=\"true\"&gt;&lt;/i&gt;&lt;/a&gt; &lt;/div&gt; &lt;table id=\"js_caremaTable\" data-height=\"400\" data-icon-size=\"outline\" data-striped=\"true\"&gt; &lt;/table&gt; &lt;script src=\"./js/jquery.min.js\"&gt;&lt;/script&gt; &lt;!-- 引入bootstrap.js --&gt; &lt;script src=\"./vendors/bootstrap-3.3.7-dist/js/bootstrap.min.js\"&gt;&lt;/script&gt; &lt;!-- bootstrap-table主js --&gt; &lt;script src=\"./vendors/bootstrap-table/bootstrap-table.js\"&gt;&lt;/script&gt; &lt;!-- bootstrap-table本地化文件 --&gt; &lt;script src=\"./vendors/bootstrap-table/locale/bootstrap-table-zh-CN.js\"&gt;&lt;/script&gt; &lt;script&gt; var caremaTable = $('#js_caremaTable').bootstrapTable(&#123; url: './json/bootstrap_table_test.json', method: 'get', // 请求方式 uniqueId: 'id', // 每一行的唯一id，一般设置为主键列，此处用数据中的'id'做为每一行的唯一标识；可用在一些方法中如removeByUniqueId，不设置uniqueId时，调用此类方法会出错 search: true, // 启用搜索 sortable: true, // 全局配置，是否启用列排序；若为false，即使列上设置了sortable:true，列也无法进行排序 pagination: true, // 启用分页 sidePagination: 'client', // 设置在哪里进行分页，可选值为 'client' 或者 'server'。设置 'server'时，必须设置 服务器数据地址（url）或者重写ajax方法 showRefresh: true, // 启用刷新 showColumns: true, // 启用内容列下拉框 showToggle: true, // 是否显示 切换试图（table/card）按钮 showPaginationSwitch: true, // 是否显示切换分页按钮 toolbar: '#js_caremaTableToolBar', // 工具栏 cache: true, // 设置为 false 禁用 AJAX 数据缓存 singleSelect: false, // 设置True 将禁止radio、checkbox多选，并隐藏选择全部按钮 class: 'cgh_dfjakdjfklasjdfklajslkdfjlkaf', columns: [&#123; checkbox: true, // 此列为checkbox &#125;, // &#123; // radio: true // 此列为radio // &#125;, &#123; field: 'id', title: '编号', sortable: true, // 此列表头点击，可进行排序，前提必须是表格的sortable为true titleTooltip: '点击可进行排序', // 悬停tooltip width: '100px' &#125;, &#123; field: 'name', title: '名称', &#125;, &#123; field: 'place', title: '预置位' &#125;, &#123; field: 'userName', title: '连接用户名' &#125;, &#123; field: 'password', title: '连接密码' &#125;, &#123; field: 'channel', title: '远程频道' &#125;, &#123; field: 'lng', title: '经度' &#125;, &#123; field: 'lat', title: '纬度', &#125;, &#123; title: '操作', formatter: function(value, row, index) &#123; return '&lt;a href=\"javascript:;\" class=\"text-danger m-l js_delete\"&gt;删除&lt;/a&gt;' &#125;, events: &#123; // 按钮点击事件 'click .js_delete': function(e, value, row, index) &#123; console.log(e, value, row, index); if (confirm('确定删除此行吗？')) &#123; caremaTable.bootstrapTable('removeByUniqueId', row.id); // 当表格配置了uniqueId: 'id'时，可通过removeByUniqueId来删除当前行 // caremaTable.bootstrapTable('remove', &#123; // 删除name列值为'测试0'的行 // field: 'name', // values: ['测试0'] // 注意values必须是一个数组 // &#125;); // caremaTable.bootstrapTable('remove', &#123; // 删除当前行，由于id在创建数据时是唯一的，所以通过点击获取row中的id数据，然后删除id列值为row.id的行；不过还是建议通过配置uniqueId然后通过removeByUniqueId方法来删除 // field: 'id', // values: [row.id] // &#125;); &#125; &#125; &#125; &#125; ], onCheck: function(row) &#123; // 单独选中某一个check时触发 console.log('onCheck', row); &#125;, onUncheck: function(row) &#123; console.log('onUncheck', row); // uncheck某一个check时触发 &#125;, onCheckAll: function(rows) &#123; console.log('onCheckAll', rows); // 全选check时触发 &#125;, onUncheckAll: function(rows) &#123; console.log('onUncheckAll', rows); // uncheck所有check时触发 &#125; &#125;); // 常用方法 // 调用方法的语法：$('#table').bootstrapTable('method', parameter); // 全部方法请参阅http://bootstrap-table.wenzhixin.net.cn/zh-cn/documentation/#方法 // caremaTable.bootstrapTable('getSelections'); // 返回所选的行，当没有选择任何行的时候返回一个空数组。 // caremaTable.bootstrapTable('getAllSelections'); // 返回所有选择的行，包括搜索过滤前的，当没有选择任何行的时候返回一个空数组。 // caremaTable.bootstrapTable('getData'); // 获取当前加载的数据。 // caremaTable.bootstrapTable('getRowByUniqueId', 3); // 根据 uniqueId 获取行数据。 // caremaTable.bootstrapTable('load', data); // 加载数据到表格中，旧数据会被替换。 // caremaTable.bootstrapTable('showAllColumns'); // 显示所有列。 // caremaTable.bootstrapTable('hideAllColumns'); // 隐藏所有列。 // caremaTable.bootstrapTable('append'); // 添加数据到表格在现有数据之后。 // caremaTable.bootstrapTable('prepend'); // 插入数据到表格在现有数据之前。 // caremaTable.bootstrapTable('remove', &#123; field: 'id', values: someArr &#125;); // 从表格中删除数据，包括两个参数： field: 需要删除的行的 field 名称。values: 需要删除的行的值，类型为数组。 // caremaTable.bootstrapTable('removeAll'); // 删除表格所有数据。 // caremaTable.bootstrapTable('removeByUniqueId'); // 根据 uniqueId 删除指定的行。 // caremaTable.bootstrapTable('insertRow', &#123; index: 1, row: row &#125;); // 插入新行，参数包括：index: 要插入的行的 index。row: 行的数据，Object 对象。 // caremaTable.bootstrapTable('updateRow', &#123; index: 1, row: row &#125;); // 更新指定的行，参数包括：index: 要更新的行的 index。row: 行的数据，Object 对象。 // caremaTable.bootstrapTable('showRow', &#123; index: 1 &#125;); // 显示指定的行，参数包括：index: 要更新的行的 index 或者 uniqueId。isIdField: 指定 index 是否为 uniqueid。 // caremaTable.bootstrapTable('hideRow', &#123; index: 1 &#125;); // 隐藏指定的行，参数包括：index: 要更新的行的 index 或者 uniqueId。isIdField: 指定 index 是否为 uniqueid。 // caremaTable.bootstrapTable('checkAll'); // 选中所有行 // caremaTable.bootstrapTable('uncheckAll'); // uncheck所有行 // caremaTable.bootstrapTable('check', 0); // 选中第一行 // caremaTable.bootstrapTable('uncheck', 0); // 取消选中第一行 // caremaTable.bootstrapTable('checkBy', &#123; field: \"field_name\", values: [\"value1\", \"value2\", \"value3\"] &#125;); // 选中field_name为value1、value2、value3的行 // caremaTable.bootstrapTable('uncheckBy', &#123; field: \"field_name\", values: [\"value1\", \"value2\", \"value3\"] &#125;); // 取消选中field_name为value1、value2、value3的行 $(window).resize(function() &#123; // 防止thead和tbody在缩放情况下不对齐 caremaTable.bootstrapTable('resetView'); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","tags":[{"name":"表格","slug":"表格","permalink":"http://yoursite.com/tags/表格/"}]},{"title":"type-existence","date":"2017-08-04T08:08:31.000Z","path":"2017/08/04/type-existence/","text":"本来在《编写可维护性的javascript》中已经做过总结，但最近在使用上又出现一点问题，所以推翻以前的单独写篇关于类型检测和存在性检测的文章 类型检测和存在性检测必备知识点 哪些值会被转成false “”、0、NaN、false、null、undefined会在期待布尔值的地方被转成false; 非上面提及的值都会被转成true； 注意空对象(没有任何属性/方法的对象)也会视为true1234var a=&#123;&#125;;if(a)&#123; console.log(true);// true&#125; 声明和赋值 未声明(更未赋值)的变量 直接使用，会报错 1console.log(b);// Uncaught ReferenceError: b is not defined 如果通过typeof b来使用，则不会报错；因为typeof存在一个特殊的安全防范机制； 已声明未赋值的变量 会有默认值undefined123var a;console.log(a===undefined);// trueconsole.log(typeof a);// 'undefined' 注意:当未声明的变量使用typeof检测时，并不会报错，而且返回&#39;undefined&#39;；因为typeof存在一个特殊的安全防范机制； 1console.log(typeof b);// 'undefined'，并没有报错 总结 未声明和已声明未赋值的变量使用typeof检测时，都会返回&#39;undefined&#39; 访问对象上不存在的属性/方法时，并不会报错，而是返回一个undefined 1234var obj=&#123; a:3&#125;;console.log(obj.b);// undefined 类型检测-&gt;(判断值的类型) 首先变量是没有类型的，类型本质指的是变量持有的值的类型，一般说的变量类型，实际指的是变量持有的值的类型 判断类型主要用来，检测输入的参数是否为想要的类型 12345function test(fn)&#123; if(typeof fn==='function')&#123; // xxxxx &#125;&#125; 一般值 string、number、boolean、undefined-&gt;typeof来判断 null一般不用做类型检测，只有在变量是一个可预期的null值时，才用来判断1234var obj=null;if(obj===null)&#123; // xxx&#125; 引用值 自定义、非数组、非函数-&gt;使用obj instanceof constructor 12345678function People(name)&#123; this.name=name;&#125;var p=new People();console.log(p instanceof People);// truevar date=new Date();console.log(date instanceof Date);// true 函数-&gt;typeof 12function fn()&#123;&#125;console.log(typeof fn==='function');// 'function' 数组 es5的isArray 12var arr=[];console.log(Array.isArray(arr));// true Object.prototype.call(arr); 12var arr=[];console.log(Object.prototype.toString.call(arr)==='[object Array]'); 存在性 常用检测存在性的不足 12345var obj=&#123; b:0&#125;;if(b)&#123;&#125;// 如果b存在，则xxx；当b为\"\",0,NaN,false,null,undefined时，就无法检测；同理b&amp;&amp;b()也会出现类似问题，所以只有在明确知道要检测的值不会是\"\",0,NaN,false,null,undefined中的一种时才能用 变量是否存在(是否已经声明) 全局变量的存在性 1console.log('a' in window);// false;判断变量a在全局环境下是否声明 局部变量的存在性 局部变量无法用in判断，只能退而求其次用typeof，typeof无法准确判断出是未声明还是已声明未赋值，如下123var a;console.log(typeof a==='undefined');// true;a已经声明但未赋值 console.log(typeof b==='undefined');// true;b没有声明 对象的属性是否存在 一般属性-&gt;统一使用in 实例属性存在性-&gt;统一使用hasOwnProperty IE8及以下判断实例属性存在性-&gt;先判断hasOwnProperty的存在性，再调用hasOwnProperty123456var obj_a=&#123; test:'测试'&#125;;console.log('test' in obj_a);// trueconsole.log('toString' in obj_a);// true，能检测到原型链上的方法console.log(obj_a.hasOwnProperty('toString'));//false,obj_a并没有实例属性(方法)`toString`，`toString`存在于其原型对象上，hasOwnProperty无法检测到","tags":[{"name":"类型检测","slug":"类型检测","permalink":"http://yoursite.com/tags/类型检测/"},{"name":"存在性","slug":"存在性","permalink":"http://yoursite.com/tags/存在性/"}]},{"title":"Vue-guide","date":"2017-08-01T02:35:14.000Z","path":"2017/08/01/Vue-guide/","text":"VueJs官网教程学习笔记安装 兼容性:不支持IE8及以下版本浏览器；因为使用了IE8无法模拟的Object.defineProperty 开发版本-&gt;包含了完整的警告和调试模式 CLI-&gt;可以构建一个完整的vue项目 介绍 是一套构建用户界面的框架，本身只关注视图层，但可以和第三方库结合来构建复杂的spa Vue实例 构造器 Vue(选项对象) 123var vm = new Vue(&#123; // 选项&#125;); 可扩展Vue构造器 12345var MyComponent = Vue.extend(&#123; // 扩展选项&#125;)// 所有的 `MyComponent` 实例都将以预定义的扩展选项被创建var myComponentInstance = new MyComponent() 属性与方法 每个vue实例会代理其data对象里有所有属性，这些属性都是响应式的； $开头的为vue实例属性/方法 不要在实例属性或者回调函数中使用箭头函数，箭头函数会绑定上级context，this预期将不会是vue实例 实例生命周期 生命周期钩子-&gt;自定义事件 可以在选项对象中进行配置 生命周期钩子中的this指向实例化后的对象12345678910var vm = new Vue(&#123; data: &#123; a: 1 &#125;, created: function () &#123; // `this` 指向 vm 实例 console.log('a is: ' + this.a) &#125;&#125;)// -&gt; \"a is: 1\" 模板语法插值 文本 绑定文本 v-text 会将对应表达式求值后，当做字符串替换元素内的内容 {{ msg }} msg 改变时，视图也会发生改变;是v-text的简写，求值后，当做字符串替换 {{ }}处的内容;{{ }}中可以使用表达式，但不能使用语句，流程控制也不能用(使用三元表达式代替) {{ }}形式会和ng中的一样，存在首次加载闪烁的问题，如果是首屏内容，可以尝试使用v-text绑定 一次性插值 在元素上使用v-once指令，这样元素内部的所有数据绑定，只会显示第一次绑定时的数据，当数据发生变化时，它们都不会得到更新，可以用在不会发生改变的数据的绑定；1&lt;span v-once&gt;This will never change: &#123;&#123; msg &#125;&#125;,&#123;&#123; test &#125;&#125;&lt;/span&gt; 纯html v-html {{ }}和v-text会将数据当做纯文本处理，不会对其做html解析;v-html会将对应表达表达式当做html解析后，输出到元素内 属性(特性) v-bind 主要用来绑定特性 v-bind:title=&quot;test&quot; 将test绑定到元素的title特性上； 缩写 v-bind:href=&quot;url&quot;-&gt;:href=&quot;url&quot; 指令 指令是v-开头(ng中以ng-开头)，它的预期是一个单一js表达式(v-for除外) 可以带参数 12&lt;a v-bind:href=\"url\"&gt;&lt;/a&gt;&lt;a v-on:click=\"doSomething\"&gt; 修饰符 指令后通过添加.来附加修饰符（Modifiers），用于指出一个指令应该以特殊方式绑定。1&lt;form v-on:submit.prevent=\"onSubmit\"&gt;&lt;/form&gt;// submit时阻止默认行为 过滤器 vue2.0中没有预定义的过滤器了，所有filter都需要自定义 主要用在{{ }}和v-bind中，达到格式化输出文本的作用 可级联使用 可带参数1234567891011121314151617181920//使用&lt;!-- in mustaches --&gt;&#123;&#123; message | capitalize &#125;&#125;&lt;!-- in v-bind --&gt;&lt;div v-bind:id=\"rawId | formatId\"&gt;&lt;/div&gt;// 定义new Vue(&#123; // ... filters: &#123; capitalize: function (value) &#123; if (!value) return '' value = value.toString() return value.charAt(0).toUpperCase() + value.slice(1) &#125; &#125;&#125;)// 级联使用&#123;&#123; message | filterA | filterB &#125;&#125;// 带参数&#123;&#123; message | filterA('arg1', arg2) &#125;&#125;// 这里，filterA 是个拥有三个参数的函数。message 的值将会作为第一个参数传入。字符串 'arg1' 将作为第二个参数传给 filterA，表达式 arg2 的值将作为第三个参数。 缩写 v-bind 1234&lt;!-- 完整语法 --&gt;&lt;a v-bind:href=\"url\"&gt;&lt;/a&gt;&lt;!-- 缩写 --&gt;&lt;a :href=\"url\"&gt;&lt;/a&gt; v-on 1234&lt;!-- 完整语法 --&gt;&lt;a v-on:click=\"doSomething\"&gt;&lt;/a&gt;&lt;!-- 缩写 --&gt;&lt;a @click=\"doSomething\"&gt;&lt;/a&gt; 计算属性计算属性 可以将计算属性当成data中属性添加了一个getter方法，并返回一个新属性，但新属性依赖data中的属性； 123456789101112131415// jsvar vm = new Vue(&#123; el: '#example', data: &#123; message: 'Hello' &#125;, computed: &#123; // a computed getter reversedMessage: function () &#123; // `this` 指向vm实例，由于vm实例代理了所有data中的属性，所以this.message能被访问到 return this.message.split('').reverse().join('') &#125; &#125;&#125;);// 当data中的message发生变化时，reversedMessage也会重新计算 计算属性vsMethods 1&lt;p&gt;Reversed message: \"&#123;&#123; reversedMessage() &#125;&#125;\"&lt;/p&gt; 123456methods: &#123; reversedMessage: function () &#123; return this.message.split('').reverse().join('') &#125;&#125;// 这样也能实现反转的效果 不同点 计算属性是基于它们的依赖进行缓存的；如上面计算属性的例子，只要data中的message没有发生变化，computed中的reversedMessage都不会重新计算，每次访问reversedMessage都将会是之前缓存的数据； methods则不存在缓存一说，如上面methods例子，只要`Reversed message: \"{{ reversedMessage() }}\"`需要重新渲染，reversedMessage就会被重新调用并计算一次 计算setter 计算属性默认只有getter，可以提供setter方法12345678910111213141516// ...computed: &#123; fullName: &#123; // getter get: function () &#123; return this.firstName + ' ' + this.lastName &#125;, // setter set: function (newValue) &#123; var names = newValue.split(' ') this.firstName = names[0] this.lastName = names[names.length - 1] &#125; &#125;&#125;// ... watch 主要用来观测数据的变化，并进行一系列的操作 1234567&lt;div id=\"watch-example\"&gt; &lt;p&gt; Ask a yes/no question: &lt;input v-model=\"question\"&gt; &lt;/p&gt; &lt;p&gt;&#123;&#123; answer &#125;&#125;&lt;/p&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!-- Since there is already a rich ecosystem of ajax libraries --&gt;&lt;!-- and collections of general-purpose utility methods, Vue core --&gt;&lt;!-- is able to remain small by not reinventing them. This also --&gt;&lt;!-- gives you the freedom to just use what you're familiar with. --&gt;&lt;script src=\"https://unpkg.com/axios@0.12.0/dist/axios.min.js\"&gt;&lt;/script&gt;&lt;script src=\"https://unpkg.com/lodash@4.13.1/lodash.min.js\"&gt;&lt;/script&gt;&lt;script&gt;var watchExampleVM = new Vue(&#123; el: '#watch-example', data: &#123; question: '', answer: 'I cannot give you an answer until you ask a question!' &#125;, watch: &#123; // 如果 question 发生改变，这个函数就会运行 question: function (newQuestion) &#123; this.answer = 'Waiting for you to stop typing...' this.getAnswer() &#125; &#125;, methods: &#123; // _.debounce 是一个通过 lodash 限制操作频率的函数。 // 在这个例子中，我们希望限制访问yesno.wtf/api的频率 // ajax请求直到用户输入完毕才会发出 // 学习更多关于 _.debounce function (and its cousin // _.throttle), 参考: https://lodash.com/docs#debounce getAnswer: _.debounce( function () &#123; if (this.question.indexOf('?') === -1) &#123; this.answer = 'Questions usually contain a question mark. ;-)' return &#125; this.answer = 'Thinking...' var vm = this axios.get('https://yesno.wtf/api') .then(function (response) &#123; vm.answer = _.capitalize(response.data.answer) &#125;) .catch(function (error) &#123; vm.answer = 'Error! Could not reach the API. ' + error &#125;) &#125;, // 这是我们为用户停止输入等待的毫秒数 500 ) &#125;&#125;)&lt;/script&gt; 什么时候用computed、methods、watch computed主要用在根据原有属性，进行计算，返回新属性的操作；即适合用在对数据(属性)的set和get上 methods主要用来编写一些通用，没有什么依赖的方法。 watch主要用来观测数据(属性)的变化，当变化时进行一系列操作（异步操作或开销较大的操作） 总结 computed适合用来对数据进行set、get watch适合用来在数据变化时，进行大开销的操作 methods 用来编写通用的方法 Class与Style绑定绑定 HTML Class类似ng-class 对象语法 传一个对象，以动态切换class 1&lt;div v-bind:class=\"&#123; active: isActive &#125;\"&gt;&lt;/div&gt;// isActive为true时，则添加active样式类，为false则去除 可以传多个属性，进行动态切换class；并v-bind:class可以和普通class属性共存 123&lt;div class=\"static\" v-bind:class=\"&#123; active: isActive, 'text-danger': hasError &#125;\"&gt;&lt;/div&gt; 可以直接绑定data里的一个对象 12345678&lt;div v-bind:class=\"classObject\"&gt;&lt;/div&gt;// jsdata: &#123; classObject: &#123; active: true, 'text-danger': false &#125;&#125; 也可以绑定一个computed里的对象 1234567891011121314&lt;div v-bind:class=\"classObject\"&gt;&lt;/div&gt;// jsdata: &#123; isActive: true, error: null&#125;,computed: &#123; classObject: function () &#123; return &#123; active: this.isActive &amp;&amp; !this.error, 'text-danger': this.error &amp;&amp; this.error.type === 'fatal', &#125; &#125;&#125; 数组语法 可以把数组传递给v-bind:class，以应用一个class列表 123456&lt;div v-bind:class=\"[activeClass, errorClass]\"&gt;// jsdata: &#123; activeClass: 'active', errorClass: 'text-danger'&#125; 可以在数组中使用条件表达式 1&lt;div v-bind:class=\"[isActive ? activeClass : '', errorClass]\"&gt; 可以在数组中使用对象语法 1&lt;div v-bind:class=\"[&#123; active: isActive &#125;, errorClass]\"&gt; 绑定内联样式类似ng-style 对象语法 直接绑定一个对象，CSS属性名用驼峰式(camelCase) 123456&lt;div v-bind:style=\"&#123; color: activeColor, fontSize: fontSize + 'px' &#125;\"&gt;&lt;/div&gt;// jsdata: &#123; activeColor: 'red', fontSize: 30&#125; 数组语法 v-bind:style 的数组语法可以将多个样式对象应用到一个元素上1&lt;div v-bind:style=\"[baseStyles, overridingStyles]\"&gt; 多重值 从 2.3.0 起你可以为 style 绑定中的属性提供一个包含多个值的数组，常用于提供多个带前缀的值1&lt;div :style=\"&#123; display: ['-webkit-box', '-ms-flexbox', 'flex'] &#125;\"&gt; 条件渲染类似ng-if v-if 条件为true时，则渲染，将元素添加到DOM中，为false，则将其从dom中删除 1&lt;h1 v-if=\"ok\"&gt;Yes&lt;/h1&gt; 条件渲染一组 可以将需要条件渲染的元素放到&lt;template&gt;元素中，然后用v-if条件渲染12345&lt;template v-if=\"ok\"&gt; &lt;h1&gt;Title&lt;/h1&gt; &lt;p&gt;Paragraph 1&lt;/p&gt; &lt;p&gt;Paragraph 2&lt;/p&gt;&lt;/template&gt; v-else 可以使用v-else指令来表示v-if的”else块” 123456&lt;div v-if=\"Math.random() &gt; 0.5\"&gt; Now you see me&lt;/div&gt;&lt;div v-else&gt; Now you don't&lt;/div&gt; v-else元素必须紧跟在v-if或者v-else-if元素的后面——否则它将不会被识别 v-else-if 充当”else if块”；可链式调用 123456789101112&lt;div v-if=\"type === 'A'\"&gt; A&lt;/div&gt;&lt;div v-else-if=\"type === 'B'\"&gt; B&lt;/div&gt;&lt;div v-else-if=\"type === 'C'\"&gt; C&lt;/div&gt;&lt;div v-else&gt; Not A/B/C&lt;/div&gt; 类似于 v-else，v-else-if 必须紧跟在 v-if 或者 v-else-if 元素之后 用 key 管理可复用的元素 默认情况下，vue会尽可能的高效渲染元素，通常会复用已有元素而不是从头开始渲染。 123456789&lt;template v-if=\"loginType === 'username'\"&gt; &lt;label&gt;Username&lt;/label&gt; &lt;input placeholder=\"Enter your username\"&gt;&lt;/template&gt;&lt;template v-else&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input placeholder=\"Enter your email address\"&gt;&lt;/template&gt;// 这里的input会被复用，并不会因为if和else而渲染两个，只是改变placeholder，这样效率更高 有时，我们就是需要渲染两个，这是就需要使用key；如上面例子，为这两个input分别添加一个唯一的key值时，切换时，vue就不会复用他们，而是重新渲染一个 123456789&lt;template v-if=\"loginType === 'username'\"&gt; &lt;label&gt;Username&lt;/label&gt; &lt;input placeholder=\"Enter your username\" key=\"username-input\"&gt;&lt;/template&gt;&lt;template v-else&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input placeholder=\"Enter your email address\" key=\"email-input\"&gt;&lt;/template&gt;// 注意, &lt;label&gt; 元素仍然会被高效地复用，因为它们没有添加 key 属性。 v-show 通过切换元素的display属性，元素会一直保留在DOM中，并不会因为为false，就把元素从DOM中删除，这点和v-if不同 v-if和v-show v-if是通过增加、删除元素来达到显示/隐藏 v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。 v-show通过css切换(display属性)来显示/隐藏 v-show不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。 一般来说， v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件不太可能改变，则使用 v-if 较好。 v-if和v-for一起使用 v-for 具有比 v-if 更高的优先级；先循环，再判断显示隐藏 列表渲染v-for 数组迭代 12345678910111213141516&lt;ul id=\"example-2\"&gt; &lt;li v-for=\"(item, index) in items\"&gt; &#123;&#123; parentMessage &#125;&#125; - &#123;&#123; index &#125;&#125; - &#123;&#123; item.message &#125;&#125; &lt;/li&gt;&lt;/ul&gt;// jsvar example2 = new Vue(&#123; el: '#example-2', data: &#123; parentMessage: 'Parent', items: [ &#123; message: 'Foo' &#125;, &#123; message: 'Bar' &#125; ] &#125;&#125;); 渲染多个元素块-&gt;使用&lt;template&gt;包裹 123456&lt;ul&gt; &lt;template v-for=\"item in items\"&gt; &lt;li&gt;&#123;&#123; item.msg &#125;&#125;&lt;/li&gt; &lt;li class=\"divider\"&gt;&lt;/li&gt; &lt;/template&gt;&lt;/ul&gt; 对象迭代 在遍历对象时，是按 Object.keys() 的结果遍历，但是不能保证它的结果在不同的 JavaScript 引擎下是一致的。1234567891011121314&lt;div v-for=\"(value, key, index) in object\"&gt; &#123;&#123; index &#125;&#125;. &#123;&#123; key &#125;&#125; : &#123;&#123; value &#125;&#125;&lt;/div&gt;// jsnew Vue(&#123; el: '#repeat-object', data: &#123; object: &#123; firstName: 'John', lastName: 'Doe', age: 30 &#125; &#125;&#125;); 整数迭代 1234&lt;div&gt; &lt;!-- span会重复10次 --&gt; &lt;span v-for=\"n in 10\"&gt;&#123;&#123; n &#125;&#125; &lt;/span&gt;&lt;/div&gt; v-for和v-if 当它们处于同一节点， v-for 的优先级比 v-if 更高，这意味着 v-if 将分别重复运行于每个 v-for 循环中。相当于在for循环中，再用if判断； 123&lt;li v-for=\"todo in todos\" v-if=\"!todo.isComplete\"&gt; &#123;&#123; todo &#125;&#125;&lt;/li&gt; 如果想条件判断了再循环，可以先if再for 12345&lt;ul v-if=\"shouldRenderTodos\"&gt; &lt;li v-for=\"todo in todos\"&gt; &#123;&#123; todo &#125;&#125; &lt;/li&gt;&lt;/ul&gt; key vue默认会采取”就地复用”的策略,如果数据项的顺序被改变，Vue将不是移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性。123&lt;div v-for=\"item in items\" :key=\"item.id\"&gt; &lt;!-- 内容 --&gt;&lt;/div&gt; 建议尽可能使用 v-for 来提供 key ，除非迭代 DOM 内容足够简单，或者你是故意要依赖于默认行为来获得性能提升。因为它是 Vue 识别节点的一个通用机制， key 并不特别与 v-for 关联，key 还具有其他用途，我们将在后面的指南中看到其他用途。 数组更新检测 变异方法 会改变原数组的方法都为变异方法push()、pop()、shift()、unshift()、splice()、sort()、reverse()；所有变异方法(会改变原数组的方法)都会触发更新检测,若发现数组有变化，则会更新依赖它的地方 重塑数组 不会改变原数组的方法为非变异方法，非变异方法会返回一个新的数组；filter(), concat(), slice()都是非变异方法；当使用新返回的数组替换原先的数组时(重塑数组)，不用担心vue会丢弃现有DOM重新渲染，vue会智能的复用DOM元素，123example1.items = example1.items.filter(function (item) &#123; return item.message.match(/Foo/)&#125;); 注意 由于js的限制，vue不能检测下面变动的数组，将不会触发更新 当你利用索引直接设置一个项时，例如： vm.items[indexOfItem] = newValue 当你修改数组的长度时，例如： vm.items.length = newLength 解决方法 第一种问题，可以使用Vue.set或者splice方法 1234// Vue.setVue.set(example1.items, indexOfItem, newValue)// splice方法example1.items.splice(indexOfItem, 1, newValue) 第二种问题可以使用splice 1example1.items.splice(newLength) 显示过滤/排序结果 我们想要显示一个数组的过滤或排序副本，而不实际改变或重置原始数据。在这种情况下，可以创建返回过滤或排序数组的计算属性。123456789101112&lt;li v-for=\"n in evenNumbers\"&gt;&#123;&#123; n &#125;&#125;&lt;/li&gt;// jsdata: &#123; numbers: [ 1, 2, 3, 4, 5 ]&#125;,computed: &#123; evenNumbers: function () &#123; return this.numbers.filter(function (number) &#123; return number % 2 === 0 &#125;) &#125;&#125; 事件处理器监听事件 v-on 使用v-on监听事件 1234&lt;div id=\"example-1\"&gt; &lt;button v-on:click=\"counter += 1\"&gt;增加 1&lt;/button&gt; &lt;p&gt;这个按钮被点击了 &#123;&#123; counter &#125;&#125; 次。&lt;/p&gt;&lt;/div&gt; 缩写 v-on:click=&quot;xxx&quot;-&gt;@click=&quot;xxx&quot; 方法事件处理器 为事件指定一个处理函数123456789101112131415161718192021222324&lt;div id=\"example-2\"&gt; &lt;!-- `greet` 是在下面定义的方法名 --&gt; &lt;button v-on:click=\"greet\"&gt;Greet&lt;/button&gt;&lt;/div&gt;// jsvar example2 = new Vue(&#123; el: '#example-2', data: &#123; name: 'Vue.js' &#125;, // 在 `methods` 对象中定义方法 methods: &#123; greet: function (event) &#123; // `this` 在方法里指当前 Vue 实例 alert('Hello ' + this.name + '!') // `event` 是原生 DOM 事件 if (event) &#123; alert(event.target.tagName) &#125; &#125; &#125;&#125;)// 也可以用 JavaScript 直接调用方法example2.greet() // -&gt; 'Hello Vue.js!' 内联处理器方法 直接将处理逻辑写在v-on:click=之后 1234&lt;div id=\"example-3\"&gt; &lt;button v-on:click=\"say('hi')\"&gt;Say hi&lt;/button&gt; &lt;button v-on:click=\"say('what')\"&gt;Say what&lt;/button&gt;&lt;/div&gt; 传递event给内联处理器需要使用$event 1234567891011&lt;button v-on:click=\"warn('Form cannot be submitted yet.', $event)\"&gt; Submit&lt;/button&gt;// jsmethods: &#123; warn: function (message, event) &#123; // 现在我们可以访问原生事件对象 if (event) event.preventDefault() alert(message) &#125;&#125; 事件修饰符 事件中经常需要调用event.preventDefault() 或 event.stopPropagation()，为了简化操作，也为了让处理函数中只有业务逻辑没有事件相关细节，所以vue在v-on:上添加修饰符 .stop,.prevent,.capture,.self,.once 1234567891011121314&lt;!-- 阻止单击事件冒泡 --&gt;&lt;a v-on:click.stop=\"doThis\"&gt;&lt;/a&gt;&lt;!-- 提交事件不再重载页面 --&gt;&lt;form v-on:submit.prevent=\"onSubmit\"&gt;&lt;/form&gt;&lt;!-- 修饰符可以串联 --&gt;&lt;a v-on:click.stop.prevent=\"doThat\"&gt;&lt;/a&gt;&lt;!-- 只有修饰符 --&gt;&lt;form v-on:submit.prevent&gt;&lt;/form&gt;&lt;!-- 添加事件侦听器时使用事件捕获模式 --&gt;&lt;div v-on:click.capture=\"doThis\"&gt;...&lt;/div&gt;&lt;!-- 只当事件在该元素本身（比如不是子元素）触发时触发回调 --&gt;&lt;div v-on:click.self=\"doThat\"&gt;...&lt;/div&gt;&lt;!-- 点击事件将只会触发一次 --&gt;&lt;a v-on:click.once=\"doThis\"&gt;&lt;/a&gt; 使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 @click.prevent.self 会阻止所有的点击，而 @click.self.prevent 只会阻止元素上的点击。 键值修饰符 Vue 允许为 v-on 在监听键盘事件时添加关键修饰符 123456&lt;!-- 只有在 keyCode 是 13 时调用 vm.submit() --&gt;&lt;input v-on:keyup.13=\"submit\"&gt;&lt;!-- 同上 --&gt;&lt;input v-on:keyup.enter=\"submit\"&gt;&lt;!-- 缩写语法 --&gt;&lt;input @keyup.enter=\"submit\"&gt; 按键别名 .enter,.tab,.delete(捕获“删除”和“退格”键),.esc,.space,.up,.down,.left,.right 可以通过全局 config.keyCodes 对象自定义键值修饰符别名12// 可以使用 v-on:keyup.f1Vue.config.keyCodes.f1 = 112 修饰键 .ctrl,.alt,.shift,.meta 1234&lt;!-- Alt + C --&gt;&lt;input @keyup.alt.67=\"clear\"&gt;&lt;!-- Ctrl + Click --&gt;&lt;div @click.ctrl=\"doSomething\"&gt;Do something&lt;/div&gt; 滑鼠按键修饰符 .left,.right,.middle 表单控件绑定基础用法 v-model v-model可以实现表单控件的双向绑定；它会根据控件类型自动选取正确的方法来更新元素；类似ng-model v-model会忽略所有表单元素的value、checked、selected特性的初始值。因为它会选择Vue实例数据来作为具体的值。应该通过data选项声明初始值。 v-model在中文输入(IME)时不会更新，可以监听input事件 简单的表单 12345678&lt;!-- 文本 --&gt;&lt;input v-model=\"message\" placeholder=\"edit me\"&gt;&lt;p&gt;Message is: &#123;&#123; message &#125;&#125;&lt;/p&gt;&lt;!-- 多行文本 --&gt;&lt;span&gt;Multiline message is:&lt;/span&gt;&lt;p style=\"white-space: pre-line\"&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;&lt;br&gt;&lt;textarea v-model=\"message\" placeholder=\"add multiple lines\"&gt;&lt;/textarea&gt;&lt;!-- 在文本区域插值( &lt;textarea&gt;&lt;/textarea&gt; ) 并不会生效，应用 v-model 来代替 --&gt; 复选框 单个复选框，逻辑值 12&lt;input type=\"checkbox\" id=\"checkbox\" v-model=\"checked\"&gt;&lt;label for=\"checkbox\"&gt;&#123;&#123; checked &#125;&#125;&lt;/label&gt; 多个复选框，v-model需要绑定到同一个数组上 123456789101112131415&lt;input type=\"checkbox\" id=\"jack\" value=\"Jack\" v-model=\"checkedNames\"&gt;&lt;label for=\"jack\"&gt;Jack&lt;/label&gt;&lt;input type=\"checkbox\" id=\"john\" value=\"John\" v-model=\"checkedNames\"&gt;&lt;label for=\"john\"&gt;John&lt;/label&gt;&lt;input type=\"checkbox\" id=\"mike\" value=\"Mike\" v-model=\"checkedNames\"&gt;&lt;label for=\"mike\"&gt;Mike&lt;/label&gt;&lt;br&gt;&lt;span&gt;Checked names: &#123;&#123; checkedNames &#125;&#125;&lt;/span&gt;// jsnew Vue(&#123; el: '...', data: &#123; checkedNames: [] &#125;&#125;); 单选按钮 同一组，v-model需要绑定到同一个数组上12345678910111213141516&lt;div id=\"example-4\"&gt; &lt;input type=\"radio\" id=\"one\" value=\"One\" v-model=\"picked\"&gt; &lt;label for=\"one\"&gt;One&lt;/label&gt; &lt;br&gt; &lt;input type=\"radio\" id=\"two\" value=\"Two\" v-model=\"picked\"&gt; &lt;label for=\"two\"&gt;Two&lt;/label&gt; &lt;br&gt; &lt;span&gt;Picked: &#123;&#123; picked &#125;&#125;&lt;/span&gt;&lt;/div&gt;// jsnew Vue(&#123; el: '#example-4', data: &#123; picked: '' &#125;&#125;); select 单选 12345678910&lt;div id=\"example-5\"&gt; &lt;select v-model=\"selected\"&gt; &lt;option disabled value=\"\"&gt;请选择&lt;/option&gt; &lt;option&gt;A&lt;/option&gt; &lt;option&gt;B&lt;/option&gt; &lt;option&gt;C&lt;/option&gt; &lt;/select&gt; &lt;span&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/span&gt;&lt;/div&gt;// 如果 v-model 表达初始的值不匹配任何的选项，&lt;select&gt; 元素就会以”未选中”的状态渲染。在 iOS 中，这会使用户无法选择第一个选项，因为这样的情况下，iOS 不会引发 change 事件。因此，像以上提供 disabled 选项是建议的做法。 多选列表（绑定到一个数组） 12345678910111213141516&lt;div id=\"example-6\"&gt; &lt;select v-model=\"selected\" multiple style=\"width: 50px\"&gt; &lt;option&gt;A&lt;/option&gt; &lt;option&gt;B&lt;/option&gt; &lt;option&gt;C&lt;/option&gt; &lt;/select&gt; &lt;br&gt; &lt;span&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/span&gt;&lt;/div&gt;// jsnew Vue(&#123; el: '#example-6', data: &#123; selected: [] &#125;&#125;); 动态选项(使用v-for渲染) 123456789101112131415161718&lt;select v-model=\"selected\"&gt; &lt;option v-for=\"option in options\" v-bind:value=\"option.value\"&gt; &#123;&#123; option.text &#125;&#125; &lt;/option&gt;&lt;/select&gt;&lt;span&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/span&gt;// jsnew Vue(&#123; el: '...', data: &#123; selected: 'A', options: [ &#123; text: 'One', value: 'A' &#125;, &#123; text: 'Two', value: 'B' &#125;, &#123; text: 'Three', value: 'C' &#125; ] &#125;&#125;); 绑定value 对于单选按钮，勾选框及选择列表选项， v-model 绑定的 value 通常是静态字符串（对于勾选框是逻辑值）;但有时我们想绑定value到Vue实例的一个动态属性上 复选框 123456&lt;input type=\"checkbox\" v-model=\"toggle\" v-bind:true-value=\"a\" v-bind:false-value=\"b\"&gt;// 当选中时vm.toggle === vm.a// 当没有选中时vm.toggle === vm.b 单选按钮 123&lt;input type=\"radio\" v-model=\"pick\" v-bind:value=\"a\"&gt;// 当选中时vm.pick === vm.a select 1234567&lt;select v-model=\"selected\"&gt; &lt;!-- 内联对象字面量 --&gt; &lt;option v-bind:value=\"&#123; number: 123 &#125;\"&gt;123&lt;/option&gt;&lt;/select&gt;// 当选中时typeof vm.selected // -&gt; 'object'vm.selected.number // -&gt; 123 v-model的修饰符 .lazy在默认情况下， v-model 在 input 事件中同步输入框的值与数据 (除了 上述 IME 部分)，但你可以添加一个修饰符 lazy ，从而转变为在 change 事件中同步 12&lt;!-- 在 \"change\" 而不是 \"input\" 事件中更新 --&gt;&lt;input v-model.lazy=\"msg\" &gt; .number如果想自动将用户的输入值转为 Number 类型（如果原值的转换结果为 NaN 则返回原值），可以添加一个修饰符 number 给 v-model 来处理输入值 1&lt;input v-model.number=\"age\" type=\"number\"&gt; .trim如果要自动过滤用户输入的首尾空格，可以添加 trim 修饰符到 v-model 上过滤输入 1&lt;input v-model.trim=\"msg\"&gt; 组件vue中的组件很类似ng1中的directive，通过自定义的html元素扩展功能 使用组件 注册 全局注册 123456789101112131415161718// Vue.component('组件名',选项对象 );// 选项对象和new Vue()中的几乎一样，只有个别属性使用不一样；//组件名建议使用kebab-case(短横线隔开式)连接，不要使用camelCased(驼峰式)，因为html特性不区分大小写，类似ng1中的directive命名，为方便，同意使用kebab-case形式// Vue.component()；不存在类似函数的声明提升机制，所以全局组件必须在根实例之前注册&lt;div id=\"example\"&gt; &lt;my-component&gt;&lt;/my-component&gt;&lt;/div&gt;// 注册-&gt;在创建根实例之前注册Vue.component('my-component', &#123; template: '&lt;div&gt;A custom component!&lt;/div&gt;' // template必须只有一个跟节点，类似ng1&#125;)// 创建根实例new Vue(&#123; el: '#example'&#125;);// 渲染为&lt;div id=\"example\"&gt; &lt;div&gt;A custom component!&lt;/div&gt; // vue中自定义元素将直接被替换，类似ng1中定义指令时配置了replace:true&lt;/div&gt; 局部注册 通过使用组件选项对象中的components来注册，让其仅在一个实例/组件的作用域中可用12345678910var Child = &#123; template: '&lt;div&gt;A custom component!&lt;/div&gt;'&#125;;new Vue(&#123; el:'#test', components: &#123; // &lt;my-component&gt; 将只在父模板可用(#test实例的范围中使用) 'my-component': Child &#125;&#125;); is 在现有html上添加功能，类似ng1指令中的restrict:A-&gt;因为html的限制，某些标签下只能出现特定的标签，出现其他标签视为无效，如select下只能是option；所以变通的方法是采用is特性 12345678// 无效&lt;table&gt; &lt;my-row&gt;...&lt;/my-row&gt;&lt;/table&gt;// 有效&lt;table&gt; &lt;tr is=\"my-row\"&gt;&lt;/tr&gt;&lt;/table&gt; 下来源之一的字符串模板，此限制将不适用： &lt;script type=&quot;text/x-template&quot;&gt; JavaScript 内联模版字符串 .vue组件 data必须是函数 通过 Vue 构造器传入的各种选项大多数都可以在组件里用。data是一个例外，它必须是函数，若不是函数，Vue将发出警告 如果通过data函数返回一个对象(引用值)，那么注册的所有组件都将共用这个对象1234567891011121314151617&lt;div id=\"example-2\"&gt; &lt;simple-counter&gt;&lt;/simple-counter&gt; &lt;simple-counter&gt;&lt;/simple-counter&gt; &lt;simple-counter&gt;&lt;/simple-counter&gt;&lt;/div&gt;var data = &#123; counter: 0 &#125;;Vue.component('simple-counter', &#123; template: '&lt;button v-on:click=\"counter += 1\"&gt;&#123;&#123; counter &#125;&#125;&lt;/button&gt;', // 技术上 data 的确是一个函数了，因此 Vue 不会警告， // 但是我们返回给每个组件的实例的却引用了同一个data对象 data: function () &#123; return data &#125;&#125;);new Vue(&#123; el: '#example-2'&#125;); 父子组件如何通信 props down, events up; 父组件通过子组件的props接口，将数据传递给子组件；子组件通过事件的形式给父组件发送消息 proprs 组件期望获得的数据，有点类似ng1指令中的scope属性 123456789Vue.component('child', &#123; // 声明 props props: ['message'], // 就像 data 一样，prop 可以用在模板内 // 同样也可以在 vm 实例中像“this.message”这样使用 template: '&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;'&#125;);// 通过child组件的message接口将数据传入&lt;child message=\"hello!\"&gt;&lt;/child&gt; 动态prop 在模板中，要动态地绑定父组件的数据到子模板的 props，与绑定到任何普通的HTML特性相类似，就是用 v-bind。每当父组件的数据变化时，该变化也会传导给子组件 12345&lt;div&gt; &lt;input v-model=\"parentMsg\"&gt; &lt;br&gt; &lt;child v-bind:my-message=\"parentMsg\"&gt;&lt;/child&gt;&lt;/div&gt; 用v-bind绑定的数据发生发生变化时，会将变化传导到子组件 123456789101112131415161718192021222324&lt;div id=\"app\"&gt; &lt;child message='纯文本'&gt;&lt;/child&gt; &lt;child message='test1'&gt;&lt;/child&gt; &lt;child message='test2'&gt;&lt;/child&gt; &lt;child v-bind:message='test2'&gt;&lt;/child&gt;&lt;/div&gt;&lt;button&gt;点击&lt;/button&gt;var vm = new Vue(&#123; el: '#app', data: &#123; test1: '我是变量1', test2: '我是变量2' &#125;, components: &#123; 'child': &#123; props: ['message'], template: '&lt;h1&gt;&#123;&#123;message&#125;&#125;&lt;/h1&gt;' &#125; &#125;&#125;);document.querySelector('button').onclick = function() &#123; vm.test2 = '我是变量2，我被改变了'; console.log(vm);&#125;; 不要使用字面量形式传递数值，使用v-bind将其转化成表达式；下面例子，因为它是一个字面 prop，它的值是字符串 “1” 而不是 number。如果想传递一个实际的 number，需要使用 v-bind，从而让它的值被当作 JavaScript 表达式计算 1234&lt;!-- 传递了一个字符串 \"1\" --&gt;&lt;comp some-prop=\"1\"&gt;&lt;/comp&gt;&lt;!-- 传递实际的 number --&gt;&lt;comp v-bind:some-prop=\"1\"&gt;&lt;/comp&gt; 单向数据流 prop是单向的，只能父传递到子，反之则不行 父组件更新时，子组件的所有prop也将得到更新 遇到下面情况，可能需要修改prop中的数据 prop 作为初始值传入后，子组件想把它当作局部数据来用 解决方法 定义一个局部变量，并用 prop 的值初始化它1234props: ['initialCounter'],data: function () &#123; return &#123; counter: this.initialCounter &#125;&#125; prop 作为初始值传入，由子组件处理成其它数据输出 解决方法 定义一个计算属性，处理 prop 的值并返回123456props: ['size'],computed: &#123; normalizedSize: function () &#123; return this.size.trim().toLowerCase() &#125;&#125; 注意在 JavaScript 中对象和数组是引用类型，指向同一个内存空间，如果 prop 是一个对象或数组，在子组件内部改变它会影响父组件的状态。 prop验证 有时需要对传入组件的数据先进行验证再操作 12345678910111213141516171819202122232425262728293031Vue.component('example', &#123; props: &#123; // 基础类型检测 (`null` 意思是任何类型都可以) propA: Number, // 多种类型 propB: [String, Number], // 必传且是字符串 propC: &#123; type: String, required: true &#125;, // 数字，有默认值 propD: &#123; type: Number, default: 100 &#125;, // 数组/对象的默认值应当由一个工厂函数返回 propE: &#123; type: Object,// 注意是构造器，并不是字符串 default: function () &#123; return &#123; message: 'hello' &#125; &#125; &#125;, // 自定义验证函数 propF: &#123; validator: function (value) &#123; return value &gt; 10 &#125; &#125; &#125;&#125;); 验证时的type可以是:String、Number、Boolean、Function、Object、Array、Symbol 注意是构造器，不是字符串1234// 这样是错误的type:'Boolean'// 这样是对的type:Boolean 当 prop 验证失败，Vue 会在抛出警告 (如果使用的是开发版本)。注意 props 会在组件实例创建之前进行校验，所以在 default 或 validator 函数里，诸如 data、computed 或 methods 等实例属性还无法使用。 非Prop属性 所谓非 prop 属性，就是它可以直接传入组件，而不需要定义相应的 prop。 明确给组件定义 prop 是传参的推荐方式 非prop属性，将会被自动添加到模板的根元素上 123456&lt;!-- 有个非prop属性，data-3d-data-picker --&gt;&lt;bs-date-input data-3d-date-picker=\"true\"&gt;&lt;/bs-date-input&gt;&lt;!-- bs-data-input的模板 --&gt;&lt;input type=\"date\" class=\"form-control\"&gt;&lt;!-- 渲染后 --&gt;&lt;input type=\"date\" class=\"form-control\" data-3d-date-picker=\"true\"&gt; 替换/覆盖现有的特性 默认情况下，在发生特性冲突时，会采取覆盖策略，传递给组件的值会覆盖组件本身设定的值。即例如传递 type=”large” 将会覆盖 type=”date” class和style特性，在发生冲突时，会采取合并策略，而不是覆盖策略12345&lt;bs-date-input type=\"num\" data-3d-date-picker=\"true\" class=\"date-picker-theme-dark\"&gt;&lt;/bs-date-input&gt;&lt;!-- 模板 --&gt;&lt;input type=\"date\" class=\"form-control\"&gt;&lt;!-- 渲染后，传进来的type覆盖了原先的type，class实现了合并 --&gt;&lt;input type=\"num\" class=\"form-control date-picker-theme-dark\" data-3d-date-picker=\"true\"&gt; 自定义事件 可以通过props向子组件传递数据，子组件可以通过自定义事件向父组件发消息 每个vue实例都实现了事件接口 vm.$on(eventName)监听事件 vm.$emit(eventName)触发事件 父组件可以在使用子组件的地方直接用v-on来监听子组件触发的自定义事件，注意在子组件的自定义标签上直接使用v-on只能绑定子组件主动分发(通过$emit触发)的事件，这是一种特殊写法,告诉父组件要监听某个自定义事件。如果想直接使用v-on为子组件绑定事件，将无法触发；例子见下一小节 不能用 $on 侦听子组件抛出的事件，而必须在模板里直接用 v-on 绑定 12345678910111213141516171819202122232425262728293031323334353637&lt;div id=\"counter-event-example\"&gt; &lt;p&gt;&#123;&#123; total &#125;&#125;&lt;/p&gt; &lt;!-- 这里的v-on:increment=\"incrementTotal\"，其实在告诉父组件(这里是根实例)要监听increment事件了 --&gt; &lt;button-counter v-on:increment=\"incrementTotal\"&gt;&lt;/button-counter&gt; &lt;button-counter v-on:increment=\"incrementTotal\"&gt;&lt;/button-counter&gt;&lt;/div&gt;// jsVue.component('button-counter', &#123; template: '&lt;button v-on:click=\"incrementCounter\"&gt;&#123;&#123; counter &#125;&#125;&lt;/button&gt;', data: function () &#123; return &#123; counter: 0 &#125; &#125;, methods: &#123; incrementCounter: function () &#123; this.counter += 1; this.$emit('increment');// 分发'increment'自定义事件 &#125; &#125;,&#125;);new Vue(&#123; el: '#counter-event-example', data: &#123; total: 0 &#125;, methods: &#123; incrementTotal: function () &#123;// 接收到子组件分发'increment'自定义事件后触发 this.total += 1 &#125; &#125;&#125;);// 在v1版本中，子组件分发的自定义事件的触发函数是写在父组件的events中;// 这样写，有个不好的地方就是父组件不知道这个事件到底是哪个子组件分发的，如果多个子组件分发了同个自定义事件，就无法分辨。// 所以作者为了清晰的知道具体是哪个组件分发了事件，就将v-on移到了子组件的自定义标签上// https://v1.vuejs.org/guide/components.html#Custom-Events// https://segmentfault.com/q/1010000004486740/a-1020000004487413 给组件绑定原生事件 有时候，你可能想在某个组件的根元素上监听一个原生事件。 注意：在子组件的自定义标签上直接使用v-on:mouseenter，这种事件是无法直接触发的(只有子组件主动$emit了mouseenter事件，才会触发)，在子组件上直接使用v-on绑定的只能是子组件主动分发的事件，它是在告诉父组件要监听某个自定义事件，是一种特殊写法； 想为某个组件绑定一个原生事件(在某个组件的根元素上监听一个原生事件)，必须在自定义标签上使用v-on:事件.native=xxx 1234&lt;!-- 这个mouseenter绑定的回调无法触发，除非子组件主动$emit了mouseenter，count才会被调用 --&gt;&lt;button-counter v-on:child_increment=\"incrementTotal\" v-on:mouseenter=\"count\"&gt;&lt;/button-counter&gt;&lt;!-- v-on:mouseenter.native这种写法，给button-counter的根标签绑定了一个原生mouseenter事件，鼠标移入，就会触发count --&gt;&lt;button-counter v-on:child_increment=\"incrementTotal\" v-on:mouseenter.native=\"count\"&gt;&lt;/button-counter&gt; 小结 子组件的自定义标签上直接使用v-on只适合子组件发消息给父组件这种情况，并且需要子组件主动$emit配合，经过这两步才能完成子组件给父组发消息，具体步骤如下 子组件的自定义标签上直接使用v-on:子组件主动分发的事件名=xxx 子组件在条件合适时主动$emit(事件名) 想在子组件自定义标签上直接使用v-on给组件根元素绑定事件，必须添加.native修饰符 双向绑定.sync 当一个子组件改变了一个 prop 的值时，这个变化也会同步到父组件中所绑定的值。123456&lt;comp :foo.sync=\"bar\"&gt;&lt;/comp&gt;&lt;!-- 本质为下面的 --&gt;&lt;comp :foo=\"bar\" @update:foo=\"val =&gt; bar = val\"&gt;&lt;/comp&gt;&lt;!-- 子组件值变化时，主动触发update事件 --&gt;this.$emit('update:foo', newValue)&lt;!-- 其实这里的.sync也佐证了自定义标签上直接使用v-on绑定的事件，需要配合$emit才能触发 --&gt; v-model v-model常用来针对表单实行双向数据绑定，它的本质是个语法糖；value属性+input事件 123&lt;input v-model=\"something\"&gt;&lt;!-- 本质如下 --&gt;&lt;input v-bind:value=\"something\" v-on:input=\"something = $event.target.value\"&gt; 创建自定义input组件时 12345678910111213141516171819202122232425262728293031323334353637&lt;!-- 下面2种效果一样 --&gt;&lt;currency-input v-model=\"price\"&gt;&lt;/currency-input&gt;&lt;currency-input v-bind:value=\"price\" v-on:input=\"price = arguments[0]\"&gt;&lt;/currency-input&gt;Vue.component('currency-input', &#123; template: '&lt;span&gt;$&lt;input ref=\"input\" v-bind:value=\"value\" v-on:input=\"updateValue($event.target.value)\"&gt;&lt;/span&gt;', props: &#123; value: Number &#125;, methods: &#123; // 不是直接更新值，而是使用此方法来对输入值进行格式化和位数限制 updateValue: function(value) &#123; var formattedValue = value // 删除两侧的空格符 .trim() // 保留 2 小数位 .slice( 0, value.indexOf('.') === -1 ? value.length : value.indexOf('.') + 3 ) // 如果值不统一，手动覆盖以保持一致 if (formattedValue !== value) &#123; this.$refs.input.value = formattedValue &#125; // 通过 input 事件发出数值 this.$emit('input', Number(formattedValue)) &#125; &#125;&#125;);var vm = new Vue(&#123; el: '#app', data: &#123; price: 3 &#125;&#125;); 定制v-model 从上节可知，v-model需要使用到表单的value属性和input事件，但单选、复选之类的表单会把value用做别的目的；此时使用组件选项对象的model选项即可避免冲突1234567891011121314151617181920Vue.component('my-checkbox', &#123; model: &#123;// v-model使用checked属性和change事件完成双向绑定，而不用原来的value属性和input属性 prop: 'checked', event: 'change' &#125;, props: &#123; checked: Boolean, // this allows using the `value` prop for a different purpose，value属性可以用做其他用途 value: String &#125;, // ...&#125;);&lt;my-checkbox v-model=\"foo\" value=\"some value\"&gt;&lt;/my-checkbox&gt;&lt;!-- 等价于 --&gt;&lt;my-checkbox :checked=\"foo\" @change=\"val =&gt; &#123; foo = val &#125;\" value=\"some value\"&gt;&lt;/my-checkbox&gt; 非父子组件通信 有时，非父子关系的组件也需要通信，这时需要一个中介来传递信息，在简单的场景下，可以使用一个空的 Vue 实例作为中央事件总线 1234567var bus = new Vue();// 触发组件 A 中的事件bus.$emit('id-selected', 1);// 在组件 B 创建的钩子中监听事件bus.$on('id-selected', function (id) &#123; // ...&#125;); 案例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;div id=\"app\"&gt; &lt;my-num :init-num=\"price\"&gt;&lt;/my-num&gt; &lt;my-div&gt;&lt;/my-div&gt;&lt;/div&gt;Vue.component('my-num', &#123; template: '&lt;input type=\"num\" v-model=\"num\" @input=\"numChanged\"&gt;', props: &#123; 'initNum': &#123; type: Number &#125; &#125;, data: function() &#123; return &#123; num: this.initNum &#125;; &#125;, methods: &#123; numChanged: function() &#123; console.log(this.num); bus.$emit('my-num-change', this.num); // 通过bus触发my-num-change &#125; &#125;&#125;);Vue.component('my-div', &#123; template: '&lt;h1&gt;&#123;&#123;text&#125;&#125;&lt;/h1&gt;', data: function() &#123; return &#123; text: '我将展示上面input的内容' &#125;; &#125;, created: function() &#123; // 创建后 var _self = this; bus.$on('my-num-change', function(str) &#123; // 监听my-num-change事件 _self.text = str; &#125;); &#125;&#125;);var bus = new Vue();var vm = new Vue(&#123; el: '#app', data: &#123; price: 3 &#125;&#125;); 使用Slot分发内容类似ng1中指令的transclude，用来混合父组件的内容和子组件的模板 编译作用域 父组件模板的内容在父组件作用域内编译；子组件模板的内容在子组件作用域内编译。1234567891011121314151617181920212223242526272829// message将在父组件/实例的作用域中编译，因为&#123;&#123;message&#125;&#125;实际是在父组件模板的内容中，而不是在子组件的模板内容中&lt;child-component&gt; &#123;&#123; message &#125;&#125;&lt;/child-component&gt;// 下例&#123;&#123;test&#125;&#125;、&#123;&#123;test2&#125;&#125;都将在根实例的作用域下编译&lt;div id=\"app\"&gt; &lt;parent-comp&gt; &#123;&#123;test&#125;&#125; &lt;br&gt; &lt;child-comp&gt; &#123;&#123;test2&#125;&#125; &lt;/child-comp&gt; &lt;/parent-comp&gt;&lt;/div&gt;// 假设someChildProperty是子组件上的属性，下面例子无效，将在父组件/实例的作用域中查找someChildProperty，你必须在child-component作用域中使用someChildProperty&lt;child-component v-show=\"someChildProperty\"&gt;&lt;/child-component&gt;// 下面有效Vue.component('child-component', &#123; // 有效，因为是在正确的作用域内 template: '&lt;div v-show=\"someChildProperty\"&gt;Child&lt;/div&gt;', data: function () &#123; return &#123; someChildProperty: true &#125; &#125;&#125;); 分发内容 父组件/实例中嵌套在子组件自定义便签中的内容都称为分发内容 分发内容是在父作用域内编译 分发内容适合混合/嵌套多个组件时使用1234&lt;!-- &#123;&#123;message&#125;&#125;属于分发内容，他将在child-component的父作用域中编译 --&gt;&lt;child-component&gt; &#123;&#123; message &#125;&#125;&lt;/child-component&gt; slot 除非子组件模板包含至少一个&lt;slot&gt;插口，否则父组件的内容将会被丢弃。类似ng1中directive模板中会指定一个标签，添加ng-transclude特性一样，这个标签将接收在父作用域中编译好的分发内容 当子组件模板只有一个没有属性的slot时，父组件整个内容片段将插入到slot所在的DOM位置，并替换掉slot标签本身 最初在 标签中的任何内容都被视为备用内容。备用内容在子组件的作用域内编译，并且只有在宿主元素为空，且没有要插入的内容时才显示备用内容。12345678910111213141516171819202122232425// 父组件模板 &lt;div&gt; &lt;h1&gt;我是父组件的标题&lt;/h1&gt; &lt;my-component&gt; &lt;p&gt;这是一些初始内容&lt;/p&gt; &lt;p&gt;这是更多的初始内容&lt;/p&gt; &lt;/my-component&gt;&lt;/div&gt;// 子组件my-component的模板&lt;div&gt; &lt;h2&gt;我是子组件的标题&lt;/h2&gt; &lt;slot&gt; 只有在没有要分发的内容时才会显示。&lt;slot&gt;整个标签将被分发内容替换 &lt;/slot&gt;&lt;/div&gt;// 渲染后&lt;div&gt; &lt;h1&gt;我是父组件的标题&lt;/h1&gt; &lt;div&gt; &lt;h2&gt;我是子组件的标题&lt;/h2&gt; &lt;!-- 下面是分发内容替换了&lt;slot&gt; --&gt; &lt;p&gt;这是一些初始内容&lt;/p&gt; &lt;p&gt;这是更多的初始内容&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 具名slot &lt;slot&gt;元素可以用一个特殊的属性 name 来配置如何分发内容。多个 slot 可以有不同的名字。具名 slot 将匹配内容片段中有对应 slot 特性的元素 仍然可以有一个匿名 slot，它是默认 slot，作为找不到匹配的内容片段的备用插槽。如果没有默认的 slot，这些找不到匹配的内容片段将被抛弃。 子组件模板上有个&lt;slot&gt;标签，通过标签上的name属性来给&lt;slot&gt;起个名字，分发内容上有个slot特性，通过这个slot特性的值找到子组件中对应名字的&lt;slot&gt;标签，并用分发内容将其替换掉。1234567891011121314151617181920212223242526272829303132// app-layout组件&lt;div class=\"container\"&gt; &lt;header&gt; &lt;slot name=\"header\"&gt;&lt;/slot&gt; // 这里将要放名字为header的分发内容 &lt;/header&gt; &lt;main&gt; &lt;slot&gt;&lt;/slot&gt;// 这里将要找不到匹配的分发内容 &lt;/main&gt; &lt;footer&gt; &lt;slot name=\"footer\"&gt;&lt;/slot&gt;// 这里将要放名字为footer的分发内容 &lt;/footer&gt;&lt;/div&gt;// 父组件模板&lt;app-layout&gt;// 这里面的都是分发内容 &lt;h1 slot=\"header\"&gt;这里可能是一个页面标题&lt;/h1&gt; // 这个将放到header的slot中 &lt;p&gt;主要内容的一个段落。&lt;/p&gt; &lt;p&gt;另一个主要段落。&lt;/p&gt; &lt;p slot=\"footer\"&gt;这里有一些联系信息&lt;/p&gt;// 这个将放到footer的slot中&lt;/app-layout&gt;// 渲染后&lt;div class=\"container\"&gt; &lt;header&gt; &lt;h1&gt;这里可能是一个页面标题&lt;/h1&gt; &lt;/header&gt; &lt;main&gt; &lt;p&gt;主要内容的一个段落。&lt;/p&gt; &lt;p&gt;另一个主要段落。&lt;/p&gt; &lt;/main&gt; &lt;footer&gt; &lt;p&gt;这里有一些联系信息&lt;/p&gt; &lt;/footer&gt;&lt;/div&gt; 作用域插槽(Scoped Slot) 正常情况下，分发内容是在父组件的作用域中编译的；考虑下面情况:我们需要创建一个组件，能使用同一份数据，根据DOM的不同渲染出不一样的界面；同一个组件，有不同的DOM结构，我们肯定不能将DOM结构固死在组件内部，肯定需要外部传入，我们很快就想到需要使用分发内容和Slot来完成，但这样会出现一个问题。我们的DOM结构是通过分发内容传入组件内部的，但是分发内容在传入子组件时，已经在父组件的作用域中编译过了，也就是说它用的数据是父组件的而不是子组件的。Scoped Slot就能解决这一问题，它能让分发内容在传入子组件前使用子组件的数据；以前分发内容只能在父组件作用域中编译，根本无法使用到子组件的数据，现在使用Scoped Slot能实现分发内容使用子组件的数据编译。这样能提高组件的复用性。 如何使用 在子组件模板&lt;slot&gt;标签上绑定需要暴露的数据(提供给父组件使用的数据)，这些数据会被封装到一个对象上，传递给父级 在父级上，必须有一个包含scope属性的&lt;template&gt;元素，表示它是作用域插槽的模板 scope的值对应一个临时变量名，此变量接收从子组件中传递过来的对象 实际例子 现在要实现一个列表组件，可以让用户自定义DOM结构12345678910111213141516171819202122232425262728293031&lt;div id=\"app\"&gt; &lt;my-awesome-list :items=\"items\"&gt; &lt;!-- 作用域插槽也可以是具名的,componProp就是子组件传递过来的对象 --&gt; &lt;template slot=\"list-item\" scope=\"componProp\"&gt; &lt;!-- 这里我可以使用任意的结构来渲染list --&gt; &lt;!-- &lt;h1&gt;&#123;&#123; componProp.text &#125;&#125;&lt;/h1&gt; --&gt; &lt;div style=\"font-style: italic;\"&gt;&#123;&#123; componProp.text &#125;&#125;&lt;/div&gt; &lt;/template&gt; &lt;/my-awesome-list&gt;&lt;/div&gt; Vue.component('my-awesome-list', &#123; props: &#123; items: &#123; type: Array, required: true &#125; &#125;, template: '&lt;div&gt;&lt;slot name=\"list-item\" v-for=\"item in items\" :text=\"item.text\"&gt;&lt;/slot&gt;&lt;/div&gt;'// 暴露text给分发内容使用&#125;); var vm = new Vue(&#123; el: '#app', data: &#123; items: [&#123; text: '11111' &#125;, &#123; text: '22222' &#125;] &#125;&#125;); 动态组件 通过使用保留的 元素，动态地绑定到它的 is 特性，我们让多个组件可以使用同一个挂载点，并动态切换 123456789101112131415&lt;component v-bind:is=\"currentView\"&gt; &lt;!-- 组件在 vm.currentview 变化时改变！ --&gt;&lt;/component&gt;var vm = new Vue(&#123; el: '#example', data: &#123; currentView: 'home' &#125;, components: &#123; home: &#123; /* ... */ &#125;, posts: &#123; /* ... */ &#125;, archive: &#123; /* ... */ &#125; &#125;&#125;); 也可以直接绑定到组件对象上 123456789var Home = &#123; template: &apos;&lt;p&gt;Welcome home!&lt;/p&gt;&apos;&#125;var vm = new Vue(&#123; el: &apos;#example&apos;, data: &#123; currentView: Home &#125;&#125;) 动态组件配合使用&lt;keep-alive&gt;来缓存非活动组件，避免重新渲染 12345&lt;keep-alive&gt; &lt;component :is=&quot;currentView&quot;&gt; &lt;!-- 非活动组件将被缓存！ --&gt; &lt;/component&gt;&lt;/keep-alive&gt; 杂项 编写可复用组件 Props 允许外部环境传递数据给组件 Events 允许从外部环境在组件内触发副作用 Slots 允许外部环境将额外的内容组合在组件中 子组件索引 尽管有 props 和 events，但是有时仍然需要在 JavaScript 中直接访问子组件。为此可以使用 ref 为子组件指定一个索引 ID 123456&lt;div id=\"parent\"&gt; &lt;user-profile ref=\"profile\"&gt;&lt;/user-profile&gt;&lt;/div&gt;var parent = new Vue(&#123; el: '#parent' &#125;);// 访问子组件var child = parent.$refs.profile 当 ref 和 v-for 一起使用时，ref 是一个数组，包含相应的子组件 $refs 只在组件渲染完成后才填充，并且它是非响应式的。它仅仅作为一个直接访问子组件的应急方案——应当避免在模版或计算属性中使用 $refs。 异步组件 在大型应用中，我们可能需要将应用拆分为多个小模块，按需从服务器下载。为了让事情更简单，Vue.js 允许将组件定义为一个工厂函数，动态地解析组件的定义。Vue.js 只在组件需要渲染时触发工厂函数，并且把结果缓存起来，用于后面的再次渲染。 12345678Vue.component(&apos;async-example&apos;, function (resolve, reject) &#123; setTimeout(function () &#123; // Pass the component definition to the resolve callback resolve(&#123; template: &apos;&lt;div&gt;I am async!&lt;/div&gt;&apos; &#125;) &#125;, 1000)&#125;) 工厂函数接收一个 resolve 回调，在收到从服务器下载的组件定义时调用。也可以调用 reject(reason) 指示加载失败。这里 setTimeout 只是为了演示。怎么获取组件完全由你决定。推荐配合使用 ：Webpack 的代码分割功能 123456Vue.component(&apos;async-webpack-example&apos;, function (resolve) &#123; // 这个特殊的 require 语法告诉 webpack // 自动将编译后的代码分割成不同的块， // 这些块将通过 Ajax 请求自动下载。 require([&apos;./my-async-component&apos;], resolve)&#125;) 你可以使用 Webpack 2 + ES2015 的语法返回一个 Promise resolve 函数 1234Vue.component( &apos;async-webpack-example&apos;, () =&gt; import(&apos;./my-async-component&apos;)) 当使用局部注册时，你也可以直接提供一个返回 Promise 的函数 123456new Vue(&#123; // ... components: &#123; &apos;my-component&apos;: () =&gt; import(&apos;./my-async-component&apos;) &#125;&#125;) 如果你是 Browserify 用户,可能就无法使用异步组件了,它的作者已经表明 Browserify 是不支持异步加载的。Browserify 社区发现 一些解决方法，可能有助于已存在的复杂应用。对于其他场景，我们推荐简单实用 Webpack 构建，一流的异步支持 高级异步组件 自 2.3.0 起，异步组件的工厂函数也可以返回一个如下的对象 123456789101112const AsyncComp = () =&gt; (&#123; // 需要加载的组件. 应当是一个 Promise component: import(&apos;./MyComp.vue&apos;), // loading 时应当渲染的组件 loading: LoadingComp, // 出错时渲染的组件 error: ErrorComp, // 渲染 loading 组件前的等待时间。默认：200ms. delay: 200, // 最长等待时间。超出此时间则渲染 error 组件。默认：Infinity timeout: 3000&#125;) 注意，当一个异步组件被作为 vue-router 的路由组件使用时，这些高级选项都是无效的，因为在路由切换前就会提前加载所需要的异步组件。另外，如果你要在路由组件中使用上述写法，需要使用 vue-router 2.4.0+。 组件命名约定 注册组件 (或者 props) 时，可以使用 kebab-case(短横线连接)，camelCase，或 PascalCase 在 HTML 模版中，使用组件推荐 kebab-case 形式 递归组件 组件在它的模板内可以递归地调用自己，不过，只有当它有 name 选项时才可以 当你利用Vue.component全局注册了一个组件, 全局的ID作为组件的 name 选项，被自动设置.局部注册需要手动设置 递归时，一定要设置终止条件 组件间的循环引用 假设你正在构建一个文件目录树，像在Finder或文件资源管理器中。你可能有一个 tree-folder组件12345678910111213// tree-folder组件&lt;p&gt; &lt;span&gt;&#123;&#123; folder.name &#125;&#125;&lt;/span&gt; &lt;tree-folder-contents :children=&quot;folder.children&quot;/&gt;&lt;/p&gt;// 然后 一个tree-folder-contents组件&lt;ul&gt; &lt;li v-for=&quot;child in children&quot;&gt; &lt;tree-folder v-if=&quot;child.children&quot; :folder=&quot;child&quot;/&gt; &lt;span v-else&gt;&#123;&#123; child.name &#125;&#125;&lt;/span&gt; &lt;/li&gt;&lt;/ul&gt;// 当你仔细看时，会发现在渲染树上这两个组件同时为对方的父节点和子节点–这点是矛盾的。当使用Vue.component将这两个组件注册为全局组件的时候，框架会自动为你解决这个矛盾 内联模版 如果子组件有 inline-template 特性，组件将把它的内容当作它的模板，而不是把它当作分发内容 123456&lt;my-component inline-template&gt; &lt;div&gt; &lt;p&gt;These are compiled as the component&apos;s own template.&lt;/p&gt; &lt;p&gt;Not parent&apos;s transclusion content.&lt;/p&gt; &lt;/div&gt;&lt;/my-component&gt; 但是 inline-template 让模板的作用域难以理解。最佳实践是使用 template 选项在组件内定义模板或者在 .vue 文件中使用 template 元素 X-Templates 另一种定义模版的方式是在 JavaScript 标签里使用 text/x-template 类型，并且指定一个 id 123456&lt;script type=&quot;text/x-template&quot; id=&quot;hello-world-template&quot;&gt; &lt;p&gt;Hello hello hello&lt;/p&gt;&lt;/script&gt;Vue.component(&apos;hello-world&apos;, &#123; template: &apos;#hello-world-template&apos;&#125;) 这在有很多模版或者小的应用中有用，否则应该避免使用，因为它将模版和组件的其他定义隔离了。 对低开销的静态组件使用 v-once 尽管在 Vue 中渲染 HTML 很快，不过当组件中包含大量静态内容时，可以考虑使用 v-once 将渲染结果缓存起来，就像这样12345678Vue.component(&apos;terms-of-service&apos;, &#123; template: &apos;\\ &lt;div v-once&gt;\\ &lt;h1&gt;Terms of Service&lt;/h1&gt;\\ ... a lot of static content ...\\ &lt;/div&gt;\\ &apos;&#125;) 深入响应式原理如何追踪变化 Vue通过Object.defineProperty将属性转化为setter/getter，在setter/getter中进行依赖追踪 把一个普通 JavaScript 对象传给 Vue 实例的 data 选项，Vue 将遍历此对象所有的属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter。 用户看不到 getter/setter，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化 每个组件实例都有相应的 watcher 实例对象，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的 setter 被调用时，会通知 watcher 重新计算，从而致使它关联的组件得以更新 变化检测问题 受现代 JavaScript 的限制（以及废弃 Object.observe），Vue 不能检测到对象属性的添加或删除。由于 Vue 会在初始化实例时对属性执行 getter/setter 转化过程，所以属性必须在 data 对象上存在才能让 Vue 转换它，这样才能让它是响应的 12345678var vm = new Vue(&#123; data:&#123; a:1 &#125;&#125;)// `vm.a` 是响应的vm.b = 2// `vm.b` 是非响应的 可以使用Vue.set(target,key,value)或者vm.$set(target,key,value)来添加响应式属性;注意target不能是 Vue 实例，或者 Vue 实例的根数据对象 有时你想向已有对象上添加一些属性，例如使用 Object.assign() 或 _.extend() 方法来添加属性。但是，添加到对象上的新属性不会触发更新。在这种情况下可以创建一个新的对象，让它包含原对象的属性和新的属性12// 代替 `Object.assign(this.someObject, &#123; a: 1, b: 2 &#125;)`this.someObject = Object.assign(&#123;&#125;, this.someObject, &#123; a: 1, b: 2 &#125;) 声明响应式属性 由于 Vue 不允许动态添加根级响应式属性，所以你必须在初始化实例前声明根级响应式属性，哪怕只是一个空值123456789var vm = new Vue(&#123; data: &#123; // 声明 message 为一个空值字符串 message: '' &#125;, template: '&lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;'&#125;)// 之后设置 `message` vm.message = 'Hello!' 异步更新队列 Vue中的DOM更新是异步的；实际的DOM更新是发生在观察到数据变化后下一个eventLoop的tick中 只要观察到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变。如果同一个 watcher 被多次触发，只会一次推入到队列中。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作上非常重要。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际（已去重的）工作。(数据变化-&gt;开启队列-&gt;去重复/缓冲)-&gt;(DOM更新)，在同一个括号中，代表发生在同一个tick中 Vue 在内部尝试对异步队列使用原生的 Promise.then 和 MutationObserver，如果执行环境不支持，会采用 setTimeout(fn, 0) 代替。例如，当你设置 vm.someData = ‘new value’ ，该组件不会立即重新渲染。当刷新队列时，组件会在事件循环队列清空时的下一个“tick”更新。 可以使用Vue.nextTick(callback),在 DOM 更新完成后立即调用callback 123456789101112&lt;div id=\"example\"&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt;var vm = new Vue(&#123; el: '#example', data: &#123; message: '123' &#125;&#125;)vm.message = 'new message' // 更改数据vm.$el.textContent === 'new message' // falseVue.nextTick(function () &#123; vm.$el.textContent === 'new message' // true&#125;) 组件内使用vm.$nextTick(callback),callback中的 this 将自动绑定到当前的 Vue 实例上 1234567891011121314151617Vue.component(&apos;example&apos;, &#123; template: &apos;&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;&apos;, data: function () &#123; return &#123; message: &apos;没有更新&apos; &#125; &#125;, methods: &#123; updateMessage: function () &#123; this.message = &apos;更新完成&apos; console.log(this.$el.textContent) // =&gt; &apos;没有更新&apos; this.$nextTick(function () &#123; console.log(this.$el.textContent) // =&gt; &apos;更新完成&apos; &#125;) &#125; &#125;&#125;) 过渡效果单元素/组件的过渡 Vue 提供了 transition 的封装组件，在下列情形中，可以给任何元素和组件添加 entering/leaving 过渡 条件渲染 （使用 v-if） 条件展示 （使用 v-show） 动态组件 组件根节点 12345678910111213141516171819202122&lt;div id=\"demo\"&gt; &lt;button v-on:click=\"show = !show\"&gt; Toggle &lt;/button&gt; &lt;transition name=\"fade\"&gt; &lt;p v-if=\"show\"&gt;hello&lt;/p&gt; &lt;/transition&gt;&lt;/div&gt;.fade-enter-active, .fade-leave-active &#123; transition: opacity 0.5s&#125;.fade-enter, .fade-leave-to &#123; opacity: 0&#125;new Vue(&#123; el: '#demo', data: &#123; show: true &#125;&#125;); 当插入或删除包含在&lt;transition&gt;组件中的元素时，Vue 将会做以下处理 自动嗅探目标元素是否应用了 CSS 过渡或动画，如果是，在恰当的时机添加/删除 CSS 类名。 如果过渡组件提供了 JavaScript 钩子函数，这些钩子函数将在恰当的时机被调用 如果没有找到 JavaScript 钩子并且也没有检测到 CSS 过渡/动画，DOM 操作（插入/删除）在下一帧中立即执行。(注意：此指浏览器逐帧动画机制，和Vue的 nextTick 概念不同) 过渡的css类名类似ng中动画会添加合适的class 会有 6 个(CSS)类名在 enter/leave 的过渡中切换 v-enter-&gt;定义开始状态，会在元素插入时生效，并在下一frame被删除 v-enter-active-&gt;定义过渡状态，插入时生效，过渡结束时删除；这个可以被用来定义过渡的过程时间，延迟和曲线函数。 v-enter-to-&gt;定义过渡结束状态，在元素插入后的下一frame被加入(v-enter正好删除),过渡结束时删除 同理，leave也一样，有v-leave、v-leave-active、v-leave-to 过渡中的类名前缀是可以更换的，通过&lt;transtion&gt;组件的name特性可以指定过渡类的前缀12// 对应的过渡样式类就是.testAnim-enter、.testAnim-enter-active、.testAnim-enter-to&lt;transtion name=&quot;testAnim&quot;&gt;xxx&lt;/transition&gt; css过渡最常用的1234567891011121314151617181920212223242526&lt;div id=&quot;example-1&quot;&gt; &lt;button @click=&quot;show = !show&quot;&gt; Toggle render &lt;/button&gt; &lt;transition name=&quot;slide-fade&quot;&gt; &lt;p v-if=&quot;show&quot;&gt;hello&lt;/p&gt; &lt;/transition&gt;&lt;/div&gt;new Vue(&#123; el: &apos;#example-1&apos;, data: &#123; show: true &#125;&#125;);/* 可以设置不同的进入和离开动画 *//* 设置持续时间和动画函数 */.slide-fade-enter-active &#123; transition: all .3s ease;&#125;.slide-fade-leave-active &#123; transition: all .8s cubic-bezier(1.0, 0.5, 0.8, 1.0);&#125;.slide-fade-enter, .slide-fade-leave-to &#123; transform: translateX(10px); opacity: 0;&#125; css动画animation CSS 动画用法同 CSS 过渡，区别是在动画中v-enter类名在节点插入 DOM 后不会立即删除，而是在 animationend 事件触发时(动画结束)删除。1234567891011121314151617181920212223242526272829&lt;div id=&quot;example-2&quot;&gt; &lt;button @click=&quot;show = !show&quot;&gt;Toggle show&lt;/button&gt; &lt;transition name=&quot;bounce&quot;&gt; &lt;p v-if=&quot;show&quot;&gt;Look at me!&lt;/p&gt; &lt;/transition&gt;&lt;/div&gt;new Vue(&#123; el: &apos;#example-2&apos;, data: &#123; show: true &#125;&#125;);.bounce-enter-active &#123; animation: bounce-in .5s;&#125;.bounce-leave-active &#123; animation: bounce-in .5s reverse;&#125;@keyframes bounce-in &#123; 0% &#123; transform: scale(0); &#125; 50% &#123; transform: scale(1.5); &#125; 100% &#123; transform: scale(1); &#125;&#125; 自定义过渡类名 可以通过以下特性来自定义过渡类名;主要用来配合第三方css动画库使用;他们的优先级高于普通的类名 enter-class enter-active-class enter-to-class (2.1.8+) leave-class leave-active-class leave-to-class (2.1.8+)123456789101112131415161718192021&lt;link href=&quot;https://unpkg.com/animate.css@3.5.1/animate.min.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;&lt;div id=&quot;example-3&quot;&gt; &lt;button @click=&quot;show = !show&quot;&gt; Toggle render &lt;/button&gt; &lt;!-- 进入离开时用特殊的class --&gt; &lt;transition name=&quot;custom-classes-transition&quot; enter-active-class=&quot;animated tada&quot; leave-active-class=&quot;animated bounceOutRight&quot; &gt; &lt;p v-if=&quot;show&quot;&gt;hello&lt;/p&gt; &lt;/transition&gt;&lt;/div&gt;new Vue(&#123; el: &apos;#example-3&apos;, data: &#123; show: true &#125;&#125;); 同时使用 Transitions 和 Animations Vue 为了知道过渡的完成，必须设置相应的事件监听器。它可以是 transitionend 或 animationend ，这取决于给元素应用的 CSS 规则。如果你使用其中任何一种，Vue 能自动识别类型并设置监听。 但是，在一些场景中，你需要给同一个元素同时设置两种过渡动效，比如 animation 很快的被触发并完成了，而 transition 效果还没结束。在这种情况中，你就需要使用 type 特性并设置 animation 或 transition 来明确声明你需要 Vue 监听的类型。 显性的过渡效果持续时间 在很多情况下，Vue 可以自动得出过渡效果的完成时机。默认情况下，Vue 会等待其在过渡效果的根元素的第一个 transitionend 或 animationend 事件。然而也可以不这样设定——比如，我们可以拥有一个精心编排的一序列过渡效果，其中一些嵌套的内部元素相比于过渡效果的根元素有延迟的或更长的过渡效果。在这种情况下你可以用 组件上的 duration 属性定制一个显性的过渡效果持续时间 (以毫秒计)：123&lt;transition :duration=&quot;1000&quot;&gt;...&lt;/transition&gt;// 你也可以定制进入和移出的持续时间：&lt;transition :duration=&quot;&#123; enter: 500, leave: 800 &#125;&quot;&gt;...&lt;/transition&gt; ###JavaScript 钩子(Js动画)可以在属性中声明 JavaScript 钩子，通过钩子在特定时间调用特定动画函数来实现js动画 beforeEnter-&gt;进入前 enter-&gt;进入中 after-enter-&gt;进入后 enter-cancelled-&gt;取消后 同理leave也有类似钩子 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;transition v-on:before-enter=&quot;beforeEnter&quot; v-on:enter=&quot;enter&quot; v-on:after-enter=&quot;afterEnter&quot; v-on:enter-cancelled=&quot;enterCancelled&quot; v-on:before-leave=&quot;beforeLeave&quot; v-on:leave=&quot;leave&quot; v-on:after-leave=&quot;afterLeave&quot; v-on:leave-cancelled=&quot;leaveCancelled&quot;&gt; &lt;!-- ... --&gt;&lt;/transition&gt;// ...methods: &#123; // -------- // 进入中 // -------- beforeEnter: function (el) &#123; // ... &#125;, // 此回调函数是可选项的设置 // 与 CSS 结合时使用 enter: function (el, done) &#123; // ... done() &#125;, afterEnter: function (el) &#123; // ... &#125;, enterCancelled: function (el) &#123; // ... &#125;, // -------- // 离开时 // -------- beforeLeave: function (el) &#123; // ... &#125;, // 此回调函数是可选项的设置 // 与 CSS 结合时使用 leave: function (el, done) &#123; // ... done() &#125;, afterLeave: function (el) &#123; // ... &#125;, // leaveCancelled 只用于 v-show 中 leaveCancelled: function (el) &#123; // ... &#125;&#125; 这些钩子函数可以结合 CSS transitions/animations 使用，也可以单独使用。 当只用 JavaScript 过渡的时候， 在 enter 和 leave 中，回调函数 done 是必须的 。 否则，它们会被同步调用，过渡会立即完成。 推荐对于仅使用 JavaScript 过渡的元素添加 v-bind:css=”false”，Vue 会跳过 CSS 的检测。这也可以避免过渡过程中 CSS 的影响。 初始渲染的过渡定义第一次渲染时，如何过渡 通过添加appear特性，可以开启初始渲染过渡动画 和enter、leave过渡一样可以自己定义css类名 12345678&lt;transition appear appear-class=&quot;custom-appear-class&quot; appear-to-class=&quot;custom-appear-to-class&quot; appear-active-class=&quot;custom-appear-active-class&quot;&gt; &lt;!-- ... --&gt;&lt;/transition&gt; 也有相应的js钩子 123456789&lt;transition appear v-on:before-appear=&quot;customBeforeAppearHook&quot; v-on:appear=&quot;customAppearHook&quot; v-on:after-appear=&quot;customAfterAppearHook&quot; v-on:appear-cancelled=&quot;customAppearCancelledHook&quot;&gt; &lt;!-- ... --&gt;&lt;/transition&gt; 多个元素的过渡 对于原生标签可以使用 v-if/v-else 。最常见的多标签过渡是一个列表和描述这个列表为空消息的元素 123456&lt;transition&gt; &lt;table v-if=&quot;items.length &gt; 0&quot;&gt; &lt;!-- ... --&gt; &lt;/table&gt; &lt;p v-else&gt;Sorry, no items found.&lt;/p&gt;&lt;/transition&gt; 当有相同标签名的元素切换时，需要通过 key 特性设置唯一的值来标记以让 Vue 区分它们，否则 Vue 为了效率只会替换相同标签内部的内容。即使在技术上没有必要，给在 组件中的多个元素设置 key 是一个更好的实践。 12345678910111213141516171819202122232425262728293031323334353637383940 &lt;style type=&quot;text/css&quot;&gt; .fade-enter, .fade-leave &#123; opacity: 0; &#125; .fade-enter-active, .fade-leave-active &#123; transition: all .3s ease-in-out; &#125; &lt;/style&gt;&lt;div id=&quot;app&quot;&gt; &lt;transition name=&quot;fade&quot;&gt; &lt;!-- 没有加key,根据vue的就地复用原则，他们将只替换内容，因此不会产生过渡动画 --&gt; &lt;!-- &lt;button v-if=&quot;isEditing&quot;&gt; Save &lt;/button&gt; &lt;button v-else&gt; Edit &lt;/button&gt; --&gt; &lt;!-- 添加key --&gt; &lt;!-- &lt;button v-if=&quot;isEditing&quot; key=&quot;save&quot;&gt; Save &lt;/button&gt; &lt;button v-else key=&quot;edit&quot;&gt; Edit &lt;/button&gt; --&gt; &lt;!-- 在一些场景中，也可以给通过给同一个元素的 key 特性设置不同的状态来代替 v-if 和 v-else，上面的例子可以重写为： --&gt; &lt;button v-bind:key=&quot;isEditing&quot;&gt; &#123;&#123; isEditing ? &apos;Save&apos; : &apos;Edit&apos; &#125;&#125; &lt;/button&gt; &lt;/transition&gt; &lt;button @click=&quot;isEditing=!isEditing&quot;&gt;点击&lt;/button&gt;&lt;/div&gt;var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123; isEditing: true &#125; &#125;); 使用多个 v-if 的多个元素的过渡可以重写为绑定了动态属性的单个元素过渡 123456789101112131415161718192021222324252627&lt;transition&gt; &lt;button v-if=&quot;docState === &apos;saved&apos;&quot; key=&quot;saved&quot;&gt; Edit &lt;/button&gt; &lt;button v-if=&quot;docState === &apos;edited&apos;&quot; key=&quot;edited&quot;&gt; Save &lt;/button&gt; &lt;button v-if=&quot;docState === &apos;editing&apos;&quot; key=&quot;editing&quot;&gt; Cancel &lt;/button&gt;&lt;/transition&gt;&lt;!-- 重写 --&gt;&lt;transition&gt; &lt;button v-bind:key=&quot;docState&quot;&gt; &#123;&#123; buttonMessage &#125;&#125; &lt;/button&gt;&lt;/transition&gt;// ...computed: &#123; buttonMessage: function () &#123; switch (this.docState) &#123; case &apos;saved&apos;: return &apos;Edit&apos; case &apos;edited&apos;: return &apos;Save&apos; case &apos;editing&apos;: return &apos;Cancel&apos; &#125; &#125;&#125; 多元素的过渡模式多元素过渡时(一个enter、一个leave)默认是进入和离开同时发生；这样可能会发生过渡时画面抖动的问题；通过多元素的过渡模式可以解决 通过在&lt;transtion&gt;上添加mode特性便可指定过渡模式 in-out: 新元素先进行过渡进入，完成之后当前元素过渡离开。-&gt;先enter后leave out-in: 当前元素先进行过渡离开，完成之后新元素过渡进入。-&gt;先leave后enter1234567891011121314151617181920212223242526272829303132&lt;style type=&quot;text/css&quot;&gt; .fade-enter, .fade-leave-to &#123; opacity: 0; &#125; .fade-enter &#123; transform: translateX(10px); &#125; .fade-leave-to &#123; transform: translateX(-10px); &#125; .fade-enter-active, .fade-leave-active &#123; transition: all .3s ease-in-out; &#125;&lt;/style&gt;&lt;div id=&quot;app&quot;&gt; &lt;transition name=&quot;fade&quot; mode=&quot;in-out&quot;&gt; &lt;button :key=&quot;isEditing&quot; @click=&quot;isEditing=!isEditing&quot; :style=&quot;&#123;position:&apos;absolute&apos;&#125;&quot;&gt; &#123;&#123; isEditing &#125;&#125; &lt;/button&gt; &lt;/transition&gt;&lt;/div&gt; var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123; isEditing: true &#125;&#125;); 多个组件的过渡 多个组件的过渡简单很多 - 我们不需要使用 key 特性。相反，我们只需要使用动态组件1234567891011121314151617181920212223&lt;transition name=&quot;component-fade&quot; mode=&quot;out-in&quot;&gt; &lt;component v-bind:is=&quot;view&quot;&gt;&lt;/component&gt;&lt;/transition&gt;new Vue(&#123; el: &apos;#transition-components-demo&apos;, data: &#123; view: &apos;v-a&apos; &#125;, components: &#123; &apos;v-a&apos;: &#123; template: &apos;&lt;div&gt;Component A&lt;/div&gt;&apos; &#125;, &apos;v-b&apos;: &#123; template: &apos;&lt;div&gt;Component B&lt;/div&gt;&apos; &#125; &#125;&#125;);.component-fade-enter-active, .component-fade-leave-active &#123; transition: opacity .3s ease;&#125;.component-fade-enter, .component-fade-leave-to&#123; opacity: 0;&#125; 列表过渡 那么怎么同时渲染整个列表，比如使用 v-for ？在这种场景中，使用&lt;transition-group&gt;组件。 不同于&lt;transition&gt;，它会以一个真实元素呈现：默认为一个 。你也可以通过tag特性更换为其他元素。 内部元素 总是需要 提供唯一的 key 属性值1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;style type=&quot;text/css&quot;&gt; .list-item &#123; display: inline-block; margin-right: 10px; &#125; .list-enter-active, .list-leave-active &#123; transition: all 1s; &#125; .list-enter, .list-leave-to &#123; opacity: 0; transform: translateY(30px); &#125;&lt;/style&gt;&lt;div id=&quot;list-demo&quot; class=&quot;demo&quot;&gt; &lt;button v-on:click=&quot;add&quot;&gt;Add&lt;/button&gt; &lt;button v-on:click=&quot;remove&quot;&gt;Remove&lt;/button&gt; &lt;!-- 因为指定了tag特性，所以transition-group将被p取代 --&gt; &lt;transition-group name=&quot;list&quot; tag=&quot;p&quot;&gt; &lt;!-- 绑定唯一的key --&gt; &lt;span v-for=&quot;item in items&quot; v-bind:key=&quot;item&quot; class=&quot;list-item&quot;&gt;&#123;&#123; item &#125;&#125;&lt;/span&gt; &lt;/transition-group&gt;&lt;/div&gt;new Vue(&#123; el: &apos;#list-demo&apos;, data: &#123; items: [1, 2, 3, 4, 5, 6, 7, 8, 9], nextNum: 10 &#125;, methods: &#123; randomIndex: function() &#123; return Math.floor(Math.random() * this.items.length) &#125;, add: function() &#123; this.items.splice(this.randomIndex(), 0, this.nextNum++) &#125;, remove: function() &#123; this.items.splice(this.randomIndex(), 1) &#125;, &#125;&#125;); 列表的位移过渡 上面的例子，当添加和移除元素的时候，周围的元素会瞬间移动到他们的新布局的位置，而不是平滑的过渡 &lt;transition-group&gt;组件还有一个特殊之处。不仅可以进入和离开动画，还可以改变定位。要使用这个新功能只需了解新增的v-move特性，它会在元素的改变定位的过程中应用。像之前的类名一样，可以通过name属性来自定义前缀，也可以通过move-class属性手动设置 12345678910111213141516171819202122232425&lt;style type=&quot;text/css&quot;&gt; /*设置-move*/ .flip-list-move &#123; transition: transform 1s; &#125;&lt;/style&gt;&lt;div id=&quot;flip-list-demo&quot; class=&quot;demo&quot;&gt; &lt;button v-on:click=&quot;shuffle&quot;&gt;洗牌&lt;/button&gt; &lt;transition-group name=&quot;flip-list&quot; tag=&quot;ul&quot;&gt; &lt;li v-for=&quot;item in items&quot; v-bind:key=&quot;item&quot;&gt; &#123;&#123; item &#125;&#125; &lt;/li&gt; &lt;/transition-group&gt;&lt;/div&gt;new Vue(&#123; el: &apos;#flip-list-demo&apos;, data: &#123; items: [1, 2, 3, 4, 5, 6, 7, 8, 9] &#125;, methods: &#123; shuffle: function() &#123; this.items = _.shuffle(this.items) // 打乱 &#125; &#125;&#125;) 内部的实现，Vue 使用了一个叫 FLIP 简单的动画队列使用 transforms 将元素从之前的位置平滑过渡新的位置。 需要注意的是使用FLIP过渡的元素不能设置为 display: inline 。作为替代方案，可以设置为 display: inline-block 或者放置于 flex 中 列表的渐进过渡 通过 data 属性与 JavaScript 通信 ，就可以实现列表的渐进过渡1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js&quot;&gt;&lt;/script&gt;&lt;div id=&quot;staggered-list-demo&quot;&gt; &lt;input v-model=&quot;query&quot;&gt; &lt;!-- 因为是全部用js完成动画，所以v-bind:css=&quot;false&quot;，避开css动画检查，提高效率；并在各个动画钩子处绑定动画函数 --&gt; &lt;transition-group name=&quot;staggered-fade&quot; tag=&quot;ul&quot; v-bind:css=&quot;false&quot; v-on:before-enter=&quot;beforeEnter&quot; v-on:enter=&quot;enter&quot; v-on:leave=&quot;leave&quot;&gt; &lt;!-- 绑定唯一的key并绑定索引 --&gt; &lt;li v-for=&quot;(item, index) in computedList&quot; v-bind:key=&quot;item.msg&quot; v-bind:data-index=&quot;index&quot;&gt;&#123;&#123; item.msg &#125;&#125;&lt;/li&gt; &lt;/transition-group&gt;&lt;/div&gt;new Vue(&#123; el: &apos;#staggered-list-demo&apos;, data: &#123; query: &apos;&apos;, list: [ &#123; msg: &apos;Bruce Lee&apos; &#125;, &#123; msg: &apos;Jackie Chan&apos; &#125;, &#123; msg: &apos;Chuck Norris&apos; &#125;, &#123; msg: &apos;Jet Li&apos; &#125;, &#123; msg: &apos;Kung Fury&apos; &#125; ] &#125;, computed: &#123; computedList: function() &#123; var vm = this return this.list.filter(function(item) &#123; return item.msg.toLowerCase().indexOf(vm.query.toLowerCase()) !== -1 &#125;) &#125; &#125;, methods: &#123; beforeEnter: function(el) &#123; el.style.opacity = 0 el.style.height = 0 &#125;, enter: function(el, done) &#123; // 根据索引创建延迟 var delay = el.dataset.index * 150; setTimeout(function() &#123; Velocity( el, &#123; opacity: 1, height: &apos;1.6em&apos; &#125;, &#123; complete: done &#125; ) &#125;, delay) &#125;, leave: function(el, done) &#123; var delay = el.dataset.index * 150 setTimeout(function() &#123; Velocity( el, &#123; opacity: 0, height: 0 &#125;, &#123; complete: done &#125; ) &#125;, delay) &#125; &#125; &#125;) 可复用的过渡 过渡可以通过 Vue 的组件系统实现复用 要创建一个可复用过渡组件，你需要做的就是将 或者 作为根组件，然后将任何子组件放置在其中就可以了。1234567891011121314151617181920Vue.component(&apos;my-special-transition&apos;, &#123; template: &apos;\\ &lt;transition\\ name=&quot;very-special-transition&quot;\\ mode=&quot;out-in&quot;\\ v-on:before-enter=&quot;beforeEnter&quot;\\ v-on:after-enter=&quot;afterEnter&quot;\\ &gt;\\ &lt;slot&gt;&lt;/slot&gt;\\ &lt;/transition&gt;\\ &apos;, methods: &#123; beforeEnter: function (el) &#123; // ... &#125;, afterEnter: function (el) &#123; // ... &#125; &#125;&#125;) 动态过渡 Vue 中即使是过渡也是数据驱动的，过渡中的各种状态能通过数据动态改变。 当你想用 Vue 的过渡系统来定义的 CSS 过渡/动画 在不同过渡间切换会非常有用 所有的过渡特性都是动态绑定。 它不仅是简单的特性，通过事件的钩子函数方法，可以在获取到相应上下文数据。 这意味着，可以根据组件的状态通过 JavaScript 过渡设置不同的过渡效果。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js&quot;&gt;&lt;/script&gt;&lt;div id=&quot;dynamic-fade-demo&quot; class=&quot;demo&quot;&gt; Fade In: &lt;input type=&quot;range&quot; v-model=&quot;fadeInDuration&quot; min=&quot;0&quot; v-bind:max=&quot;maxFadeDuration&quot;&gt; Fade Out: &lt;input type=&quot;range&quot; v-model=&quot;fadeOutDuration&quot; min=&quot;0&quot; v-bind:max=&quot;maxFadeDuration&quot;&gt; &lt;transition v-bind:css=&quot;false&quot; v-on:before-enter=&quot;beforeEnter&quot; v-on:enter=&quot;enter&quot; v-on:leave=&quot;leave&quot; &gt; &lt;p v-if=&quot;show&quot;&gt;hello&lt;/p&gt; &lt;/transition&gt; &lt;button v-if=&quot;stop&quot; v-on:click=&quot;stop = false; show = false&quot; &gt;Start animating&lt;/button&gt; &lt;button v-else v-on:click=&quot;stop = true&quot; &gt;Stop it!&lt;/button&gt;&lt;/div&gt;new Vue(&#123; el: &apos;#dynamic-fade-demo&apos;, data: &#123; show: true, fadeInDuration: 1000, fadeOutDuration: 1000, maxFadeDuration: 1500, stop: true &#125;, mounted: function () &#123; this.show = false &#125;, methods: &#123; beforeEnter: function (el) &#123; el.style.opacity = 0 &#125;, enter: function (el, done) &#123; var vm = this Velocity(el, &#123; opacity: 1 &#125;, &#123; duration: this.fadeInDuration,// 持续时间为动态绑定 complete: function () &#123; done() if (!vm.stop) vm.show = false &#125; &#125; ) &#125;, leave: function (el, done) &#123; var vm = this Velocity(el, &#123; opacity: 0 &#125;, &#123; duration: this.fadeOutDuration,// 持续时间为动态绑定 complete: function () &#123; done() vm.show = true &#125; &#125; ) &#125; &#125;&#125;) 过渡状态 Vue 的过渡系统提供了非常多简单的方法设置进入、离开和列表的动效。有些变化中间的过渡状态无法通过vue独自完成，例如 数字和运算(数字从1变为10中间的过渡) 颜色的显示(从一种颜色变化到另一种的过渡) SVG 节点的位置 元素的大小和其他的属性 所有的原始数字都被事先存储起来，可以直接转换到数字。做到这一步，我们就可以结合 Vue 的响应式和组件系统，使用第三方库来实现切换元素的过渡状态，补间动画 状态动画 与 watcher 通过 watcher 我们能监听到任何数值属性的数值更新，然后调用一些辅助用的动画库(例如tween.js、color.js)完成相应的特殊过渡123456789101112131415161718192021222324252627282930&lt;script src=&quot;https://unpkg.com/tween.js@16.3.4&quot;&gt;&lt;/script&gt;&lt;div id=&quot;animated-number-demo&quot;&gt; &lt;input v-model.number=&quot;number&quot; type=&quot;number&quot; step=&quot;20&quot;&gt; &lt;p&gt;&#123;&#123; animatedNumber &#125;&#125;&lt;/p&gt;&lt;/div&gt;new Vue(&#123; el: &apos;#animated-number-demo&apos;, data: &#123; number: 0, animatedNumber: 0 &#125;, watch: &#123; number: function(newValue, oldValue) &#123; var vm = this function animate () &#123; if (TWEEN.update()) &#123; requestAnimationFrame(animate) &#125; &#125; new TWEEN.Tween(&#123; tweeningNumber: oldValue &#125;) .easing(TWEEN.Easing.Quadratic.Out) .to(&#123; tweeningNumber: newValue &#125;, 500) .onUpdate(function () &#123; vm.animatedNumber = this.tweeningNumber.toFixed(0) &#125;) .start() animate() &#125; &#125;&#125;) 动态状态转换 类似动态过渡，每个状态都是可变的(响应式的) 通过组件组织过渡 管理太多的状态转换会很快的增加 Vue 实例或者组件的复杂性，幸好很多的动画可以提取到专用的子组件。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;script src=&quot;https://unpkg.com/tween.js@16.3.4&quot;&gt;&lt;/script&gt;&lt;div id=&quot;example-8&quot;&gt; &lt;input v-model.number=&quot;firstNumber&quot; type=&quot;number&quot; step=&quot;20&quot;&gt; + &lt;input v-model.number=&quot;secondNumber&quot; type=&quot;number&quot; step=&quot;20&quot;&gt; = &#123;&#123; result &#125;&#125; &lt;p&gt; &lt;!-- 传入输入框的值 --&gt; &lt;animated-integer v-bind:value=&quot;firstNumber&quot;&gt;&lt;/animated-integer&gt; + &lt;animated-integer v-bind:value=&quot;secondNumber&quot;&gt;&lt;/animated-integer&gt; = &lt;animated-integer v-bind:value=&quot;result&quot;&gt;&lt;/animated-integer&gt; &lt;/p&gt;&lt;/div&gt;// 这种复杂的补间动画逻辑可以被复用// 任何整数都可以执行动画// 组件化使我们的界面十分清晰// 可以支持更多更复杂的动态过渡Vue.component(&apos;animated-integer&apos;, &#123; template: &apos;&lt;span&gt;&#123;&#123; tweeningValue &#125;&#125;&lt;/span&gt;&apos;, props: &#123; value: &#123; // 接收的值 type: Number, required: true &#125; &#125;, data: function() &#123; return &#123; tweeningValue: 0 &#125; &#125;, watch: &#123; // 传过来的值有变化，触发tween value: function(newValue, oldValue) &#123; this.tween(oldValue, newValue) &#125; &#125;, mounted: function() &#123; // 刚载入，触发默认tween this.tween(0, this.value) &#125;, methods: &#123; tween: function(startValue, endValue) &#123; var vm = this; // raf function animate() &#123; if (TWEEN.update()) &#123; requestAnimationFrame(animate) &#125; &#125; // 数值变化的补间动画 new TWEEN.Tween(&#123; tweeningValue: startValue &#125;) .to(&#123; tweeningValue: endValue &#125;, 500) .onUpdate(function() &#123; vm.tweeningValue = this.tweeningValue.toFixed(0) &#125;) .start(); // 调用一次 animate(); &#125; &#125;&#125;);new Vue(&#123; el: &apos;#example-8&apos;, data: &#123; firstNumber: 20, secondNumber: 40 &#125;, computed: &#123; result: function() &#123; return this.firstNumber + this.secondNumber &#125; &#125;&#125;) Render函数-&gt;后期补自定义指令 vue2中代码复用的主要形式和抽象是组件,有的情况下,你仍然需要对纯 DOM 元素进行底层操作,这时候就会用到自定义指令。 简介 注册 全局注册 12345678// 注册一个全局自定义指令 v-focusVue.directive(&apos;focus&apos;, &#123; // 当绑定元素插入到 DOM 中。 inserted: function (el) &#123; // 聚焦元素 el.focus() &#125;&#125;) 局部注册 12345directives: &#123; focus: &#123; // 指令的定义--- &#125;&#125; 使用-&gt;&lt;input v-focus&gt; 钩子函数 自定义指令提供下面钩子 bind-&gt;只调用一次，只在第一次绑定到元素时调用，主要用做初始化工作 inserted-&gt;被绑定元素插入父节点时调用（父节点存在即可调用，不必存在于 document 中） componentUpdated-&gt;所在组件的 VNode 及其孩子的 VNode 全部更新时调用。 update-&gt;所在组件的 VNode 更新时调用,但是可能发生在其孩子的 VNode 更新之前。指令的值可能发生了改变也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 unbind-&gt; 只调用一次， 指令与元素解绑时调用 钩子函数参数 钩子函数的回调在被调用时，会自动传入一些参数el,bingding,vnode,oldVnode -el: 指令所绑定的元素，可以用来直接操作 DOM 。 binding: 一个对象，包含以下属性 name: 指令名，不包括 v- 前缀。 value: 指令的绑定值， 例如： v-my-directive=”1 + 1”, value 的值是 2。 oldValue: 指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。 expression: 绑定值的字符串形式。 例如 v-my-directive=”1 + 1” ， expression 的值是 “1 + 1”。 arg: 传给指令的参数。例如 v-my-directive:foo， arg 的值是 “foo”。 modifiers: 一个包含修饰符的对象。 例如： v-my-directive.foo.bar, 修饰符对象 modifiers 的值是 { foo: true, bar: true }。 vnode: Vue 编译生成的虚拟节点 oldVnode: 上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。 除了 el 之外，其它参数都应该是只读的，尽量不要修改他们。如果需要在钩子之间共享数据，建议通过元素的 dataset 来进行。12345678910111213141516171819&lt;div id=&quot;hook-arguments-example&quot; v-demo:foo.a.b=&quot;message&quot;&gt;&lt;/div&gt;Vue.directive(&apos;demo&apos;, &#123; bind: function (el, binding, vnode) &#123; var s = JSON.stringify el.innerHTML = &apos;name: &apos; + s(binding.name) + &apos;&lt;br&gt;&apos; + &apos;value: &apos; + s(binding.value) + &apos;&lt;br&gt;&apos; + &apos;expression: &apos; + s(binding.expression) + &apos;&lt;br&gt;&apos; + &apos;argument: &apos; + s(binding.arg) + &apos;&lt;br&gt;&apos; + &apos;modifiers: &apos; + s(binding.modifiers) + &apos;&lt;br&gt;&apos; + &apos;vnode keys: &apos; + Object.keys(vnode).join(&apos;, &apos;) &#125;&#125;);new Vue(&#123; el: &apos;#hook-arguments-example&apos;, data: &#123; message: &apos;hello!&apos; &#125;&#125;); 函数简写 大多数情况下，我们可能想在 bind 和 update 钩子上做重复动作，并且不想关心其它的钩子函数。 第二个参数不传入选项对象，而是一个函数，则表示此函数只会在bind和update时被调用123Vue.directive(&apos;color-swatch&apos;, function (el, binding) &#123; el.style.backgroundColor = binding.value&#125;) 对象字面量 如果指令需要多个值，可以传入一个 JavaScript 对象字面量12345&lt;div v-demo=&quot;&#123; color: &apos;white&apos;, text: &apos;hello!&apos; &#125;&quot;&gt;&lt;/div&gt;Vue.directive(&apos;demo&apos;, function (el, binding) &#123; console.log(binding.value.color) // =&gt; &quot;white&quot; console.log(binding.value.text) // =&gt; &quot;hello!&quot;&#125;) 混合-&gt;后期补插件-&gt;后期补单文件组件-&gt;后期补生产环境部署提示-&gt;后期补路由官方路由 Vue-router 简单路由 HTML5 History API12345678910111213141516171819const NotFound = &#123; template: &apos;&lt;p&gt;Page not found&lt;/p&gt;&apos; &#125;const Home = &#123; template: &apos;&lt;p&gt;home page&lt;/p&gt;&apos; &#125;const About = &#123; template: &apos;&lt;p&gt;about page&lt;/p&gt;&apos; &#125;const routes = &#123; &apos;/&apos;: Home, &apos;/about&apos;: About&#125;new Vue(&#123; el: &apos;#app&apos;, data: &#123; currentRoute: window.location.pathname &#125;, computed: &#123; ViewComponent () &#123; return routes[this.currentRoute] || NotFound &#125; &#125;, render (h) &#123; return h(this.ViewComponent) &#125;&#125;) 状态管理类 Flux 状态管理的官方实现 由于多个状态分散的跨越在许多组件和交互间各个角落，大型应用复杂度也经常逐渐增长。为了解决这个问题，Vue 提供 vuex： 我们有受到 Elm 启发的状态管理库 简单状态管理起步使用 Vue 应用中原始数据对象的实际来源 - 当访问数据对象时，一个 Vue 实例只是简单的代理访问。所以，如果你有一处需要被多个实例间共享的状态，可以简单地通过维护一份数据来实现共享 1234567const sourceOfTruth = &#123;&#125;const vmA = new Vue(&#123; data: sourceOfTruth&#125;)const vmB = new Vue(&#123; data: sourceOfTruth&#125;) 现在当 sourceOfTruth 发生变化，vmA 和 vmB 都将自动的更新引用它们的视图。子组件们的每个实例也会通过 this.$root.$data 去访问。现在我们有了唯一的实际来源，但是，调试将会变为噩梦。任何时间，我们应用中的任何部分，在任何数据改变后，都不会留下变更过的记录 为了解决这个问题，我们采用一个简单的 store 模式： 1234567891011121314var store = &#123; debug: true, state: &#123; message: &apos;Hello!&apos; &#125;, setMessageAction (newValue) &#123; if (this.debug) console.log(&apos;setMessageAction triggered with&apos;, newValue) this.state.message = newValue &#125;, clearMessageAction () &#123; if (this.debug) console.log(&apos;clearMessageAction triggered&apos;) this.state.message = &apos;&apos; &#125;&#125; 所有 store 中 state 的改变，都放置在 store 自身的 action 中去管理,这种集中式状态管理能够被更容易地理解哪种类型的 mutation 将会发生，以及它们是如何被触发。当错误出现时，我们现在也会有一个 log 记录 bug 之前发生了什么 此外，每个实例/组件仍然可以拥有和管理自己的私有状态：123456789101112var vmA = new Vue(&#123; data: &#123; privateState: &#123;&#125;, sharedState: store.state &#125;&#125;)var vmB = new Vue(&#123; data: &#123; privateState: &#123;&#125;, sharedState: store.state &#125;&#125;) 重要的是，注意你不应该在 action 中 替换原始的状态对象 - 组件和 store 需要引用同一个共享对象，mutation 才能够被观察 接着我们继续延伸约定，组件不允许直接修改属于 store 实例的 state，而应执行 action 来分发 (dispatch) 事件通知 store 去改变，我们最终达成了 Flux 架构 这样约定的好处是，我们能够记录所有 store 中发生的 state 改变，同时实现能做到记录变更 (mutation) 、保存状态快照、历史回滚/时光旅行的先进的调试工具 单元测试-&gt;后期补服务器端渲染-&gt;后期补Typescript支持-&gt;后期补","tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"how-does-timer-work","date":"2017-07-31T02:55:32.000Z","path":"2017/07/31/how-does-timer-work/","text":"最近看了些关于js中定时器原理解析的文章，所以特在此做一个记录本文带有个人理解，若有错误，望指正。 JS中的定时器(setTimeout)是如何工作的?定时器js中的setTimeout主要用来完成一些超时调用的任务，可以指定函数在未来的某个时间执行。123setTimeout(function()&#123; console.log('hi');&#125;,500); 理论情况下，’hi’会在500ms后被打印出来。 考虑下面这种情况12345console.log(1);setTimeout(function()&#123; console.log(2);&#125;,1000);console.log(3); 最后输出的顺序是1,3,2，你可能在想因为2被延迟了1000ms，所以最后输出的。 再看下面的12345console.log(1);setTimeout(function()&#123; console.log(2);&#125;,0);console.log(3); 这次我们将延迟的时间从1000调成了0，这次应该输出1,2,3了吧，但实际上最后的输出结果还是1,3,2这是为什么呢？要解释清楚这个就必须了解setTimeout的工作原理了。 工作原理js是单线程的，它同一时间它只能干一件事情。那你可能会问为什么不多弄几个线程，这样多管齐下，不是执行效率更高了吗？当时js的用途(交互、操作dom)决定了它只能是单线程的，如果多线程，就会存在多线程同步的问题。我在一个线程中删除了节点a，另一个线程在节点a上添加了一些内容，这样就会导致冲突，将一个简单的问题负责化了，所以最终js是单线程的。 解释下下面代码的执行过程12345console.log(1);setTimeout(function()&#123; console.log(2);&#125;,1000);console.log(3); 首先js中存在一个callstack(调用栈)的东西，它会将函数/方法压入(push)到栈中，并依次出栈(pop)执行。 默认上面代码外围有个main函数 main入栈 console.log(1)入栈 console.log(1)出栈并调用打印出1 setTimeout入栈 发现setTimeout是个延迟执行，出栈时，将需要延迟执行的回调函数交给浏览器的timer模块，timer模块负责观察延迟执行的回调函数是否到达触发条件，此时call stack会继续将后面的方法压入栈中 console.log(3)入栈 console.log(3)出栈并调用打印出3 main出栈 timer模块观察到延迟执行的函数到达触发条件后，将延迟执行的回调函数推入任务队列(task queue)中 当调用栈处于空闲状态时，它会将任务队列中的第一个任务压入callstack中，并调用，并一直重复这个过程直到任务队列为空。这个过程称为event loop 上面的setTimeout的延迟是1000，为0的时候其实也是一样的，只不过在timer模块中，它会立即到达触发条件，并被推入任务队列中，等待call stack空闲时，再压入到call stack中并调用。 上面是关于setTimeout延迟函数的调用过程，其实js中的事件、ajax的执行流程也一样(其实你会发现他们有个共同点，都有回调函数)。只不过setTimeout有一个具体的延迟时间，延迟时间到达了触发。事件是在用户进行某种操作后(点击)，立即将回调函数推入任务队列中，call stack空闲时取第一个并执行。ajax则是在返回数据后(满足触发条件)，将回调推入任务队列中，call stack空闲时取第一个并执行。 其实js的任务(代码)可以分为同步任务和异步任务(事件、ajax、setTimeout)，异步任务的回调一定是在所有同步任务都执行完了以后再被调用;12345console.log(1);setTimeout(function()&#123; console.log(2);&#125;,0);console.log(3); 如上面，即使setTimeout的延迟时间为0，它的回调函数也没有直接被调用，而是等到console.log(3)执行完，call stack为空时，再被调用执行的。所以setTimeour(fn,0)常用来在所有同步任务执行完后，尽可能早的执行； 再看下面的代码12345var req = new XMLHttpRequest();req.open('GET', url); req.onload = function ()&#123;&#125;; req.onerror = function ()&#123;&#125;; req.send(); 和12345var req = new XMLHttpRequest();req.open('GET', url);req.send();req.onload = function ()&#123;&#125;; req.onerror = function ()&#123;&#125;; 二者效果一样。 onload和onerror的位置无关紧要，不用担心先send了,load和error不会触发。因为load和error事件都属于异步任务(事件)，他们的回调函数一定是在所有同步任务完成后再被调用的。 总结： 通过上面可以发现，js中的异步任务(事件、ajax、setTimeout)，是需要call stack、浏览器中的对应模块(DOM Binding、network、timer)、task queue三者配合来完成异步任务； call stack负责压入待执行的方法/函数，遇到异步任务时，会将异步任务交给对应模块处理； 浏览器对应模块负责判断异步任务是否满足触发条件，若满足触发条件，则将异步任务的回调推入task queue中 task queue负责保存所有已经满足触发条件可以压入call stack中执行的异步任务回调。 当call stack空闲时，会将task queue中的第一个回调压入call stack中并执行，并一直循环这一过程直到task queue为空；-&gt;event loop 所有异步任务的回调一定是在所有同步任务都执行完了后再被调用 setTimeout(fn,0)无论写在哪，它的作用都是在所有同步任务执行完后，尽可能早的执行fn 参考链接 http://www.alloyteam.com/2015/10/turning-to-javascript-series-from-settimeout-said-the-event-loop-model/http://www.ruanyifeng.com/blog/2014/10/event-loop.htmlhttps://vimeo.com/96425312http://latentflip.com/loupe/","tags":[{"name":"timer","slug":"timer","permalink":"http://yoursite.com/tags/timer/"}]},{"title":"AngularJs-todoMVC","date":"2017-07-13T03:23:52.000Z","path":"2017/07/13/AngularJs-todoMVC/","text":"AngularJs-todoMVC 源码解释 github上的todoMVC仓库是一个帮助你选择前端MVC框架的项目项目中包含了绝大多数前端MVC框架实现Todo application的范例，让你能比较不同的框架实现同一个应用的差异。进而让你做出最佳选择。Todo application的具体效果，可以看这个http://todomvc.com/examples/angularjs/#/对于新手来说，是个很不错的学习范例。本文选取的是其中的angularJs范例，对其做了简单分析。分析源码已经上传至github，https://github.com/BryanAdamss/SourceSave/tree/master/TodoMVC/angularjs源码下载后，请在服务器中打开 目录结构主要根据功能不同，放在了不同文件夹中 angularjs/ js/ controllers/ todoCtrl.js-&gt;最主要的一个控制器 directives/ todoEscape.js-&gt;实现按下esc键，恢复到原先编辑状态的指令 todoFocus.js-&gt;再编辑input显示，聚焦的指令 services/ todoStorage.js-&gt;实现本地localStorge app.js-&gt;入口文件，包含了路由配置 node_modules/ angular/ angular-resource/ angular-route/ todomvc-app-css/-&gt;页面主要样式文件 todomvc-common/-&gt;一些通用的css样式和js helper index.html index.html相关说明全部写在注释里了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta name=\"renderer\" content=\"webkit\"&gt; &lt;meta name=\"keywords\" content=\"我是关键字\"&gt; &lt;meta name=\"description\" content=\"我是网站描述\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\"&gt; &lt;meta content=\"telephone=no,email=no\" name=\"format-detection\" /&gt; &lt;meta name=\"full-screen\" content=\"yes\"&gt; &lt;meta name=\"x5-fullscreen\" content=\"true\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0,maximum-scale=1.0,minimum-scale=1.0,user-scalable=no,minimal-ui\" /&gt; &lt;link rel=\"stylesheet\" href=\"node_modules/todomvc-common/base.css\"&gt; &lt;link rel=\"stylesheet\" href=\"node_modules/todomvc-app-css/index.css\"&gt; &lt;title&gt;Angular | TodoMVC&lt;/title&gt; &lt;style&gt; [ng-cloak] &#123; /*防止闪屏*/ display: none; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body ng-app=\"todomvc\"&gt; &lt;ng-view&gt;&lt;/ng-view&gt; &lt;script type=\"text/ng-template\" id=\"todomvc-index.html\"&gt; &lt;!-- 模板 --&gt; &lt;section id=\"todoapp\"&gt; &lt;header id=\"header\"&gt; &lt;h1&gt;todos&lt;/h1&gt; &lt;!-- form提交时，触发addTodo()事件 --&gt; &lt;form id=\"todo-form\" ng-submit=\"addTodo()\"&gt; &lt;!-- 新todo的输入框，值绑定到newTodo上，根据状态saving来禁用 --&gt; &lt;input id=\"new-todo\" placeholder=\"What needs to be done?\" ng-model=\"newTodo\" ng-disabled=\"saving\" autofocus&gt; &lt;/form&gt; &lt;/header&gt; &lt;!-- #main根据todos的长度来显示隐藏 --&gt; &lt;section id=\"main\" ng-show=\"todos.length\" ng-cloak&gt; &lt;!-- #toggle-all 布尔值绑定到allChecked上，点击时触发markAll --&gt; &lt;input id=\"toggle-all\" type=\"checkbox\" ng-model=\"allChecked\" ng-click=\"markAll(allChecked)\"&gt; &lt;label for=\"toggle-all\"&gt;Mark all as complete&lt;/label&gt; &lt;ul id=\"todo-list\"&gt; &lt;!-- 遍历每个todo，并通过statusFilter进行过滤，通过todo.completed、editedTodo来切换class --&gt; &lt;li ng-repeat=\"todo in todos | filter:statusFilter track by $index\" ng-class=\"&#123;completed: todo.completed, editing: todo == editedTodo&#125;\"&gt; &lt;div class=\"view\"&gt; &lt;!-- todo前的复选框，值绑定到todo.completed，change时触发toggleCompleted事件，并传入对应todo --&gt; &lt;input class=\"toggle\" type=\"checkbox\" ng-model=\"todo.completed\" ng-change=\"toggleCompleted(todo)\"&gt; &lt;!-- 展示用label，双击时触发editTodo，并传入对应todo --&gt; &lt;label ng-dblclick=\"editTodo(todo)\"&gt;&#123;&#123;todo.title&#125;&#125;&lt;/label&gt; &lt;!-- 删除按钮，点击时，移除对应todo --&gt; &lt;button class=\"destroy\" ng-click=\"removeTodo(todo)\"&gt;&lt;/button&gt; &lt;/div&gt; &lt;!-- 隐藏的再编辑表单，在表单提交时触发saveEdits --&gt; &lt;form ng-submit=\"saveEdits(todo, 'submit')\"&gt; &lt;!-- 再编辑input，值绑定到todo.title并不去除前后空格；按下esc时触发reverEdits事件，恢复到之前状态；失去焦点时自动提交；当双击展示用label时，todo和editedTodo相等，会触发todo-focus指令，显示再编辑input--&gt; &lt;input class=\"edit\" ng-trim=\"false\" ng-model=\"todo.title\" todo-escape=\"revertEdits(todo)\" ng-blur=\"saveEdits(todo, 'blur')\" todo-focus=\"todo == editedTodo\"&gt; &lt;/form&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/section&gt; &lt;footer id=\"footer\" ng-show=\"todos.length\" ng-cloak&gt; &lt;!-- #todo-count 展示剩余待做todo数量 --&gt; &lt;span id=\"todo-count\"&gt;&lt;strong&gt;&#123;&#123;remainingCount&#125;&#125;&lt;/strong&gt; &lt;!-- 当count为1显示'item left'，否则显示'items left' --&gt; &lt;ng-pluralize count=\"remainingCount\" when=\"&#123; one: 'item left', other: 'items left' &#125;\"&gt;&lt;/ng-pluralize&gt; &lt;/span&gt; &lt;ul id=\"filters\"&gt; &lt;!-- 过滤状态，点击时触发$routeChangeSuccess事件，改变statusFilter，进而改变展示的数据 --&gt; &lt;li&gt; &lt;a ng-class=\"&#123;selected: status == ''&#125; \" href=\"#/\"&gt;All&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a ng-class=\"&#123;selected: status == 'active'&#125;\" href=\"#/active\"&gt;Active&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a ng-class=\"&#123;selected: status == 'completed'&#125;\" href=\"#/completed\"&gt;Completed&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;!-- 清除所有已完成todo，点击时触发clearCompletedTodos --&gt; &lt;button id=\"clear-completed\" ng-click=\"clearCompletedTodos()\" ng-show=\"completedCount\"&gt;Clear completed&lt;/button&gt; &lt;/footer&gt; &lt;/section&gt; &lt;/script&gt; &lt;!-- 资源文件 --&gt; &lt;script src=\"node_modules/todomvc-common/base.js\"&gt;&lt;/script&gt; &lt;script src=\"node_modules/angular/angular.js\"&gt;&lt;/script&gt; &lt;script src=\"node_modules/angular-route/angular-route.js\"&gt;&lt;/script&gt; &lt;script src=\"node_modules/angular-resource/angular-resource.js\"&gt;&lt;/script&gt; &lt;!-- 逻辑文件 --&gt; &lt;script src=\"js/app.js\"&gt;&lt;/script&gt; &lt;script src=\"js/controllers/todoCtrl.js\"&gt;&lt;/script&gt; &lt;script src=\"js/services/todoStorage.js\"&gt;&lt;/script&gt; &lt;script src=\"js/directives/todoFocus.js\"&gt;&lt;/script&gt; &lt;script src=\"js/directives/todoEscape.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; app.jsapp.js是入口文件，主要是创建了模块，并配置了路由12345678910111213141516171819202122232425262728293031/*global angular *//** * The main TodoMVC app module * * @type &#123;angular.Module&#125; */angular.module('todomvc', ['ngRoute', 'ngResource']) .config(['$routeProvider', function($routeProvider) &#123; 'use strict'; var routeConfig = &#123; controller: 'TodoCtrl', templateUrl: 'todomvc-index.html', // 指定模板 resolve: &#123; store: function(todoStorage) &#123; // 在跳转路由之前载入正确的module // Get the correct module (API or localStorage). return todoStorage.then(function(module) &#123; module.get(); // Fetch the todo records in the background. return module; &#125;); &#125; &#125; &#125;; // 路由跳转 $routeProvider .when('/', routeConfig) .when('/:status', routeConfig) .otherwise(&#123; redirectTo: '/' &#125;); &#125;]); todoStorage.js这个文件是一个服务，主要实现了数据在localStorge中的存储和读写其实这一块没怎么看懂，主要是不太理解ngResource模块的作用，不过大概知道是存储和读取数据用的123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165/*global angular *//** * Services that persists and retrieves todos from localStorage or a backend API * if available. * * They both follow the same API, returning promises for all changes to the * model. */// 这一块是懵逼的...大概就是将数据存储在localStorage中angular.module('todomvc') .factory('todoStorage', function($http, $injector) &#123; 'use strict'; // Detect if an API backend is present. If so, return the API module, else // hand off the localStorage adapter return $http.get('/api') .then(function() &#123; return $injector.get('api'); &#125;, function() &#123; return $injector.get('localStorage'); &#125;); &#125;).factory('api', function($resource) &#123; 'use strict'; var store = &#123; todos: [], api: $resource('/api/todos/:id', null, &#123; update: &#123; method: 'PUT' &#125; &#125;), clearCompleted: function() &#123; var originalTodos = store.todos.slice(0); var incompleteTodos = store.todos.filter(function(todo) &#123; return !todo.completed; &#125;); angular.copy(incompleteTodos, store.todos); return store.api.delete(function() &#123;&#125;, function error() &#123; angular.copy(originalTodos, store.todos); &#125;); &#125;, delete: function(todo) &#123; var originalTodos = store.todos.slice(0); store.todos.splice(store.todos.indexOf(todo), 1); return store.api.delete(&#123; id: todo.id &#125;, function() &#123;&#125;, function error() &#123; angular.copy(originalTodos, store.todos); &#125;); &#125;, get: function() &#123; return store.api.query(function(resp) &#123; angular.copy(resp, store.todos); &#125;); &#125;, insert: function(todo) &#123; var originalTodos = store.todos.slice(0); return store.api.save(todo, function success(resp) &#123; todo.id = resp.id; store.todos.push(todo); &#125;, function error() &#123; angular.copy(originalTodos, store.todos); &#125;) .$promise; &#125;, put: function(todo) &#123; return store.api.update(&#123; id: todo.id &#125;, todo) .$promise; &#125; &#125;; return store;&#125;).factory('localStorage', function($q) &#123; 'use strict'; var STORAGE_ID = 'todos-angularjs'; var store = &#123; todos: [], _getFromLocalStorage: function() &#123; return JSON.parse(localStorage.getItem(STORAGE_ID) || '[]'); &#125;, _saveToLocalStorage: function(todos) &#123; localStorage.setItem(STORAGE_ID, JSON.stringify(todos)); &#125;, clearCompleted: function() &#123; var deferred = $q.defer(); var incompleteTodos = store.todos.filter(function(todo) &#123; return !todo.completed; &#125;); angular.copy(incompleteTodos, store.todos); store._saveToLocalStorage(store.todos); deferred.resolve(store.todos); return deferred.promise; &#125;, delete: function(todo) &#123; var deferred = $q.defer(); store.todos.splice(store.todos.indexOf(todo), 1); store._saveToLocalStorage(store.todos); deferred.resolve(store.todos); return deferred.promise; &#125;, get: function() &#123; var deferred = $q.defer(); angular.copy(store._getFromLocalStorage(), store.todos); deferred.resolve(store.todos); return deferred.promise; &#125;, insert: function(todo) &#123; var deferred = $q.defer(); store.todos.push(todo); store._saveToLocalStorage(store.todos); deferred.resolve(store.todos); return deferred.promise; &#125;, put: function(todo, index) &#123; var deferred = $q.defer(); store.todos[index] = todo; store._saveToLocalStorage(store.todos); deferred.resolve(store.todos); return deferred.promise; &#125; &#125;; return store;&#125;); todoEscape.js这是一个指令，主要完成按下esc键，恢复再编辑input到原先状态12345678910111213141516171819202122232425/*global angular *//** * Directive that executes an expression when the element it is applied to gets * an `escape` keydown event. */// esc键绑定事件// 当按下Escape键时，执行attrs.todoEscape的表达式。angular.module('todomvc') .directive('todoEscape', function() &#123; 'use strict'; var ESCAPE_KEY = 27; return function(scope, elem, attrs) &#123; // 直接返回一个函数，实际上就是link函数；在link函数中绑定事件 elem.bind('keydown', function(event) &#123; if (event.keyCode === ESCAPE_KEY) &#123; // 按下esc，触发attrs.todoEscape对应的事件 scope.$apply(attrs.todoEscape); &#125; &#125;); scope.$on('$destroy', function() &#123; // 销毁时，解除绑定 elem.unbind('keydown'); &#125;); &#125;; &#125;); todoFocus.js这个指令主要完成再编辑input的显示和聚焦1234567891011121314151617181920/*global angular *//** * Directive that places focus on the element it is applied to when the * expression it binds to evaluates to true */angular.module('todomvc') .directive('todoFocus', function todoFocus($timeout) &#123; 'use strict'; return function(scope, elem, attrs) &#123; // 在二次编辑的input上绑定事件 scope.$watch(attrs.todoFocus, function(newVal, oldVal) &#123; // 当双击时，newVal为true if (newVal) &#123; $timeout(function() &#123; elem[0].focus(); &#125;, 0, false); &#125; &#125;); &#125;; &#125;); todoCtrl.js这是重头性，关键性逻辑全写在这123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126/*global angular *//** * The main controller for the app. The controller: * - retrieves and persists the model via the todoStorage service * - exposes the model to the template and provides event handlers */angular.module('todomvc') .controller('TodoCtrl', function TodoCtrl($scope, $routeParams, $filter, store) &#123; 'use strict'; var todos = $scope.todos = store.todos; // 从localStorge中取出所有todo $scope.newTodo = ''; // 用来保存新创建的todo $scope.editedTodo = null; // 用来保存编辑过的todo $scope.$watch('todos', function() &#123; // 深度观察todos的值 $scope.remainingCount = $filter('filter')(todos, &#123; completed: false &#125;).length; // 更新未完成的todo数量 $scope.completedCount = todos.length - $scope.remainingCount; // 更新完成的todo数量 $scope.allChecked = !$scope.remainingCount; // 是否全部完成 &#125;, true); // Monitor the current route for changes and adjust the filter accordingly. $scope.$on('$routeChangeSuccess', function() &#123; // 观察路由跳转，并更新用来过滤的statusFilter var status = $scope.status = $routeParams.status || ''; $scope.statusFilter = (status === 'active') ? &#123; completed: false &#125; : (status === 'completed') ? &#123; completed: true &#125; : &#123;&#125;; &#125;); $scope.addTodo = function() &#123; // 输入框提交时触发 var newTodo = &#123; // 创建新todo title: $scope.newTodo.trim(), //newTodo是绑定在input输入框上 completed: false &#125;; if (!newTodo.title) &#123; // 空值，则不提交 return; &#125; $scope.saving = true; // saving用来标识input的禁用状态，为true则禁用 store.insert(newTodo) // 插入新todo .then(function success() &#123; // 成功则重置newTodo $scope.newTodo = ''; &#125;) .finally(function() &#123; $scope.saving = false; // 最后取消input的禁用状态 &#125;); &#125;; $scope.editTodo = function(todo) &#123; // 已添加的todo上双击时触发，会将双击的todo传入 $scope.editedTodo = todo; // 保存正在编辑的todo // Clone the original todo to restore it on demand. $scope.originalTodo = angular.extend(&#123;&#125;, todo); // 保留原先的todo，以备不时之需 &#125;; $scope.saveEdits = function(todo, event) &#123; // 再编辑input提交或者blur时触发 // Blur events are automatically triggered after the form submit event. // This does some unfortunate logic handling to prevent saving twice. if (event === 'blur' &amp;&amp; $scope.saveEvent === 'submit') &#123; // 提交时，会自动触发一次blur，所以手动阻止 $scope.saveEvent = null; return; &#125; $scope.saveEvent = event; // 保存事件类型(blur或submit) if ($scope.reverted) &#123; // 如果编辑后按esc，取消了编辑，则不保存 // Todo edits were reverted-- don't save. $scope.reverted = null; return; &#125; todo.title = todo.title.trim(); // 保存新编辑title if (todo.title === $scope.originalTodo.title) &#123; // title未发生改变，则不保存 $scope.editedTodo = null; return; &#125; store[todo.title ? 'put' : 'delete'](todo) .then(function success() &#123;&#125;, function error() &#123; // 保存出错，则恢复title todo.title = $scope.originalTodo.title; &#125;) .finally(function() &#123; // 最后，重置editedTodo $scope.editedTodo = null; &#125;); &#125;; $scope.revertEdits = function(todo) &#123; // todoEscape时触发，将再编辑input恢复到编辑前的状态，会传入需要恢复的todo todos[todos.indexOf(todo)] = $scope.originalTodo; $scope.editedTodo = null; $scope.originalTodo = null; $scope.reverted = true; &#125;; $scope.removeTodo = function(todo) &#123; // 删除todo store.delete(todo); &#125;; $scope.saveTodo = function(todo) &#123; // 保存todo store.put(todo); &#125;; $scope.toggleCompleted = function(todo, completed) &#123; // 切换完成状态 if (angular.isDefined(completed)) &#123; // 如果completed曾经定义过，则直接使用 todo.completed = completed; &#125; // 更新localStorge上的todo的complete store.put(todo, todos.indexOf(todo)) .then(function success() &#123;&#125;, function error() &#123; // 保存出错，则恢复 todo.completed = !todo.completed; &#125;); &#125;; $scope.clearCompletedTodos = function() &#123; // 清除所有已经完成的todo store.clearCompleted(); &#125;; $scope.markAll = function(completed) &#123; // 将所有todo置为已完成 todos.forEach(function(todo) &#123; if (todo.completed !== completed) &#123; $scope.toggleCompleted(todo, completed); &#125; &#125;); &#125;; &#125;);","tags":[{"name":"Angular","slug":"Angular","permalink":"http://yoursite.com/tags/Angular/"},{"name":"todoMVC","slug":"todoMVC","permalink":"http://yoursite.com/tags/todoMVC/"}]},{"title":"Maintainable-Javascript","date":"2017-06-30T02:39:31.000Z","path":"2017/06/30/Maintainable-Javascript/","text":"本文为阅读《编写可维护的Javascript》的笔记，记录了一些个人认为重要的点，带有一定个人理解，并未深入展开，如需详细了解可阅读原书籍。这本书，是从可维护性的角度出发，介绍了如何编写可维护性的js代码，读完，还是有收获的，特别是第二部分的编程实践，很基础，但也很实用。综合来看，还是一本不错的书籍，值得一看。PS:本书主要从可维护性的角度出发，有些写法并不一定是最优解，因人而异，取其精华，去其糟粕。本人github上有很多本人学习前端时保存的demo，都带有注释，适合新手入门。如果对大家有帮助。望star~https://github.com/BryanAdamss/SourceSave 《编写可维护的Javascript》笔记编程风格基本格式化 代码缩进 使用4空格代替tab；不同编辑器对于tab的解释不一样，有的是2空格长度，有的是4空格长度； 语句结尾 总是使用分号;结尾 行的长度 单行不超过80个字符 空行 使用空行分隔语义不同的代码段 命名 驼峰命名法 变量 名词开头-&gt;count、myName 函数 动词开头-&gt;(can、has、is、get、set)isEnabled、getName 构造函数 首字母大写123function Person(name)&#123; this.name=name;&#125; 常量 全大写，下划线区分12var MAX_COUNT=10, URL='https://github.com/BryanAdamss/SourceSave'; 直接量 字符串-&gt;单双引号皆可，不过个人推荐用单引号，因为在拼接html字符串时很方便) 数字-&gt;不省略小数点前后的数字 null-&gt;当做对象占位符使用 undefined-&gt;已声明但没有赋值的变量会获得此值 对象直接量 1234567// 不好的写法var book=new Object();book.title='Javascript';// 好的写法var book=&#123; title:'Javascript'&#125;; 数组直接量 1234// 不好的写法var colors=new Array('red','green');// 好的写法var colors=['red','green']; 注释 只在需要注释的时候才添加注释-&gt;只在需要让代码变得更清晰的时候添加注释 逻辑复杂难于理解的代码 可能被误认为错误的代码 语句和表达式 switch语句 js中的switch不同于其他语言，switch的条件和case从句可以是任意类型值，其他语言必须是原始值或者常量 with语句-&gt;不要使用 循环 for-&gt;在初始化中缓存遍历次数 123for(var i=0,len=arr.length;i&lt;len;i++)&#123; doSth();&#125; for-in-&gt;配合hasOwnProperty过滤非实例属性/方法 123456for(var prop in testObj)&#123; if(testObj.hasOwnProperty(prop))&#123; console.log('属性名为:'+prop); console.log('属性名对应的属性值为:'+testObj[prop]); &#125;&#125; forEach-&gt;针对数组用forEach 总结:对象(除数组)用for-in，数组用forEach，其他用for 变量、函数和运算符 变量声明 单var声明 123var a=3, b=4, c=5; 将局部变量的定义做为函数内第一条语句 1234567891011121314151617181920 function getName()&#123; var a=3, b=4, c=5; &#125; ``` - 函数声明 - 先声明再使用 - 函数内声明函数时，可将函数声明放在变量生命之后 ```javascript function getName()&#123; var a=3, b=4, c=5; function getOtherName()&#123; doSth(); &#125; getOtherName(); &#125; 立即调用函数 使用圆括号包裹123var a=(function()&#123; doSth();&#125;)(); 严格模式-&gt;只在局部使用 相等-&gt;使用=== eval-&gt;避免使用 原始包装类型-&gt;避免使用原始包装类型构造函数 编程实践UI层的松耦合 将javascript从css中抽离 禁用css表达式1234/*不好的写法*/.box&#123; width:expression(document.body.offsetWidth+\"px\");&#125; 将css从javascript中抽离 用js控制样式类，而不是直接操纵样式 当需要控制元素位置时，可直接用js操纵样式(top,left…) 将javascript从HTML中抽离 不要在html标签上用onclick=…，改用事件addEventListener 将HTML从javascript中抽离 使用客户端模板引擎，例如handlebars 避免使用全局变量 全局变量带来的问题 命名冲突 代码脆弱性 难以测试 意外的全局变量 未声明直接赋值了 12345function ()&#123; var a=3;// 局部变量 var b;// 局部变量 c=3;// 全局变量&#125; 如何避免 总是使用var来声明变量，即时是声明全局变量 单全局变量 只声明一个全局变量，所有功能全挂载到这个全局变量上 模块 规范CommonJs、AMD、CMD 对应实现NodeJs、RequireJs、SeaJs 零全局变量 使用立即函数包裹123(function(win)&#123; // doSth&#125;)(window); 事件处理 不好的写法 1234567function handleClick(event)&#123; var popup=document.getElementById('popup'); popup.style.left=event.clientX+'px'; popup.style.top=event.clientY+'px'; popup.className='reveal';&#125;ele.addEventListener('click',handleClick,false); 事件处理规则1 隔离应用逻辑-&gt;将应用(业务)逻辑从事件处理程序中抽离 1234567891011121314var MyApp=&#123; handleClick:function(event)&#123; this.showPopup(event); &#125;, showPopup:function(event)&#123; var popup=document.getElementById('popup'); popup.style.left=event.clientX+'px'; popup.style.top=event.clientY+'px'; popup.className='reveal'; &#125;&#125;;ele.addEventListener('click',function(event)&#123; MyApp.handleClick(event);&#125;,false); 不要分发事件对象-&gt;只传需要的信息 应用逻辑不应当依赖于event对象来正确完成功能 将event对象做为参数并不能告诉你event的哪些属性是有用的 测试时，需要重建event对象 最佳实践 让事件处理程序使用event对象来处理事件，然后拿到需要的数据传给应用逻辑 1234567891011121314var MyApp=&#123; handleClick:function(event)&#123; this.showPopup(event.clientX,event.clientY);// 只传需要的信息 &#125;, showPopup:function(x,y)&#123; var popup=document.getElementById('popup'); popup.style.left=x+'px'; popup.style.top=y+'px'; popup.className='reveal'; &#125;&#125;;ele.addEventListener('click',function(event)&#123; MyApp.handleClick(event);&#125;,false); 让事件处理程序成为接触到event对象的唯一的函数，事件处理程序应当在进入应用逻辑之前针对event对象执行任何必要的操作。包括阻止默认事件和冒泡。 12345678910111213141516var MyApp=&#123; handleClick:function(event)&#123;// 在事件处理程序中针对event进行必要的处理 event.preventDefault(); event.stopPropagation(); this.showPopup(event.clientX,event.clientY);// 只传需要的信息 &#125;, showPopup:function(x,y)&#123; var popup=document.getElementById('popup'); popup.style.left=x+'px'; popup.style.top=y+'px'; popup.className='reveal'; &#125;&#125;;ele.addEventListener('click',function(event)&#123; MyApp.handleClick(event);&#125;,false); 避免空比较 检测原始值的类型 字符串、数字、布尔、undefined-&gt;typeof 1234typeof 'a';// 'string'typeof 3;// 'number'typeof true;// 'boolean'typeof undefined;// 'undefined' null-&gt;一般不用于类型检测，除非null是一种可预期的页面时可用===和!==来判断是否为null值 1234var ele=document.getElementById('my-div');if(ele!==null)&#123;// 如果DOM元素不存在，则ele就为null，此时null是一个可预期的值，所以可以===或!==来判断 // doSth &#125; 检测引用值的类型 使用value instanceof constructor 123456789if(value instance Data)&#123; // doSth&#125;if(value instance RegExp)&#123; // doSth&#125;if(value instance Object)&#123; // doSth &#125; 但函数、数组不能用instanceof来判断，因为存在跨帧问题(cross-frame) 检测函数(判断某一引用值是否是函数(是否是函数类型)) 使用typeof 12function myFn()&#123;&#125;typeof myFn;// 'function' 使用typeof检测IE8及以下DOM元素的方法时，会返回’object’;退而求其次会使用in来判断；因为DOM明确定义，了解到对象成员如果存在则意味着它是一个方法 123if('querySelectorAll' in document)&#123; var imgs=document.querySelectorAll('img');&#125; 检测数组(判断某一引用值是否是数组(是否是数组类型)) 使用ES5的isArray 不支持的则使用Object.prototype.toString.call(value)1234567function isArray(value)&#123; if(typeof Array.isArray==='function')&#123; return Array.isArray(value); &#125;else&#123; return Object.prototype.toString.call(value)==='[object Array]'; &#125;&#125; 检测属性/方法存在性 使用prop in obj 检测属性/方法是否为实例属性-&gt;obj.hasOwnProperty(‘prop’) IE8及以下判断是否为实例属性-&gt;需先判断hasOwnProperty的存在性 总结 判断数据类型 原始值 字符串、数字、布尔、undefined-&gt;typeof 如if(typeof &#39;test&#39;===&#39;string&#39;){...} null-&gt;只有在null是一个可预期的值时，才用来比较，使用===，!== 引用值 自定义、非函数、非数组对象-&gt;使用obj instanceof constructor 如obj instanceof Data 函数/方法 非DOM对象的方法/函数-&gt;typeof 如typeof myFn===&#39;function&#39; DOM对象的方法-&gt;无法使用typeof，只能通过in判断它存在，然后直接使用 数组 支持isArray-&gt;Array.isArray(value) 不支持-&gt;Object.prototype.toString.call(value)===&#39;[object Array]&#39; 判断属性/方法存在性 一般属性/方法-&gt;统一使用in 实例属性存在性-&gt;统一使用hasOwnProperty IE8及以下判断实例属性存在性-&gt;先判断hasOwnProperty的存在性，再调用hasOwnProperty 将配置数据从代码中抽离 配置数据 URL 展现给用户的字符串 重复的值 设置(每页的配置项) 任何可能发生变更的值 抽离 将配置数据抽离成一个对象 1234var config=&#123; MSG_INVALID_VALUE:'不合法的值', URL:'https://github.com/BryanAdamss/SourceSave'&#125;; 将配置数据抽离成一个对象，并放在一个单独的文件中 抛出自定义错误 如果没有通过try-catch语句捕获，抛出任何值都将引发一个错误。如直接throw &#39;message&#39;，会引发一个错误 何时抛出错误 抛出错误最佳的地方是在工具函数中，如addClass()函数，它是通用脚本的一部分，会在很多地方使用。-&gt;在javascript类库中使用 错误类型 Error、EvalError、RangeError、ReferenceError、SyntaxError、TypeError、URIError 不是你的对象不要动 不要修改原生对象以及一些类库对象 原则：将已经存在的js对象当做工具函数库那样使用 不覆盖方法 不覆盖原对象的方法 不新增方法 不在不属于你的对象上添加方法 不删除方法 不要删除一个不是你的对象上的方法 更好方法 继承原对象，在其基础上扩充 阻止修改(锁定后，将无法解锁) 防止扩展-&gt;无法新增属性和方法，可删除 Object.preventExtension(obj); Object.isExtensible(); 密封对象-&gt;已存在的属性、方法无法被删除，可修改 Object.seal(obj); Object.isSealed(); 冻结对象-&gt;防止扩展+密封，无法删除，无法修改 Object.freeze(obj); Object.isFrozen(); 浏览器嗅探 UA检测 缺点 UA可以被修改 浏览器为了兼容性，都会包含其他浏览器的UA字符串 特性检测-&gt;根据功能(特性)来检测 不要进行特性推断-&gt;不要根据一个特性的是否存在去推断另一个特性是否存在 不要进行浏览器推断-&gt;不要根据一个特性的是否存在去推断是某种浏览器 优先级:特性检测&gt;UA检测 自动化文章第三部分介绍的是前端自动化方面的知识，但用的是Ant(需要JAVA环境)，由于现在用gulp的比较多，所以这一块就只是大概扫了一下。 流程 构建-&gt;验证-&gt;合并、加工-&gt;精简、压缩-&gt;文档化-&gt;自动化测试-&gt;集成","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"Angualr-guide","date":"2017-06-07T01:19:44.000Z","path":"2017/06/07/Angualr-guide/","text":"本文为自己学习angular的笔记，带有个人理解。学习的版本为1.2.32对应的源码在https://github.com/BryanAdamss/SourceSave/tree/master/AngularJs本仓库还包含大量本人前端练习用的demo，希望对大家有帮助。望star~ Angular学习笔记Angular适用场景 适合：大量CRUD(增删改查)操作的场景，如后台管理系统 不适合：游戏、大量UI操作的场景 DataBinding 双向：view、model之间会相互同步数据 Controller 在controller中做 设置$scope的初始状态 为$scope添加一些行为 不要在controller中做 手动操作DOM：controller中应该仅包含业务逻辑；如果在controller中添加表现相关逻辑，会严重影响测试；DOM操作应该封装在directives中；另外AngularJs中也封装了一些常用DOM操作指令，如ng-show等。 格式化输入： Use AngularJS form controls instead. 过滤输出： Use AngularJS filters instead. 传递数据或状态： Use AngularJS services instead. 管理其他组件的周期：例如在controller中创建services Services 特点 lazy实例化：只有当某个services被依赖时，它才会被实例化 单例：每个依赖services的component都会得到由service factory产生的service单实例的一个引用（service都是单例的，只要创建了一个Service，那么程序都在使用这唯一的Service) 以$开头的，都是内置服务，eg：$http service可以被用来传递数据、实现代码复用 创建并使用：通过service工厂函数来创建（factory函数）123456789101112131415 angular.module('myServiceModule', []). controller('MyController', ['$scope', 'notify', function($scope, notifyInstance) &#123;//3.这里notyfy被依赖，所以立马被实例化并将2处的匿名函数赋值给了notifyInstance $scope.callNotify = function(msg) &#123; notifyInstance (msg); &#125;; &#125;]).factory('notify', ['$window', function(win) &#123;// 1.这里注册了一个notify的服务，而且还依赖另一个内置服务$winodw，注意这里还只是注册一个notify的构造函数，并没有创建notify的实例 var msgs = []; return function(msg) &#123;// 2.return里的是当服务被加载(依赖时)返回的实例对象或函数 msgs.push(msg); if (msgs.length === 3) &#123; win.alert(msgs.join('\\n')); msgs = []; &#125; &#125;; &#125;]); Scope 特点 它只是一个普通的js对象 它指向了应用的model 它是表达式的执行环境context 它拥有和DOM一样的树形结构 它能监视表达式 它能传播事件 它提供了$watch来观察模型的变化 它提供了$apply来传播模型的变化 它可以嵌套以限制对应用程序组件属性的访问，同时提供对共享模型属性的访问。 它是controller和view间的胶水 层次结构（类似DOM的树形结构） 每个angularApp都有一个根scope，$rootScope，$rootScope有一个或多个子scope 查找某属性时，会像js作用域一样，逐层向上找 angularJs会在每个绑定了scope元素的class上添加ng-scope directive可以创建scope 获取DOM元素上绑定的scope 可以通过angular.element(dom元素).scope() 在chrome中，也可以通过 angular.element($0).scope()或者在选中一个dom元素后直接在控制台中$scope，就能得到相应dom上的$scope 可以通过安装 AngularJS Batarang插件来查看 事件传播 $emit(eventName) 向上传播事件 $broadcast(eventName) 向下传播事件 生命周期： Creation-&gt; Watcher registration-&gt; Model mutation-&gt; Mutation observation-&gt; Scope destruction DependencyInjection(DI) 使用 services、directives、filter、animation可以将”services”、”value”型组件作为依赖注入 123456789angular.module('myModule', []).factory('serviceId', ['depService', function(depService) &#123; // ...&#125;]).directive('directiveName', ['depService', function(depService) &#123; // ...&#125;]).filter('filterName', ['depService', function(depService) &#123; // ...&#125;]); controller可以将”services”、”value”型组件作为依赖注入，但他们还可以注入一些特殊的依赖如$scope 1234567someModule.controller('MyController', ['$scope', 'dep1', 'dep2', function($scope, dep1, dep2) &#123;...$scope.aMethod = function() &#123;...&#125;...&#125;]); 为module提供run、config方法时，可以使用DI config接收一个函数，函数可以注入”provider”、”constant”型组件；不可将”services”、”value”型注入到config中 run接收一个函数，函数可以注入”services”、”value”以及”constant”(常数)型组件；不可将”providers”型注入到run中12345angular.module('myModule', []).config(['depProvider', function(depProvider) &#123;// ...&#125;]).run(['depService', function(depService) &#123;// ...&#125;]); 依赖声明 行内数组声明(推荐、最优) 123someModule.controller('MyController', ['$scope', 'greeter', function($scope, greeter) &#123;// ...&#125;]); 使用$inject(可让controller通过js压缩) 12345var MyController = function($scope, greeter) &#123;// ...&#125;MyController.$inject = ['$scope', 'greeter'];someModule.controller('MyController', MyController); 隐式声明依赖(压缩时，会出错)-&gt;尽量避免用此方法 123someModule.controller('MyController', function($scope, greeter) &#123;// ...&#125;); 通过在ng-app指令所在html元素上添加 ng-strict-di指令，以限制隐式声明的使用(若使用隐式声明 ，会报错) Templates angularJS中的template是由html以及angularJs声明的元素及特性组成。angularJs通过controller组合model中的信息和模板以呈现动态的view给用户 templates中可以使用 directive {{}} filter form controller 1234567891011&lt;html ng-app&gt; &lt;!-- Body tag augmented with ngController directive --&gt; &lt;body ng-controller=\"MyController\"&gt; &lt;input ng-model=\"foo\" value=\"bar\"&gt; &lt;!-- Button tag with ngClick directive, and string expression 'buttonText' wrapped in \"&#123;&#123; &#125;&#125;\" markup --&gt; &lt;button ng-click=\"changeFoo()\"&gt;&#123;&#123;buttonText&#125;&#125;&lt;/button&gt; &lt;script src=\"angular.js\"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 在复杂的app中,可以将不同的模板放在单独的html中，然后通过ng-view来引用 Expressions 主要用在插值绑定(interpolation bindings)中，但也可以直接用在指令中；如ng-click=”functionExpression()”；以下都是合法的 1+2 a+b user.name items[index] 和Js的表达式的异同 context：js中的context一般是全局变量window；angular中表达式的context则是scope js中尝试计算未定义的属性，会报错；angular则不会直接报错，而是转为undefined或null 在angular表达式中可以用filter在展示数据前进行数据格式化 在angular的表达式中没有条件控制相关语句；如if、for等，但三元操作符中可以用 在angular的表达式中不能有函数声明，及时在ng-init指令中 在angular的表达式中不能创建正则表达式 在angular的表达式中不能通过new创建对象 在angular的表达式中不能使用位运算、void、逗号等操作符 如果想解析angularJs表达式，不要用eval，使用$eval 总结：如果想使用复杂js代码，可以将其封装在controller中，然后在view中调用。不推荐直接在表达式中书写大量代码； $event 在执行ng-click、ng-focus等指令时，会在表达式范围内将$event暴露出来，$event是类似jquery Event的对象 one-time绑定(数据只绑定一次) 优势：只绑定一次，可减少监视次数 使用：在变量前添加双冒号；类似{{::name}} 何时( 当表达式被设定后，就不会被改变时 ) 用在插值文本和特性时 1&lt;div name=\"attr: &#123;&#123;::color&#125;&#125;\"&gt;text: &#123;&#123;::name | uppercase&#125;&#125;&lt;/div&gt; 当用directive双向绑定数据并且参数不会改变时 1234567891011someModule.directive('someDirective', function() &#123; return &#123; scope: &#123; name: '=', color: '@' &#125;, template: '&#123;&#123;name&#125;&#125;: &#123;&#123;color&#125;&#125;' &#125;;&#125;);&lt;div some-directive name=\"::myName\" color=\"My color is &#123;&#123;::myColor&#125;&#125;\"&gt;&lt;/div&gt; 指令中包含表达式时 123&lt;ul&gt; &lt;li ng-repeat=\"item in ::items | orderBy:'name'\"&gt;&#123;&#123;item.name&#125;&#125;;&lt;/li&gt;&lt;/ul&gt; Interpolation 针对布尔attr，如disabled、required、selected、checked、readOnly、open，不要使用原生的，使用ng-disabled、ng-required… 使用ng-attr-xxx绑定任意特性，如ng-attr-cx；若为驼峰形式，则用下划线代替，如viewBox，则使用ng-attr-view_box Filters 在view中的语法 正常语法 1&#123;&#123; expression | filterName &#125;&#125; Filter Chain-&gt;用上一个filter的输出作为下一个filter的输入 1&#123;&#123; expression | filter1Name | filter2Name | ... &#125;&#125; 带参数 12&#123;&#123; expression | filterName:argument1:argument2:... &#125;&#125;如 &#123;&#123; 1234 | number:2 &#125;&#125; 当filter用在controller、services、directives上时，需采用Filter形式 需要在controller中使用number过滤器时1234angular.module('numberFilterExample', []).controller('ExampleController', ['numberFilter', function(numFilter) &#123; // ....&#125;]); 创建自定义filter 使用filter函数123456789101112angular.module('myReverseFilterApp', []).filter('reverse', function() &#123; return function(input) &#123;// return 一个函数 input = input || ''; var out = ''; for (var i = 0; i &lt; input.length; i++) &#123; out = input.charAt(i) + out; &#125; return out; &#125;;&#125;)// html中直接&#123;&#123; data | reverse&#125;&#125; 常用filter date日期格式-&gt; {{ now | date:'yyyy-MM-dd hh:mm:ss a' }} currency货币格式化 fiter对数组、字符串、对象等进行筛选显示 1234567891011$scope.city = [&#123; id: \"001\", name: \"上海\" &#125;, &#123; id: \"002\", name: \"北京\"&#125;];// view &#123;&#123;city&#125;&#125; &#123;&#123;city|filter:'上海'&#125;&#125;// 默认筛选出所有value值为'上海'的object &#123;&#123;city|filter:&#123;name:'北京'&#125; &#125;&#125;// 筛选出name为北京的object orderBy排序 {{city |orderBy:'id'}} 默认正序 {{city |orderBy:'-id'}} 反序 json 将对象解析成json，主要用来调试 Forms angularJs对表单域做了增强，添加了很多功能 使用ng-model就可以将表单的值和model进行双向绑定 使用novalidate屏蔽浏览器原生验证 angualrJs会添加一些class类，来标识验证的状态，根据这些验证状态class类，来写不同的样式 ng-valid：model验证通过 ng-invalid：model未验证通过 ng-valid-[ruleName]：ruleName的验证规则已通过 ng-invalid-[ruleName ]：ruleName的验证规则未通过 ng-pristine：这个表单域还没有交互过(未修改过) ng-dirty：这个表单域已经交互过(修改过) ng-touched：这个表单域 失去焦点 ng-untouched：这个表单域未失去焦点 ng-pending：异步验证还未完成 可以根据表单验证的一些状态，来辅助添加帮助信息 通过ng-model-options来设置一些属性 ng-model-options=”{ updateOn: ‘blur’ }” 在blur时更新model 延时更新model ng-model-options=”{ debounce: 500 }” ng-model-options=”{ updateOn: ‘default blur’, debounce: { default: 500, blur: 0 } }” 可通过编写directive来创建自己的验证规则、表单域 可以修改内置的验证规则 相关状态 字段错误信息-&gt;formName.fieldName.$error-&gt;验证通过的规则会显示false，未通过的显示true 字段无效信息-&gt;formName.fieldName.$invalid 字段有效信息-&gt;formName.fieldName.$valid 字段是否更改-&gt;formName.fieldName.$dirty 字段是否未更改-&gt;formName.fieldName.$pristine $scope.formName.$setPristine-&gt;将表单恢复到最初状态，class、$dirty等都被恢复 Directives 匹配 12345678&lt;div ng-controller=\"Controller\"&gt;&lt;!-- 下面这几种形式，都将input和model中name绑定起来了，绑定这个指令就匹配上了 --&gt; Hello &lt;input ng-model='name'&gt; &lt;hr/&gt;&lt;!-- 建议形式 --&gt; &lt;span ng-bind=\"name\"&gt;&lt;/span&gt; &lt;br/&gt;&lt;!-- 建议形式 --&gt; &lt;span ng:bind=\"name\"&gt;&lt;/span&gt; &lt;br/&gt; &lt;span ng_bind=\"name\"&gt;&lt;/span&gt; &lt;br/&gt; &lt;span data-ng-bind=\"name\"&gt;&lt;/span&gt; &lt;br/&gt; &lt;span x-ng-bind=\"name\"&gt;&lt;/span&gt; &lt;br/&gt;&lt;/div&gt; ng-attr-xxx-&gt;所有ng-attr开头的特性，最后都会转化到原生的特性上，建议不要在原生的特性上绑定值，都用ng-attr开头(因为某些原生特性和ng配合的不好) 123&lt;svg&gt; &lt;circle ng-attr-cx=\"&#123;&#123;cx&#125;&#125;\"&gt;&lt;/circle&gt;&lt;!-- 将&#123;&#123;cx&#125;&#125;绑定到了原生的cx上 --&gt;&lt;/svg&gt; 指令类型 A（attribute）、E（element）、M（comment）、C（class）;M和C不常用，如果需要兼容IE8，建议全部用A 1234&lt;my-dir&gt;&lt;/my-dir&gt;&lt;span my-dir=\"exp\"&gt;&lt;/span&gt;&lt;!-- directive: my-dir exp --&gt;&lt;span class=\"my-dir: exp;\"&gt;&lt;/span&gt; 注意：由于历史原因，浏览器在解析html标签和标签attribute时，会自动忽略大小写，统一使用小写形式；这就导致了，用驼峰形式定义的html标签（&lt;myTag&gt;）和特性会被转换为全小写（&lt;mytag&gt;）；那么用驼峰形式定义的指令在匹配E和A时，就找不到（无法匹配），为了解决这问题，ng会在定义时用的驼峰形式directive(“myTag”,xxx)转换成my-tag，这样在html中my-tag形式的标签和特性就会被匹配到。如果定义时没用驼峰形式(全小写)，则不会转换，直接匹配。驼峰形式的指令名在匹配M和C时不会存在转换-&gt;总结:在定义指令时如果用了驼峰形式匹配EA，则在html中使用时就要转换成短横线连接的形式如myTag转换成my-tag-&gt;最佳实践：ng中指令若用驼峰则html中用短横线连接； 创建指令 module.directive(directiveName,fn); 12345678910angular.module('docsSimpleDirective', []).controller('Controller', ['$scope', function($scope) &#123; $scope.customer = &#123; name: 'Naomi', address: '1600 Amphitheatre' &#125;;&#125;]).directive('myCustomer', function() &#123; return &#123;// 尽量都返回一个object，不要只返回一个函数 template: 'Name: &#123;&#123;customer.name&#125;&#125; Address: &#123;&#123;customer.address&#125;&#125;' // 除非你的模板很小，否则使用templateUrl来引入外部单独的模板html文件 &#125;;&#125;); templateUrl-&gt;除非你的模板很小，否则使用templateUrl来引入外部单独的模板html文件 当replace为true时，tpl文件内容必须被包裹在一个标签内，也即tpl文件只能有一个根标签；即不能存在有文本未被标签包裹，也不能存在多个根标签；因为替换的时候ng找不到一个唯一的节点做为替换节点，所以必须得有一个最外层的根节点；template也存在同样情况-&gt;最佳实践，任何情况下，都让模板文件包裹在一个根标签中，这样也方便文件的组织管理 可以在模板中使用$scope中的变量 templateUrl中可以指定type=text/ng-template的script为模板，只需要在templateUrl中写上script模板的id；注意：这个script模板必须在ng-app中，而且，若replact为true，则也需要一个根标签1234567891011angular.module('docsTemplateUrlDirective', []).controller('Controller', ['$scope', function($scope) &#123; $scope.customer = &#123; name: 'Naomi', address: '1600 Amphitheatre' &#125;;&#125;]).directive('myCustomer', function() &#123; return &#123; templateUrl: 'my-customer.html' &#125;;&#125;); restrict-&gt;设置指令的匹配模式(AEMC)；默认是AE（匹配attribute、element类型指令)；M和C不常用 123456789101112131415angular.module('docsRestrictDirective', []).controller('Controller', ['$scope', function($scope) &#123; $scope.customer = &#123; name: 'Naomi', address: '1600 Amphitheatre' &#125;;&#125;]).directive('myCustomer', function() &#123; return &#123; restrict: 'E', templateUrl: 'my-customer.html' &#125;;&#125;);// 什么情况下该用元素名，什么情况下该用属性名？ 当创建一个含有自己模板的组件的时候，建议使用元素名，常见情况是，当你想为你的模板创建一个DSL（特定领域语言）的时候。如果仅仅想为已有的元素添加功能，建议使用属性名.// 当需要创建一个自己的组件时-&gt;创建E型指令// 为已有元素添加新功能-&gt;创建A型指令 isolate scope 存在原因：若无独立作用域，则在一个作用域下，多个指令无法独立执行；使用独立作用域，可以将指令限制在独立的作用域下执行，互不干扰 创建：在创建directive时指定scope属性 1234567891011angular.module('docsIsolateScopeDirective', []).controller('Controller', ['$scope', function($scope) &#123; $scope.naomi = &#123; name: 'Naomi', address: '1600 Amphitheatre' &#125;; $scope.igor = &#123; name: 'Igor', address: '123 Somewhere' &#125;;&#125;]).directive('myCustomer', function() &#123; return &#123; restrict: 'E', scope: &#123; customerInfo: '=info' // 将customerInfo绑定到指令所在元素的info特性上，如果外面的特性也叫customerInfo，则可以直接使用缩写形式\"=\" &#125;, templateUrl: 'my-customer-iso.html' &#125;;&#125;); 独立作用域会隔离除你添加到scope: {} 对象中的数据模型之外的一切东西。 因为它可以阻止除你传入的数据模型之外的一切东西改变你内部数据模型的状态。 如果要使你的组件在应用范围内可重用，那么使用scope选项去创建一个独立作用域1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" ng-app=\"myApp\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div ng-controller=\"myController\"&gt; &#123;&#123;books&#125;&#125; &lt;div book-list book-a=\"books\" book-b=\"books\" book-c=\"&#123;&#123;title&#125;&#125;\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;script type=\"text/javascript\" src=\"js/angularjs.js\"&gt;&lt;/script&gt; &lt;script&gt; angular.module('myApp', []).directive(\"bookList\", function() &#123; return &#123; restrict: \"EAMC\", template: '&lt;div&gt;&lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt;&lt;ul&gt;&lt;li ng-repeat=\"book in books\"&gt;&#123;&#123;book.name&#125;&#125;&lt;/li&gt;&lt;/ul&gt; &lt;/div&gt;', // bookList指令中包含一个booAdd指令 replace: true, // scope: false,// scope为独立作用域，当为false，表示直接使用父级作用域，为true，表示创建一个作用域并继承自父作用域；当scope为一个对象时，则表示创建了一个不继承父作用域的继承链的独立作用域(就是可以访问到父作用域，但是无法访问到父作用域之上的作用域) scope: &#123; // &amp;attr表示作用域将父作用域的属性包装成一个函数，从而以函数的形式读写父作用域的属性；一般用在执行父作用域上的某个事件处理函数；若作用域和父作用域的属性名称一要，则可以使用简写形式&amp;,@和=同理 a: \"&amp;bookA\" // 会查找当前指令匹配的元素上的bookA特性，然后取得值books，并将books做为a调用的返回值进行返回； // =attr会将作用域上的属性和父级的作用域上的属性进行双向绑定，任何一方的修改都会修改另外一方 // b: \"=bookB\" // 会查找当前指令匹配的元素上的bookB特性，会将其值和b进行双向绑定 // @attr代表只能读取父级作用域上的值，单向的，并只能读取简单值，引用值不行，因为他最终得到的只会是简单值； // c: \"@bookC\" &#125;, controller: function($scope) &#123; $scope.books = $scope.a(); console.log($scope.a()); // $scope.books = $scope.b; // $scope.b.push(&#123; // name: \"nodeJs\" // &#125;); // console.log($scope.b); // $scope.title = $scope.c; // console.log($scope.c); &#125;, &#125; &#125;).controller('myController', ['$scope', function($scope) &#123; $scope.books = [&#123; name: \"php\" &#125;, &#123; name: \"js\" &#125;, &#123; name: \"java\" &#125;]; $scope.title = \"书籍\"; &#125;]); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; compile 主要用在DOM渲染之前( link之前) 改变DOM结构，并不需要$scope参数。它必须返回一个link函数，因此如果指令中compile和link都写了，则link会被覆盖-&gt;用的比较少123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" ng-app=\"myApp\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div ng-controller=\"myController\"&gt; &lt;div ng-repeat=\"user in users\" my-tag my-tag2&gt;&lt;/div&gt; &lt;/div&gt; &lt;script type=\"text/javascript\" src=\"js/angularjs.js\"&gt;&lt;/script&gt; &lt;script&gt; angular.module('myApp', []).directive('myTag', function() &#123; return &#123; restrict: \"EAMC\", template: '&lt;div&gt;&#123;&#123;user.name&#125;&#125;&lt;/div&gt;', replace: true, compile: function(tElement, tAttrs, transclude) &#123; // 主要用来在实际渲染之前修改DOM结构，compile必须返回一个link函数 // console.log(tElement); //返回匹配的当前类jQuery对象 // console.log(tAttrs); // 返回tElement上的所有attr // console.log(transclude); // 如果指令中transclue为true，则它返回的就是被transclude的原始数据 console.log(\"myTag 编译阶段\"); // 在实际渲染前变更DOM结构 tElement.append(angular.element(\"&lt;h1&gt;test&lt;/h1&gt;\")); return &#123; // 若在compile中直接return一个函数，则返回的是postLink函数 pre: function(scope, iElement, iAttrs, controller) &#123; // preLink是在compile阶段结束后，link阶段之前触发 console.log(\"myTag preLink\"); &#125;, post: function(scope, iElement, iAttrs, controller) &#123; // postLink是指令link后触发 console.log(\"myTag postLink\"); &#125; &#125; &#125;, link: function(scope, iElement, iAttrs, controller) &#123; // 主要在link中进行绑定事件和操纵DOM；一般定义了compile，就不会定义link了;此处的link其实就是compile中postLink console.log(\"因为上面执行了，compile，所以我不会再被执行了\"); &#125; &#125; &#125;).directive('myTag2', function() &#123; return &#123; restrict: \"EAMC\", compile: function(tElement, tAttrs, transclude) &#123; console.log(\"myTag2 编译阶段\"); return &#123; pre: function() &#123; console.log(\"myTag2 preLink\"); &#125;, post: function() &#123; console.log(\"myTag2 postLink\"); &#125; &#125; &#125; &#125; &#125;).controller(\"myController\", [\"$scope\", function($scope) &#123; $scope.users = [&#123; id: 10, name: \"张三\" &#125;, &#123; id: 20, name: \"李四\" &#125;]; &#125;]); &lt;/script&gt;&lt;/body&gt; &lt;/html&gt; link 主要在这里来操作DOM和添加事件 scope-&gt;指令所处的作用域(如果有独立作用域，则为独立作用域，否则值为父级的作用域); element-&gt;指令所匹配的那个元素 attrs-&gt;指令匹配元素的所有特性的集合 controller-&gt;指令需要依赖的controller实例123456789101112131415161718192021222324252627282930angular.module('docsTimeDirective', []).controller('Controller', ['$scope', function($scope) &#123; $scope.format = 'M/d/yy h:mm:ss a';&#125;]).directive('myCurrentTime', ['$interval', 'dateFilter', function($interval, dateFilter) &#123; function link(scope, element, attrs) &#123; var format, timeoutId; function updateTime() &#123; element.text(dateFilter(new Date(), format)); &#125; scope.$watch(attrs.myCurrentTime, function(value) &#123; format = value; updateTime(); &#125;); element.on('$destroy', function() &#123; $interval.cancel(timeoutId); &#125;); // start the UI update process; save the timeoutId for canceling timeoutId = $interval(function() &#123; updateTime(); // update DOM &#125;, 1000); &#125; return &#123; link: link &#125;;&#125;]); replace-&gt;是否替换匹配的元素 若为true则在找到匹配的元素后，会用指令中的template内容替换匹配的内容(包括被匹配的元素)；默认情况下，指令会在找到匹配的元素时，会将匹配元素的内容替换为指令中template的内容； 一般在匹配E时，会选择将其设置为true，因为一般E型指令都是创建新标签，是不符合规范的，所以会选择将其替换 transclude-&gt;主要用来处理指令嵌套 默认情况下，指令会替换匹配元素内部的内容，这样就无法实现指令的相互嵌套使用(原指令的内容会被新指令全部替换掉)； 当设置transclude为true时，则可以保留原先的指令模板以及对应的作用域；注意，在新指令的模板中要用ng-transclude保留老指令的内容； 123456789101112// jsangular.module('docsTransclusionDirective', []).controller('Controller', ['$scope', function($scope) &#123; $scope.name = 'Tobias';&#125;]).directive('myDialog', function() &#123; return &#123; restrict: 'E', transclude: true, scope: &#123;&#125;, templateUrl: 'my-dialog.html' &#125;;&#125;);// my-dialog.html&lt;h1&gt;新内容&lt;/h1&gt;&lt;div class=\"alert\" ng-transclude&gt;&lt;/div&gt; &lt;!-- 指定ng-transclude --&gt; 仅当你要创建一个包裹任意内容的指令的时候使用transclude: true 创建一个包裹任意内容的dialogBox 12345678910111213141516171819202122232425262728293031323334353637// jsangular.module('docsIsoFnBindExample', []).controller('Controller', ['$scope', '$timeout', function($scope, $timeout) &#123; $scope.name = 'Tobias'; $scope.message = ''; $scope.hideDialog = function(message) &#123; $scope.message = message; $scope.dialogIsHidden = true; $timeout(function() &#123; $scope.message = ''; $scope.dialogIsHidden = false; &#125;, 2000); &#125;;&#125;]).directive('myDialog', function() &#123; return &#123; restrict: 'E', transclude: true, scope: &#123; 'close': '&amp;onClose' // &amp;prop 用来绑定一个函数到独立作用域，允许独立作用域调用它，同时保留了函数的原来作用域；当你的指令想要开放一个API去绑定特定的行为，在scope选项中使用&amp;prop。 &#125;, templateUrl: 'my-dialog-close.html' &#125;;&#125;);// html&lt;div ng-controller=\"Controller\"&gt; &#123;&#123;message&#125;&#125; &lt;my-dialog ng-hide=\"dialogIsHidden\" on-close=\"hideDialog(message)\"&gt; Check out the contents, &#123;&#123;name&#125;&#125;! &lt;/my-dialog&gt;&lt;/div&gt;// my-dialog-close.html&lt;div class=\"alert\"&gt; &lt;a href class=\"close\" ng-click=\"close(&#123;message: 'closing for now'&#125;)\"&gt;&amp;times;&lt;/a&gt; &lt;div ng-transclude&gt;&lt;/div&gt; &lt;!-- 保留原先指令内容 --&gt;&lt;/div&gt; 创建添加事件的指令 12345678910111213141516171819202122232425262728293031323334353637angular.module('dragModule', []).directive('myDraggable', ['$document', function($document) &#123; return &#123; link: function(scope, element, attr) &#123; // 在link中为指令匹配的元素element绑定事件 var startX = 0, startY = 0, x = 0, y = 0; element.css(&#123; position: 'relative', border: '1px solid red', backgroundColor: 'lightgrey', cursor: 'pointer' &#125;); element.on('mousedown', function(event) &#123; // Prevent default dragging of selected content event.preventDefault(); startX = event.pageX - x; startY = event.pageY - y; $document.on('mousemove', mousemove); $document.on('mouseup', mouseup); &#125;); function mousemove(event) &#123; y = event.pageY - startY; x = event.pageX - startX; element.css(&#123; top: y + 'px', left: x + 'px' &#125;); &#125; function mouseup() &#123; $document.off('mousemove', mousemove); $document.off('mouseup', mouseup); &#125; &#125; &#125;;&#125;]); controller-&gt;指令中的controller属性可以用来完成指令间的相互通信 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// jsangular.module('docsTabsExample', []).directive('myTabs', function() &#123; return &#123; restrict: 'E', transclude: true, scope: &#123;&#125;, controller: ['$scope', function MyTabsController($scope) &#123; var panes = $scope.panes = []; $scope.select = function(pane) &#123; angular.forEach(panes, function(pane) &#123; pane.selected = false; &#125;); pane.selected = true; &#125;; this.addPane = function(pane) &#123;// 这个方法需要暴露给其他指令用 if (panes.length === 0) &#123; $scope.select(pane); &#125; panes.push(pane); &#125;; &#125;], templateUrl: 'my-tabs.html' &#125;;&#125;).directive('myPane', function() &#123; return &#123; require: '^^myTabs', // 依赖一个myTabs控制器，并在指令的父元素上查找这个控制器 restrict: 'E', transclude: true, scope: &#123; title: '@' // 相当于@title &#125;, link: function(scope, element, attrs, tabsCtrl) &#123; tabsCtrl.addPane(scope); &#125;, templateUrl: 'my-pane.html' &#125;;&#125;);// index.html&lt;my-tabs&gt; &lt;my-pane title=\"Hello\"&gt; &lt;p&gt;Lorem ipsum dolor sit amet&lt;/p&gt; &lt;/my-pane&gt; &lt;my-pane title=\"World\"&gt; &lt;em&gt;Mauris elementum elementum enim at suscipit.&lt;/em&gt; &lt;p&gt;&lt;a href ng-click=\"i = i + 1\"&gt;counter: &#123;&#123;i || 0&#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;/my-pane&gt;&lt;/my-tabs&gt;// tabs&lt;div class=\"tabbable\"&gt; &lt;ul class=\"nav nav-tabs\"&gt; &lt;li ng-repeat=\"pane in panes\" ng-class=\"&#123;active:pane.selected&#125;\"&gt; &lt;a href=\"\" ng-click=\"select(pane)\"&gt;&#123;&#123;pane.title&#125;&#125;&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;div class=\"tab-content\" ng-transclude&gt;&lt;/div&gt;&lt;/div&gt;// panel&lt;div class=\"tab-pane\" ng-show=\"selected\"&gt; &lt;h4&gt;&#123;&#123;title&#125;&#125;&lt;/h4&gt; &lt;div ng-transclude&gt;&lt;/div&gt;&lt;/div&gt; 当你想暴露一个API给其它的指令调用那就用controller,否则用link。 controllerAs-&gt;给指令中的controller起个别名，并可做controller中的第四个参数传入 priority-&gt;设置指令执行的优先级顺序(权重)；多个指令时，ng必须知道哪个先执行；默认ng-repeat优先级很高，为1000；-&gt;不常用 terminal-&gt;是否设置当前指令的权重priority 为结束界限；若为true，则节点上小于当前指令权重priority的指令不会被执行，相同权重的会执行 require-&gt;可以将其他指令传给自己，有以下值 directiveName-&gt;默认值，会从同一个元素上查找 ^directiveName-&gt;会在父级上查找 ?directiveName-&gt;表示指令是可选的，找不到也不会抛出异常 Animations 可参考https://css-tricks.com/animations-the-angular-way/ 无需引入任何模块，直接利用切换class配合css的过渡，来实现过渡动画-&gt;无法做到全兼容；-&gt;https://codepen.io/bdsimmons/pen/NqYjaV angualr中内置了$animate服务，可以提供简单的动画操作，enter、leave…-&gt;核心方法，ngAnimate模块也依赖这个核心服务 更强大的动画-&gt;引入ngAnimate模块；angualr没有直接包含动画模块(ngAnimate)，需要在引入angular.js后引入angular-animate.js 重点：ngAnimate动画的核心都是基于css，通过变换元素的class类配合过渡和animation进而实现动画，js动画除外 如何使用ngAnimate模块 整个app没有模块，则可以直接指定ng-app=”ngAnimate”来从ngAnimate模块启动app，也能有动画效果；-&gt;不推荐-&gt;http://www.runoob.com/try/try.php?filename=try_ng_animation 当做模块依赖来使用-&gt;var app=angular.module(“myApp”,[“ngAnimate”]); 当引入ngAnimate模块后，就会自动在一些指令执行的特殊时机，为元素添加上对应的class类，可以利用这个配合css实现动画 css过渡动画-&gt;需要设置动画的起点、终点的动画属性值；例如在.ng-enter上设置过渡动画初始值，在.ng-enter-active上设置过渡动画终点值-&gt;https://codepen.io/bdsimmons/pen/OPmNxXs css3Animation-&gt;css3Animtions，无需在2个class上设置动画，只需要在一个class上设置动画，并给定动画时间即可，所以如上面的只需要在.ng-enter上设置一个animation动画即可，无需在ng-enter-active在设置动画-&gt;https://codepen.io/anon/pen/NjJLMZ JS动画-&gt;当引入ngAnimate模块后 就自动在app上添加了animation方法，app.animation()；可以通过animation方法，实现动画-&gt;https://codepen.io/bdsimmons/pen/YXLZEw Module 基本用法 创建模块-&gt;用angular.module(“moduleName”,[“依赖的模块”]); 获取已有模块-&gt;用angular.module(“moduleName”);注意获取时，没有后面的依赖数组 让模块运作起来 声明一个module,然后在ng-app中引用它，即可让app从module中开始运行 模块划分 服务模块 指令模块 过滤器模块 一个应用的模块，依赖于上述的三个模块，而且包含应用的初始化及启动代码12345678910111213141516171819202122232425262728293031323334angular.module('xmpl.service', []) // 服务 .value('greeter', &#123; salutation: 'Hello', localize: function(localization) &#123; this.salutation = localization.salutation; &#125;, greet: function(name) &#123; return this.salutation + ' ' + name + '!'; &#125; &#125;) .value('user', &#123; load: function(name) &#123; this.name = name; &#125; &#125;);angular.module('xmpl.directive', []); // directiveangular.module('xmpl.filter', []);// filterangular.module('xmpl', ['xmpl.service', 'xmpl.directive', 'xmpl.filter']) // xmpl依赖service、directive、filter .run(function(greeter, user) &#123; // 初始化 // This is effectively part of the main method initialization code greeter.localize(&#123; salutation: 'Bonjour' &#125;); user.load('World'); &#125;) .controller('XmplController', function($scope, greeter, user)&#123; $scope.greeting = greeter.greet(user.name); &#125;); 模块是配置代码块和运行代码块的集合 配置代码块config-&gt;在 provider 注册和配置阶段执行（注：provider 是 ng 服务的一种）。只有 provider 和 constant 可以被注入配置代码块。这是为了防止服务在完全配置好之前被意外地初始化。-&gt;config为配置 执行代码块run-&gt;在 injector 被创建后执行，被用来启动整个应用。只有服务的实例对象以及 constant 可以被注入到执行代码块。这是为了防止在应用执行期间系统的更进一步的配置。-&gt;run为初始化 123456789angular.module('myModule', []). config(function(injectables) &#123; // provider型注入器 // 这是配置(config)代码块的范例，你可以有任意多个配置代码块 // 配置块中你只能注入Provider类（注意：不是由Provider类生成的实例）以及`constant` &#125;). run(function(injectables) &#123; // instance型注入器 // 这是运行(run)代码块的范例，你可以有任意个运行代码块 // 运行块中你只能注入Provider实例（注意：不是Provider类） &#125;); 配置代码块的快捷方法 123456789101112131415161718192021222324angular.module('myModule', []).value('a', 123).factory('a', function() &#123; return 123; &#125;).directive('directiveName', ...).filter('filterName', ...);// 等同于angular.module('myModule', []).config(function($provide, $compileProvider, $filterProvider) &#123; $provide.value('a', 123); $provide.factory('a', function() &#123; return 123; &#125;); $compileProvider.directive('directiveName', ...); $filterProvider.register('filterName', ...);&#125;);//.config等同于设置module函数的第三个参数angular.module(\"myModule\",[],[\"$provide\",\"$compileProvider\",\"$filterProvier\",function(provide,compileProvier,filterProvider)&#123; provide.value('a', 123); provide.factory('a', function() &#123; return 123; &#125;); compileProvider.directive('directiveName', ...); filterProvider.register('filterName', ...); &#125;]); 配置语句的执行顺序就是根据它们注册的顺序而定的。唯一的例外是 constant 的定义，它会被调整到所有配置块的最前面执行。 执行代码块 执行代码块是 ng 中最接近 main 函数的一个东西。执行代码块是应用启动时运行的代码。它在所有的服务被配置好以及 注入器(injector)被创建好之后执行。通常，执行代码块包含的代码都很难进行单元测试，正因为如此，它通常应该被丢在一个单独的模块中，这样我们可以在单元测试时忽略它。 模块依赖 A依赖B，则A的配置阶段要在B的配置阶段完成后进行，执行阶段同理，A的执行要在B的执行结束后。 注意每个模块只能被加载一次，即使有多个别的模块依赖它。 IE兼容性 1.3及以上不再支持IE8-&gt;所以如果需要支持IE8，请使用ng1.2.x-&gt;1.2的最新版本为1.2.32 IE7及以下不支持JSON.stringify-&gt;使用json2.js 123&lt;!--[if lte IE 7]&gt; &lt;script src=\"/path/to/json2.js\"&gt;&lt;/script&gt;&lt;![endif]--&gt; 在根元素上添加id=”ng-app”并结合ng-app=”xxModule”来启动app 1234&lt;!doctype html&gt;&lt;html xmlns:ng=\"http://angularjs.org\" id=\"ng-app\" ng-app=\"optionalModuleName\"&gt; ...&lt;/html&gt; 不要使用自定义节点 如，用attribute方式代替如ng-view 如果你由于语义或者第三方的Angular组件需要使用tag的方式的话,那么你必须按照如下步骤 make IE happy 1234567891011121314151617181920&lt;!doctype html&gt;&lt;html xmlns:ng=\"http://angularjs.org\" id=\"ng-app\" ng-app=\"optionalModuleName\"&gt;&lt;head&gt;&lt;!--[if lte IE 8]&gt; &lt;script&gt; document.createElement('ng-include'); document.createElement('ng-pluralize'); document.createElement('ng-view'); // Optionally these for CSS document.createElement('ng:include'); document.createElement('ng:pluralize'); document.createElement('ng:view'); &lt;/script&gt;&lt;![endif]--&gt;&lt;/head&gt;&lt;body&gt;...&lt;/body&gt;&lt;/html&gt; 重要的部分: xmlns:ng- 命名空间 - 你需要为每一个将使用的自定义tag注册一个命名空间(译者注:IE作为严格xml模式解析). document.createElement(yourTagName) - 自定义节点创建 - 由于这只是老版本的IE issues，所以你需要按条件加载这些脚本(IE低版本特有的条件注释)。对于每一个需要使用的没有注册命名空间以及非HTML定义的tag你需要利用它来预申明来make IE happy。 IE在处理关于非标准HTML tag 的问题主要由两类，每种类型又其自己的修复方式. If the tag name starts with my: prefix then it is considered an XML namespace and must have corresponding namespace declaration on 以my:为前缀的tag 考虑到严格的XML命名空间，你必须有相应的命名空间申明,如。 If the tag has no : but it is not a standard HTML tag, then it must be pre-created using document.createElement(‘my-tag’) 没有:的非标准HTML tag, 你需要使用document.createElement(&#39;my-tag&#39;)来预申明改节点(译者注:ie-shv)。 If you are planning on styling the custom tag with CSS selectors, then it must be pre-created using document.createElement(&#39;my-tag&#39;) regardless of XML namespace. 如果你希望采用CSS选择器的方式，那么你需要使用document.createElement(&#39;my-tag&#39;)预申明，忽略XML命名空间。 使用ng-style代替style=;后者在&lt;IE11的版本上无法运行 Angualr会在执行的某些时间点为标签添加上一些标识用的class类 ng-scope样式类会在创建了新作用域(Scope)的HTML元素上生成 ng-binding样式类会在ng-bind 或 绑定了任何数据的元素上生成 ng-invalid、ng-valid样式类会在进行了验证操作的所有input组件元素上生成 ng-pristine、ng-dirty angular的input指令给所有新的、还没有与用户交互的input元素附加上ng-pristine类，当用户有任何输入时，则附加上 ng-dirty. 国际化I18n和本地化L10n 引入特定的语言包 12345678&lt;html ng-app&gt;&lt;head&gt;…. &lt;script src=\"angular.js\"&gt;&lt;/script&gt; &lt;script src=\"i18n/angular-locale_zh-cn.js\"&gt;&lt;/script&gt;….&lt;/head&gt;&lt;/html&gt; 启动即bootstrap(这里bootstrap并非指ui库，bootstrap本身就有启动的意思) 自动启动 在angular要控制的范围最外层元素上添加ng-app指令 若未指定ng-app的具体值，会从默认模块开始启动；若指定了则从指定模块上启动 若需支持IE7，则还上在ng-app除添加id=”ng-app” 若需支持老式ng:风格的指令，则还需要在html上添加xml命名空间 1&lt;html xmlns:ng=\"http://angularjs.org\"&gt; 手动启动 使用angular.bootstrap 1234567891011121314151617181920&lt;!doctype html&gt;&lt;html&gt;&lt;body&gt; &lt;div ng-controller=\"MyController\"&gt; Hello &#123;&#123;greetMe&#125;&#125;! &lt;/div&gt; &lt;script src=\"http://code.angularjs.org/snapshot/angular.js\"&gt;&lt;/script&gt; &lt;script&gt; angular.module('myApp', []) .controller('MyController', ['$scope', function ($scope) &#123; $scope.greetMe = 'World'; &#125;]); angular.element(document).ready(function() &#123; angular.bootstrap(document, ['myApp']); // 手动启动 &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; bootstrap要在需要的module创建或加载完成后，才能调用 当手动启动app时，就不应当在用ng-app指令了 安全性 不要混用前台和后台的模板 不要使用用户的输入动态生成模板 Do not run user input through $scope.$eval 考虑使用ngCSP模块 Providers injector可以创建两种对象 专有对象-&gt;angular框架提供的，如controller、filter、directives等 服务-&gt;服务的API由开发人员自己制定-&gt;说明服务可以自己定制 injector需要知道如何创建服务，它需要一个”图纸” 图纸provider、factory、service、value、constant 最底层的图纸是provider，其余四种图纸都是基于provider的语法糖（在provider上又封装了一层） value图纸 用来创建可在运行阶段使用的常量 1234567891011var myApp = angular.module('myApp', []);myApp.value('clientId', 'a12345654321x');myApp.controller('DemoController', ['clientId', function DemoController(clientId) &#123; this.clientId = clientId;&#125;]);&lt;html ng-app=\"myApp\"&gt; &lt;body ng-controller=\"DemoController as demo\"&gt; Client ID: &#123;&#123;demo.clientId&#125;&#125;&lt;/body&gt;&lt;/html&gt; factory图纸 可以创建任何类型的服务 factory图纸相较value图纸增加了下面功能 可以有依赖 服务初始化 延迟/惰性初始化 factory图纸通过一个拥有0～n个参数(参数表示该服务对其他服务的依赖)的函数来创建服务，而函数返回值就是factory图纸创建的服务实例。 123myApp.factory('clientId', function clientIdFactory() &#123; return 'a12345654321x';// 返回的是服务的实例，不过这里clientId是一个常量，所以还是用value靠谱&#125;); 更适合用factory的例子，计算token 12345678910111213myApp.factory('apiToken', ['clientId', function apiTokenFactory(clientId) &#123;//将工厂方法命名为\"Factory\"是最佳实践（比如，apiTokenFactory）.虽然这种命名方式不是强制性的，但是它有助于浏览代码仓库或者在调试器里跟踪调用堆栈。 var encrypt = function(data1, data2) &#123; // NSA-proof加密算法： return (data1 + ':' + data2).toUpperCase(); &#125;; var secret = window.localStorage.getItem('myApp.secret'); var apiToken = encrypt(clientId, secret); return apiToken;&#125;]);``` service图纸 必须返回引用类型 自定义类型，并携带token 1234567891011function UnicornLauncher(apiToken) &#123; this.launchedCount = 0; this.launch() &#123; // 带上apiToken来发起远程调用 ... this.launchedCount++; &#125;&#125;myApp.factory('unicornLauncher', [\"apiToken\", function(apiToken) &#123;// 使用factory图纸来实现 return new UnicornLauncher(apiToken);&#125;]);myApp.service('unicornLauncher', [\"apiToken\", UnicornLauncher]);// 使用services语法更加简介，在内部还是会像factory一样，new 一下 provider图纸 注意必须实现$get方法 其它图纸的底层都是通过provider实现的，如factory 123function factory(name, factoryFn) &#123; return provider(name, &#123; $get: factoryFn &#125;); &#125; 当你需要为在应用运行前就必须设置好的全局配置项提供API时，你才需要用到provider图纸 假设我们的unicornLauncher服务是如此棒，以至于有好多应用都用到它。默认情况下，发射器将独角兽发射到太空中不需要任何保护屏障。但是在某些星球上，由于大气层非常厚，我们在将独角兽送去做星际旅行前必须将它们包裹在铝箔里，不然它们在穿越大气层时就被烧毁了。在一些应用里，需要设置发射器在每次发射时都使用铝箔屏蔽，如果我们能按需配置这一点那就太棒了。我们可以像下面这样让它变得可配置 12345678910111213myApp.provider('unicornLauncher', function UnicornLauncherProvider() &#123; var useTinfoilShielding = false; this.useTinfoilShielding = function(value) &#123; useTinfoilShielding = !!value; &#125;; this.$get = [\"apiToken\", function unicornLauncherFactory(apiToken) &#123; // 这里我们假设UnicornLauncher的构造函数也被改造得支持useTinfoilShielding参数了 return new UnicornLauncher(apiToken, useTinfoilShielding); &#125;];&#125;);myApp.config([\"unicornLauncherProvider\", function(unicornLauncherProvider) &#123; unicornLauncherProvider.useTinfoilShielding(true);&#125;]); constant图纸 用来创建可以在配置阶段使用的图纸 在angular开始创建服务之前，angular会配置和实例化所有provider，此时服务还不能用，因为他们还没有被创建(只是provider被实例化了，由provider创建并返回的服务此时还没有被创建)；一旦配置阶段结束，与provider的交互就被禁止了，而创建服务的过程开始；-&gt;所以在配置阶段，没有服务可用，这就导致了一些没有依赖用value写的常量也无法被使用-&gt;使用constant 假设在配置阶段提供了发射独角兽的星球名称，那么我们的unicornLauncher服务就能通过这个名字来标识一个独角兽。星球名是各个应用特有的，并且在应用运行时也会被各个控制器使用。我们可以像下面的代码那样把星球名定义为一个常量 123456myApp.constant('planetName', 'Greasy Giant');myApp.config(['unicornLauncherProvider', 'planetName', function(unicornLauncherProvider, planetName) &#123;// 在配置阶段，使用constant，因为value无法使用 unicornLauncherProvider.useTinfoilShielding(true); unicornLauncherProvider.stampText(planetName);&#125;]);``` value图纸也可以在控制器、模板、指令中使用 1234567891011myApp.controller('DemoController', [\"clientId\", \"planetName\", function DemoController(clientId, planetName) &#123; this.clientId = clientId; this.planetName = planetName;&#125;]);&lt;html ng-app=\"myApp\"&gt; &lt;body ng-controller=\"DemoController as demo\"&gt; Client ID: &#123;&#123;demo.clientId&#125;&#125; &lt;br&gt; Planet Name: &#123;&#123;demo.planetName&#125;&#125; &lt;/body&gt;&lt;/html&gt; 总结 injector用五种图纸来创建服务和专有对象 provider图纸是最底层的方法，其他的图纸都是基于其之上的语法糖 provider是最复杂的图纸类型，除非你正在构建需要全局配置的可复用代码，否则不要使用它 除了控制器，其他所有专用对象都是通过factory图纸来定义的(factory定义的，都是单例对象，而controller不是单例的) factory和service是最常用的图纸。它们之间的唯一区别就是service图纸存在一个new过程，所以最好返回一个构造函数，而factory可以创建任意类型 constant用在配置时，value用在运行时 12* 有直接使用new操作符预先初始化的开销。** 在配置阶段，服务对象是不能被访问的，但Provider实例是可以被访问的。（参见我们上面列举的unicornLauncherProvider例子）。 HTML Compiler HTML compiler 让开发者可以教浏览器一些新的语法技能 Compiler是 Angular 提供的一项服务，用来遍历DOM节点，查找特定的属性。编译过程分为两个阶段： 编译compile：遍历DOM节点，收集所有的指令，返回一个连接函数（link func） 连接link：将上一步收集到的每个指令与其所在的作用域（scope）连接生成一个实时视图。任何作用域中的模型改变都会实时在视图中反映出来，同时任何用户与视图的交互则会映射到作用域的模型中。这样，作用域中的数据模型就成了唯一的数据源。 指令directive 在编译过程中，遇到特定的HTML结构（也就是指令）时，指令所声明的行为操作会被触发 指令其实就是在编译器遍历DOM时碰到就需要执行的函数。 指令是如何被编译的 知道 Angular 的编译是在DOM节点上发生而非字符串上是很重要的。如果你自己手动调用 $compile 时，如果你传给它一个字符串，显然是要报错的。所以，在你传值给 $compile 之前，用 angular.element 将字符串转化为DOM。 编译流程 $compile 遍历DOM节点，匹配指令。 如果编译器发现某个元素匹配一个指令，那么这个指令就被添加到指令列表中（该列表与DOM元素对应）。一个元素可能匹配到多个指令（译注：也就是一个元素里面可能有多个指令）。 当所有指令都匹配到相应的元素时，编译器按照指令的 priority 属性来排列指令的编译顺序。 然后依次执行每个指令的 compile 函数。每个 compile 函数有一次更改该指令所对应的DOM模板的机会。然后，每个 compile 函数返回一个 link 函数。这些函数构成一个“合并的”连接函数，它会调用每个指令返回的 link 函数。 之后，$compile 调用第二步返回的连接函数，将模板和对应的作用域连接。而这又会依次调用连接函数中包含的每个指令对应的 link 函数，进而在各个DOM元素上注册监听器以及在相应的 scope 中设置对应的 $watchs。 用代码表示大概是下面流程 1234567891011121314151617181920212223var $compile = ...; // 已经存在的编译器var scope = ...;// 作用域var parent = ...; // DOM element where the compiled template can be appended，要被追加内容的DOM元素var html = '&lt;div ng-bind=\"exp\"&gt;&lt;/div&gt;';// 指令模板字符串// Step 1: parse HTML into DOM element，将html字符串解析为DOM，因为如果传给$compile字符串会报错var template = angular.element(html);// Step 2: compile the template，遍历整个template的DOM，找到所有指令，并按priority排序，并依次执行每个指令里的compile函数，每个compile函数会返回一个link函数，以供第三部用var linkFn = $compile(template);// Step 3: link the compiled template with the scope.，$compile会依次调用第二步返回的link函数，将模板和对应的作用域连接，会依次调用连接函数中包含的每个指令对应的 link 函数，进而在各个DOM元素上注册监听器以及在相应的 scope 中设置对应的 $watchesvar element = linkFn(scope);// Step 4: Append to DOM (optional)，可选的将一切就绪的dom追加到html中parent.appendChild(element); 总结：compile(找指令、排序、依次执行指令中compile函数并返回link函数)-&gt;执行每个指令中的link(DOM和作用域进行连接，设置事件监听并添加$watch) ngModel模块 当需要对数据进行深层处理时，可以用ngModel模块-&gt;一般是指令，这个ngModel对应的就是指令匹配元素上的ng-model 主要参考http://docs.ngnice.com/guidehttps://code.angularjs.org/1.2.32/docs/guide小猫杯的angular视频教程大漠穷秋的angular实战","tags":[{"name":"MVC","slug":"MVC","permalink":"http://yoursite.com/tags/MVC/"},{"name":"framework","slug":"framework","permalink":"http://yoursite.com/tags/framework/"},{"name":"Angular","slug":"Angular","permalink":"http://yoursite.com/tags/Angular/"}]},{"title":"Graphviz","date":"2017-03-24T08:55:14.000Z","path":"2017/03/24/Graphviz/","text":"Graphviz的安装以及基本使用介绍Graphviz可通过代码的方式生成图形 安装win下，可在官网http://http://www.graphviz.org/Download_windows.php下载，安装好后，手动将bin文件夹添加到环境变量即可。cmd 下键入dot -version,能出现Graphviz相关信息，则表示安装成功 生成图片12dot 源文件 -T 图片格式 -o 输出文件dot input.dot -T png -o output.png 可利用sublimeText的编译系统，实现图片实时预览 具体可参考这篇文章https://zhuanlan.zhihu.com/p/22820399 新建*.dot文件，然后编写相应代码，再编译就能生成图 基本语法123图类型 图名&#123; //其他&#125; 无向图1234567// 无向图用--表示节点之间的关系graph graphname &#123; a -- b--e; b -- c; b -- d; d -- a;&#125; 有向图123456// 有向图用a-&gt;b表示从a节点指向b节点digraph graphname&#123; a-&gt;b b-&gt;c a-&gt;c&#125; 定义一类节点123456digraph graphname&#123; T [label=&quot;Teacher&quot;,fontcolor=&quot;red&quot;] //定义节点T，并给予属性 P [label=&quot;Pupil&quot;] //定义节点P，并给予属性 T-&gt;P [label=&quot;Instructions&quot;, fontcolor=darkgreen] //定义边T-&gt;P，并给予属性 &#125; 设置属性(样式)12345678910111213141516171819202122232425262728293031323334353637graph G &#123; // 设置当前图和子图的属性 fontname=&quot;Microsoft JhengHei&quot;; fontsize=20; label=&quot;图&quot;; fontcolor=blue; //设置当前大括号范围内所有节点和边的属性，包含子图里面节点和边，类css中标签选择器 node[fontname=&quot;Microsoft JhengHei&quot;,fontsize=16]; edge[fontname=&quot;Microsoft JhengHei&quot;,fontsize=16]; // 可针对某一类节点设置属性，类css中class选择器 &quot;黑海&quot;[fontcolor=&quot;pink&quot;,style =&quot;filled&quot;,fillcolor = &quot;black&quot;]; &quot;黑海&quot; -- &quot;亚速海&quot;; &quot;黑海&quot; -- &quot;博斯普鲁斯海峡&quot;; &quot;达达尼尔海峡&quot; -- &quot;爱琴海&quot;; // 子图，用subgraph声明，并图名字前缀必须是cluster_否则识别失败；子图和父图的类型必须一致，父图是无向则子图也必须是无向，不能是有向 subgraph cluster_T &#123; // 设置子图的label属性，它的颜色继承父图的fontcolor=blue label=&quot;黑海海峡&quot;; &quot;达达尼尔海峡&quot; -- &quot;马尔马拉海&quot; -- &quot;博斯普鲁斯海峡&quot;; &#125; subgraph cluster_M &#123; label=&quot;黑海海峡&quot;; // 一对多，空格分隔 &quot;中部地中海&quot; -- &#123; &quot;爱琴海&quot; &quot;爱奥尼亚海&quot; &quot;西西里海峡&quot; &#125;; // 一对多，并设置每对都有一个label标签说明，并把字体颜色设置为red，线条颜色设置为yellow &quot;西部地中海&quot; -- &#123; &quot;西西里海峡&quot; &quot;第勒尼安海&quot; &quot;利古里亚海&quot; &quot;伊比利海&quot; &quot;阿尔沃兰海&quot; &#125;[label=&quot;标签说明&quot;,fontcolor=&quot;red&quot;,color=&quot;yellow&quot;]; &quot;爱奥尼亚海&quot; -- &quot;亚得里亚海&quot;; &quot;阿尔沃兰海&quot; -- &quot;直布罗陀海峡&quot;; &#125;&#125; 最终生成的 中文乱码保证.dot文件是以UTF-8编码通过设置fontname为中文字体来解决 参考链接 https://zhuanlan.zhihu.com/p/21993254https://zhuanlan.zhihu.com/p/22820399http://blog.csdn.net/xiajian2010/article/details/23748557http://www.tuicool.com/articles/vy2Ajyu","tags":[{"name":"Graphviz","slug":"Graphviz","permalink":"http://yoursite.com/tags/Graphviz/"},{"name":"绘图","slug":"绘图","permalink":"http://yoursite.com/tags/绘图/"}]},{"title":"mock-js","date":"2017-03-24T02:52:19.000Z","path":"2017/03/24/mock-js/","text":"Mock.js的基本用法如何使用123456789101112131415161718192021&lt;script type=\"text/javascript\" src=\"js/jquery-2.2.4.min.js\"&gt;&lt;/script&gt;&lt;!-- 引入Mock.js --&gt;&lt;script type=\"text/javascript\" src=\"js/mock-min.js\"&gt;&lt;/script&gt;&lt;script&gt; // 根据数据模板生成模拟数据。 Mock.mock('http://test.cn', &#123; \"userName\": \"@cname\", \"sex|1\": [\"男\", \"女\"], \"avator\": Mock.Random.image('100x100', '#894FC4', '#FFF', 'png', '头像') &#125;); // 模拟请求 $.ajax(&#123; url: 'http://test.cn', dataType: 'json' &#125;).done(function(data, status, xhr) &#123; // 请求成功，do something console.log(data); &#125;);&lt;/script&gt; 语法规范 数据模板定义规范（Data Template Definition，DTD） 数据占位符定义规范（Data Placeholder Definition，DPD） 数据模板定义语法1234&apos;name|rule&apos;:valuename:属性名rule:生成规则vale:属性值 注意 属性名(name)和生成规则(value)之间要用|分隔 生成规则(rule)不是必须的 最终生成值的类型和初始值由属性值(value)确定 属性值(value)中可以包含数据占位符(@占位符) 生成规则有7种格式 ‘name|min-max’: value ‘name|count’: value ‘name|min-max.dmin-dmax’: value ‘name|min-max.dcount’: value ‘name|count.dmin-dmax’: value ‘name|count.dcount’: value ‘name|+step’: value 生成规则的具体含义还要配合属性值(value)的类型来确定 规则 属性值(value)是String ‘name |min-max’:stringValue 通过重复stringValue，生成一个字符串。重复次数在[min,max]区间取值(次数大于等于min，小于等于max) ‘name |count’:stringValue 通过重复stringValue字符串count次，生成一个字符串。 属性值(value)是Number ‘name|+1’: numberValue 属性值自动加 1，初始值为numberValue。 ‘name|min-max’:numberValue 生成一个[min,max]之间的整数，此时属性值numberValue只是用来确定类型。 ‘name|min-max.dmin-dmax’: numberValue 生成一个整数部分在[min,max]间取值,小数保留的位数在[dmin,dmax]间取值的浮点数。同理此时属性值(value)也只是用来确定最终返回的数据的类型。 属性值是Boolean ‘name|1’: booleanValue 随机生成一个布尔值，值为 booleanValue 的概率是 1/2，值为 !booleanValue 的概率同样是 1/2。 ‘name|min-max’: booleanValue 随机生成一个布尔值，值为 booleanValue 的概率是 min / (min + max)，值为 !booleanValue 的概率是 max / (min + max)。此处属性值必须是Boolean类型，若为Number,则意义不同，见2 “test|1-2”:true 生成一个布尔值，为true的概率为1/3，为false概率为2/3 属性值是对象 Object ‘name|count’: object 返回的对象只包含从属性值object中随机选取的count个属性。 ‘name|min-max’: object 返回的对象只包含从属性值object中随机选取的min到max个属性。 属性值是数组 Array ‘name|1’: array 从属性值 array 中随机选取 1 个元素，作为最终值。 ‘name|+1’: array 从属性值 array 中顺序选取 1 个元素，作为最终值。 ‘name|min-max’: array 通过重复属性值array的值生成一个新数组，重复次数大于等于 min，小于等于 max。 ‘name|count’: array 通过重复属性值array的值生成一个新数组，重复次数为 count。 属性值是函数 Function ‘name’: function 执行函数 function，取其返回值作为最终的属性值，函数的上下文为属性 ‘name’ 所在的对象。 属性值是正则表达式 RegExp ‘name’: regexp 根据正则表达式 regexp 反向生成可以匹配它的字符串。用于生成自定义格式的字符串。 数据占位符定义语法Mock中的占位符和Sass中的placeholder很像。可以直接用在数据模板的属性值中。Mock中提供了很多预先定义的占位符，当然你也可以自定义占位符。 基本调用格式1234@占位符@占位符(参数 [, 参数])或者Mock.Random.占位符(参数 [, 参数]) 注意： 用@来标识其后的字符串是占位符。 占位符引用的是Mock.Random中的方法。 通过 Mock.Random.extend() 来扩展自定义占位符。 占位符也可以引用数据模板中的属性。 占位符会优先引用数据模板中的属性。 占位符支持相对路径和绝对路径。 预定义的占位符 Basic 提供一些基础占位符，如布尔值、整数、自然数、字符串等 Date 提供日期相关的占位符 Image 提供图片相关的占位符 Color 提供色值相关的占位符 Text 提供文本相关的占位符 Name 提供英文、中文名称相关的占位符 Web 提供了url、IP、protocol等相关的占位符 Address 提供省份、城市等地域相关信息的占位符 Helper 提供一些常用工具如字母转换大小写等相关占位符 Miscellaneous 提供了guid、身份证、自增等相关占位符号 自定义扩展符1234567891011121314Mock.Random.extend(&#123; constellation: function(date) &#123; var constellations = ['白羊座', '金牛座', '双子座', '巨蟹座', '狮子座', '处女座', '天秤座', '天蝎座', '射手座', '摩羯座', '水瓶座', '双鱼座'] return this.pick(constellations) &#125;&#125;)Mock.Random.constellation()// =&gt; \"水瓶座\"Mock.mock('@CONSTELLATION')// =&gt; \"天蝎座\"Mock.mock(&#123; constellation: '@CONSTELLATION'&#125;)// =&gt; &#123; constellation: \"射手座\" &#125; 更多API请参考 https://github.com/nuysoft/Mock/wiki‘ 更多实例请参考 http://mockjs.com/examples.html 可以一边看API、一边看实例，很容易就能上手","tags":[{"name":"mock","slug":"mock","permalink":"http://yoursite.com/tags/mock/"},{"name":"模拟数据","slug":"模拟数据","permalink":"http://yoursite.com/tags/模拟数据/"}]},{"title":"Markdown-Learning","date":"2017-03-23T03:21:16.000Z","path":"2017/03/23/Markdown-Learning/","text":"Markdown-Github Flavored Markdown常用操作Markdown拥有多种语法风格 标准风格-不支持表格 扩展风格-支持表格 github风格-Github Flavored Markdown它在标准风格上做了很多改进，如对表格的支持，针对不同编程语言实现代码高亮等 因为经常使用github，所以选择了Github Flavored Markdown风格。 Hexo搭建的博客也是使用github风格来解析markdown的。 win上支持Github Flavored Markdown风格的编辑器我常用的有:markdown pad2和typora。typora最让我心动的是支持快捷键创建表格，非常的方便。 标题12345# 一级标题## 二级标题，二级标题自带下划线### 三级标题...###### 六级标题 粗体斜体1234**两个星号为粗体***一个星号为斜体***粗中带 _斜_***内部换行用&lt;br&gt;,第二行* 引用1&gt; 这样引用 无序列表12345- 无序 - 我前面有2个空格，我能缩进 - 无序- 无序- 无序 有序列表12341. 第一行 1. 我前面有2个空格2. 第二行3. 第三行 任务列表123- [x] 我代表选中- [ ] 我没选中- [ ] 我没选中 图片与链接12[链接名](链接地址)![图片alt](图片地址) 代码段1使用`包裹的区域会形成代码段,区段内的 &amp;、&lt; 和 &gt; 都会被自动的转换成HTML实体，一般用在行内 代码块1使用三个`会产生格式化好的代码块,而 &amp;、&lt; 和 &gt; 也一样会自动转成HTML实体，一般用于一大段代码 代码块高亮123function show()&#123; console.log(\"我是带语法高亮的代码块，在三个`后添加上语言类型即可高亮\");&#125; 表格12345| Tables | Are | Cool || ------------- |:-------------:| -----:|| col 3 is | right-aligned | $1600 || col 2 is | centered | $12 || zebra stripes | are neat | $1 | Markdown中表格生成较为麻烦，建议使用编辑器快速生成,如typora中使用ctrl+t 分割线1***或--- 会产生分割线 还有很多东西因为没用到，所以不做介绍。更多的可以参考这 https://help.github.com/categories/writing-on-github/","tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://yoursite.com/tags/Markdown/"}]},{"title":"Handlebars-guide","date":"2017-03-17T10:48:09.000Z","path":"2017/03/17/Handlebars-guide/","text":"#HandleBars备忘 表达式{{xxx}} {{{xxxx}}}因为双大括号默认会进行HTML转义,将&lt;转换为&amp;lt;,通过三括号可以避免 Helper默认Helper{{#if a}}如果a为真执行这个{{/if}} {{#else}}否则执行这个{{/else}} {{#unless a}}当a为假的时候执行这个{{/unless}} {{#each obj}}遍历obj的每个属性{{/each}} #each内可以用{{@index}}获取当前遍历的索引值，用{{@key}}获取当前属性的属性名，用{{this}}可以获当前属性的值 如何获取父对象 可以通过{{../父对象某属性}}来获取父对象的某个属性，{{@../index}}获取父对象当前的所引值 {{#with obj}}xxx{{/with}}类似js中with，可改变作作用域，在each中也可通过#with 父对象名 来访问父对象 {{lookup xxx}}一般用来按照索引来找兄弟变量对应的值{{lookup ../父对象某属性 @index}}，查找父对象在当前索引下值 自定义Helper行级Helper语法{{helperName [普通值参数][hash值参数]}} {{customHelper \"My Text\" class=\"my-class\" visible=true counter=4}} Handlebars.registerHelper(&apos;customHelper&apos;, function() { console.log(arguments[0]);//==&gt;&quot;My Text&quot; console.log(arguments[1].hash);//==&gt;{class:&quot;my-class&quot;,visible:true,conter:4} }); 块级Helper语法{{#helperName context [普通值参数][hash值参数]}}xxxxxxxxx{{/helperName}} {{#customHelper nav \"normalValue\" class=\"my-class\" visible=true counter=4}} {{if name}} aaaaaa {{else}} bbbbbbb {{/if}} {{/customHelper}} Handlebars.registerHelper(&apos;customHelper&apos;, function(context,options) { console.log(arguments[0]);//==&gt;context console.log(arguments[1]);//==&gt;normalValue console.log(arguments[2]);//==&gt;options //说明在registerHelper内部,第二个参数匿名函数,只会存在3个实参，第一个为当前使用的上下文，第二个如果有则为一个普通值参数，另外一个就是封装了函数相关信息的options对象，它有hash(封装好一个或多个键值对参数)、fn(传入一个上下文，并在此上下文中执行customHelper模板中的{{#if}}到{{else}}中的模板)、inverse(同fn相反执行{{else}}到{{/if}}之间的)、name、data等属性。 }); 参考:http://cnodejs.org/topic/56a2e8b1cd415452622eed2dhttp://www.cnblogs.com/iyangyuan/archive/2013/12/12/3471227.html","tags":[{"name":"Handlebars","slug":"Handlebars","permalink":"http://yoursite.com/tags/Handlebars/"}]},{"title":"break-word、word-wrap、white-space","date":"2017-03-10T09:04:18.000Z","path":"2017/03/10/break-word-word-wrap-white-space/","text":"white-spacewhite-space的定义是用来设置如何处理元素中的空白。这里的空白指的是空格、tab制表符。 默认情况下，html中连续出现的多个空格会被合并成一个空格，Tab也会被替换成一个空格。回车换行(br换行不在内)会被忽略并将其替换成一个空格。当在容器剩余空间不足以容纳一个单词时，浏览器会在单词结束处自动换行。(默认情况下，是无法在一个单词内进行自动换行的，只能在结尾处换行。) 值 是否合并空白符(空格、tab) 是否忽略回车换行 是否允许自动换行 normal 合并 忽略 允许 nowrap 合并 忽略 不允许 pre 保留 保留 不允许 pre-wrap 保留 保留 允许 pre-line 合并 保留 允许 word-wrapword-wrap的定义是用来说明当一个不能被分开的字符串太长而不能填充其包裹盒时，为防止其溢出，浏览器是否允许这样的单词中断换行。既指明是否允许浏览器在单词内进行自动换行 值 解释 normal 在单词结束处换行 break-word 如果行内没有多余空间容纳该单词到行尾，则会强制将单词截断，在单词内进行换行 word-breakword-break指定了怎样在单词内断行 值 解释 normal 默认换行规则 break-all 对于non-CJK (中文/日文/韩文) 文本，可在任意字符间断行。 keep-all CJK 文本不断行。 Non-CJK 文本表现同 normal。 在white-space、word-wrap、word-break都为normal值时，既默认情况下时。一行的剩余空间不足以容纳一个单词时，浏览器会将这个单词挪到下一行显示。挪后如果这个单词比容器还长，则这个单词会直接溢出，因为默认情况下，浏览器是无法在单词内进行换行的。中文会一行空间不足以容纳一个字时，在字后进行换行 此时如果设置word-wrap:break-word，则会将这个长单词进行截断，从截断处进行换行。 可以发现第一行仍然有一点空间没有利用，此时就需要用到word-break:break-all; 可以说word-break:break-all是word-wrap:break-word的升级版本，它不会在剩余空间不够的时候将长单词挪到下一行，它将单词放在原位，并在容器边界处直接将这个长单词进行截断，然后换行。 将这三个属性，组合使用会怎么样 当设置了white-space:nowrap;时，word-wrap:break-word;和word-break:break-all;都将失效。文本将会强制在一行内显示 当同时设置word-wrap:break-word;和word-break:break-all时，word-break:break-all的效果会生效 word-spacing规定英文单词之间的间距 letter-spacing规定英文字符之间的间距 总结: 默认情况下，当一行的剩余空间不足以容纳某一单词时，浏览器会将此单词整体挪到下一行显示。此时，若这个单词超长(长度超出容器的宽度)，则此单词会直接溢出(此时上一行会留下一段空白)。 word-wrap:指明是否允许在长单词中换行，当设置其属性为break-word，则会把超过容器长度的单词进行截断，并换行(上一行留下的空白并不会被清除) word-break:当其设置break-all时，它是word-wrap:break-word的升级版，它能解决上一行留白问题。它会让单词先在当前行显示，当单词某个字符到达容器边界时，会直接在此字符出进行截断，并换行。这样就最大限度的利用了空间。 white-space:指定处理空白符的方式，比较有用的属性为nowrap，设置文本不换行。一般配合其它css实现文本过长省略号 word-spacing:规定英文单词之间的间距 letter-spacing:规定英文单词字符之间的间距 图片引用在自http://www.cnblogs.com/2050/archive/2012/08/10/2632256.html","tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]}]