[{"title":"Maintainable-Javascript","date":"2017-06-30T02:39:31.000Z","path":"2017/06/30/Maintainable-Javascript/","text":"本文为阅读《编写可维护的Javascript》的笔记，记录了一些个人认为重要的点，带有一定个人理解，并未深入展开，如需详细了解可阅读原书籍。这本书，是从可维护性的角度出发，介绍了如何编写可维护性的js代码，读完，还是有收获的，特别是第二部分的编程实践，很基础，但也很实用。综合来看，还是一本不错的书籍，值得一看。PS:本书主要从可维护性的角度出发，有些写法并不一定是最优解，因人而异，取其精华，去其糟粕。本人github上有很多本人学习前端时保存的demo，都带有注释，适合新手入门。如果对大家有帮助。望star~https://github.com/BryanAdamss/SourceSave 《编写可维护的Javascript》笔记编程风格基本格式化 代码缩进 使用4空格代替tab；不同编辑器对于tab的解释不一样，有的是2空格长度，有的是4空格长度； 语句结尾 总是使用分号;结尾 行的长度 单行不超过80个字符 空行 使用空行分隔语义不同的代码段 命名 驼峰命名法 变量 名词开头-&gt;count、myName 函数 动词开头-&gt;(can、has、is、get、set)isEnabled、getName 构造函数 首字母大写123function Person(name)&#123; this.name=name;&#125; 常量 全大写，下划线区分12var MAX_COUNT=10, URL='https://github.com/BryanAdamss/SourceSave'; 直接量 字符串-&gt;单双引号皆可，不过个人推荐用单引号，因为在拼接html字符串时很方便) 数字-&gt;不省略小数点前后的数字 null-&gt;当做对象占位符使用 undefined-&gt;已声明但没有赋值的变量会获得此值 对象直接量 1234567// 不好的写法var book=new Object();book.title='Javascript';// 好的写法var book=&#123; title:'Javascript'&#125;; 数组直接量 1234// 不好的写法var colors=new Array('red','green');// 好的写法var colors=['red','green']; 注释 只在需要注释的时候才添加注释-&gt;只在需要让代码变得更清晰的时候添加注释 逻辑复杂难于理解的代码 可能被误认为错误的代码 语句和表达式 switch语句 js中的switch不同于其他语言，switch的条件和case从句可以是任意类型值，其他语言必须是原始值或者常量 with语句-&gt;不要使用 循环 for-&gt;在初始化中缓存遍历次数 123for(var i=0,len=arr.length;i&lt;len;i++)&#123; doSth();&#125; for-in-&gt;配合hasOwnProperty过滤非实例属性/方法 123456for(var prop in testObj)&#123; if(testObj.hasOwnProperty(prop))&#123; console.log('属性名为:'+prop); console.log('属性名对应的属性值为:'+testObj[prop]); &#125;&#125; forEach-&gt;针对数组用forEach 总结:对象(除数组)用for-in，数组用forEach，其他用for 变量、函数和运算符 变量声明 单var声明 123var a=3, b=4, c=5; 将局部变量的定义做为函数内第一条语句 1234567891011121314151617181920 function getName()&#123; var a=3, b=4, c=5; &#125; ``` - 函数声明 - 先声明再使用 - 函数内声明函数时，可将函数声明放在变量生命之后 ```javascript function getName()&#123; var a=3, b=4, c=5; function getOtherName()&#123; doSth(); &#125; getOtherName(); &#125; 立即调用函数 使用圆括号包裹123var a=(function()&#123; doSth();&#125;)(); 严格模式-&gt;只在局部使用 相等-&gt;使用=== eval-&gt;避免使用 原始包装类型-&gt;避免使用原始包装类型构造函数 编程实践UI层的松耦合 将javascript从css中抽离 禁用css表达式1234/*不好的写法*/.box&#123; width:expression(document.body.offsetWidth+\"px\");&#125; 将css从javascript中抽离 用js控制样式类，而不是直接操纵样式 当需要控制元素位置时，可直接用js操纵样式(top,left…) 将javascript从HTML中抽离 不要在html标签上用onclick=…，改用事件addEventListener 将HTML从javascript中抽离 使用客户端模板引擎，例如handlebars 避免使用全局变量 全局变量带来的问题 命名冲突 代码脆弱性 难以测试 意外的全局变量 未声明直接赋值了 12345function ()&#123; var a=3;// 局部变量 var b;// 局部变量 c=3;// 全局变量&#125; 如何避免 总是使用var来声明变量，即时是声明全局变量 单全局变量 只声明一个全局变量，所有功能全挂载到这个全局变量上 模块 规范CommonJs、AMD、CMD 对应实现NodeJs、RequireJs、SeaJs 零全局变量 使用立即函数包裹123(function(win)&#123; // doSth&#125;)(window); 事件处理 不好的写法 1234567function handleClick(event)&#123; var popup=document.getElementById('popup'); popup.style.left=event.clientX+'px'; popup.style.top=event.clientY+'px'; popup.className='reveal';&#125;ele.addEventListener('click',handleClick,false); 事件处理规则1 隔离应用逻辑-&gt;将应用(业务)逻辑从事件处理程序中抽离 1234567891011121314var MyApp=&#123; handleClick:function(event)&#123; this.showPopup(event); &#125;, showPopup:function(event)&#123; var popup=document.getElementById('popup'); popup.style.left=event.clientX+'px'; popup.style.top=event.clientY+'px'; popup.className='reveal'; &#125;&#125;;ele.addEventListener('click',function(event)&#123; MyApp.handleClick(event);&#125;,false); 不要分发事件对象-&gt;只传需要的信息 应用逻辑不应当依赖于event对象来正确完成功能 将event对象做为参数并不能告诉你event的哪些属性是有用的 测试时，需要重建event对象 最佳实践 让事件处理程序使用event对象来处理事件，然后拿到需要的数据传给应用逻辑 1234567891011121314var MyApp=&#123; handleClick:function(event)&#123; this.showPopup(event.clientX,event.clientY);// 只传需要的信息 &#125;, showPopup:function(x,y)&#123; var popup=document.getElementById('popup'); popup.style.left=x+'px'; popup.style.top=y+'px'; popup.className='reveal'; &#125;&#125;;ele.addEventListener('click',function(event)&#123; MyApp.handleClick(event);&#125;,false); 让事件处理程序成为接触到event对象的唯一的函数，事件处理程序应当在进入应用逻辑之前针对event对象执行任何必要的操作。包括阻止默认事件和冒泡。 12345678910111213141516var MyApp=&#123; handleClick:function(event)&#123;// 在事件处理程序中针对event进行必要的处理 event.preventDefault(); event.stopPropagation(); this.showPopup(event.clientX,event.clientY);// 只传需要的信息 &#125;, showPopup:function(x,y)&#123; var popup=document.getElementById('popup'); popup.style.left=x+'px'; popup.style.top=y+'px'; popup.className='reveal'; &#125;&#125;;ele.addEventListener('click',function(event)&#123; MyApp.handleClick(event);&#125;,false); 避免空比较 检测原始值的类型 字符串、数字、布尔、undefined-&gt;typeof 1234typeof 'a';// 'string'typeof 3;// 'number'typeof true;// 'boolean'typeof undefined;// 'undefined' null-&gt;一般不用于类型检测，除非null是一种可预期的页面时可用===和!==来判断是否为null值 1234var ele=document.getElementById('my-div');if(ele!==null)&#123;// 如果DOM元素不存在，则ele就为null，此时null是一个可预期的值，所以可以===或!==来判断 // doSth &#125; 检测引用值的类型 使用value instanceof constructor 123456789if(value instance Data)&#123; // doSth&#125;if(value instance RegExp)&#123; // doSth&#125;if(value instance Object)&#123; // doSth &#125; 但函数、数组不能用instanceof来判断，因为存在跨帧问题(cross-frame) 检测函数(判断某一引用值是否是函数(是否是函数类型)) 使用typeof 12function myFn()&#123;&#125;typeof myFn;// 'function' 使用typeof检测IE8及以下DOM元素的方法时，会返回’object’;退而求其次会使用in来判断；因为DOM明确定义，了解到对象成员如果存在则意味着它是一个方法 123if('querySelectorAll' in document)&#123; var imgs=document.querySelectorAll('img');&#125; 检测数组(判断某一引用值是否是数组(是否是数组类型)) 使用ES5的isArray 不支持的则使用Object.prototype.toString.call(value)1234567function isArray(value)&#123; if(typeof Array.isArray==='function')&#123; return Array.isArray(value); &#125;else&#123; return Object.prototype.toString.call(value)==='[object Array]'; &#125;&#125; 检测属性/方法存在性 使用prop in obj 检测属性/方法是否为实例属性-&gt;obj.hasOwnProperty(‘prop’) IE8及以下判断是否为实例属性-&gt;需先判断hasOwnProperty的存在性 总结 判断数据类型 原始值 字符串、数字、布尔、undefined-&gt;typeof 如if(typeof &#39;test&#39;===&#39;string&#39;){...} null-&gt;只有在null是一个可预期的值时，才用来比较，使用===，!== 引用值 自定义、非函数、非数组对象-&gt;使用obj instanceof constructor 如obj instanceof Data 函数/方法 非DOM对象的方法/函数-&gt;typeof 如typeof myFn===&#39;function&#39; DOM对象的方法-&gt;无法使用typeof，只能通过in判断它存在，然后直接使用 数组 支持isArray-&gt;Array.isArray(value) 不支持-&gt;Object.prototype.toString.call(value)===&#39;[object Array]&#39; 判断属性/方法存在性 一般属性/方法-&gt;统一使用in 实例属性存在性-&gt;统一使用hasOwnProperty IE8及以下判断实例属性存在性-&gt;先判断hasOwnProperty的存在性，再调用hasOwnProperty 将配置数据从代码中抽离 配置数据 URL 展现给用户的字符串 重复的值 设置(每页的配置项) 任何可能发生变更的值 抽离 将配置数据抽离成一个对象 1234var config=&#123; MSG_INVALID_VALUE:'不合法的值', URL:'https://github.com/BryanAdamss/SourceSave'&#125;; 将配置数据抽离成一个对象，并放在一个单独的文件中 抛出自定义错误 如果没有通过try-catch语句捕获，抛出任何值都将引发一个错误。如直接throw &#39;message&#39;，会引发一个错误 何时抛出错误 抛出错误最佳的地方是在工具函数中，如addClass()函数，它是通用脚本的一部分，会在很多地方使用。-&gt;在javascript类库中使用 错误类型 Error、EvalError、RangeError、ReferenceError、SyntaxError、TypeError、URIError 不是你的对象不要动 不要修改原生对象以及一些类库对象 原则：将已经存在的js对象当做工具函数库那样使用 不覆盖方法 不覆盖原对象的方法 不新增方法 不在不属于你的对象上添加方法 不删除方法 不要删除一个不是你的对象上的方法 更好方法 继承原对象，在其基础上扩充 阻止修改(锁定后，将无法解锁) 防止扩展-&gt;无法新增属性和方法，可删除 Object.preventExtension(obj); Object.isExtensible(); 密封对象-&gt;已存在的属性、方法无法被删除，可修改 Object.seal(obj); Object.isSealed(); 冻结对象-&gt;防止扩展+密封，无法删除，无法修改 Object.freeze(obj); Object.isFrozen(); 浏览器嗅探 UA检测 缺点 UA可以被修改 浏览器为了兼容性，都会包含其他浏览器的UA字符串 特性检测-&gt;根据功能(特性)来检测 不要进行特性推断-&gt;不要根据一个特性的是否存在去推断另一个特性是否存在 不要进行浏览器推断-&gt;不要根据一个特性的是否存在去推断是某种浏览器 优先级:特性检测&gt;UA检测 自动化文章第三部分介绍的是前端自动化方面的知识，但用的是Ant(需要JAVA环境)，由于现在用gulp的比较多，所以这一块就只是大概扫了一下。 流程 构建-&gt;验证-&gt;合并、加工-&gt;精简、压缩-&gt;文档化-&gt;自动化测试-&gt;集成","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"Angualr-guide","date":"2017-06-07T01:19:44.000Z","path":"2017/06/07/Angualr-guide/","text":"本文为自己学习angular的笔记，带有个人理解。学习的版本为1.2.32对应的源码在https://github.com/BryanAdamss/SourceSave/tree/master/AngularJs本仓库还包含大量本人前端练习用的demo，希望对大家有帮助。望star~ Angular学习笔记Angular适用场景 适合：大量CRUD(增删改查)操作的场景，如后台管理系统 不适合：游戏、大量UI操作的场景 DataBinding 双向：view、model之间会相互同步数据 Controller 在controller中做 设置$scope的初始状态 为$scope添加一些行为 不要在controller中做 手动操作DOM：controller中应该仅包含业务逻辑；如果在controller中添加表现相关逻辑，会严重影响测试；DOM操作应该封装在directives中；另外AngularJs中也封装了一些常用DOM操作指令，如ng-show等。 格式化输入： Use AngularJS form controls instead. 过滤输出： Use AngularJS filters instead. 传递数据或状态： Use AngularJS services instead. 管理其他组件的周期：例如在controller中创建services Services 特点 lazy实例化：只有当某个services被依赖时，它才会被实例化 单例：每个依赖services的component都会得到由service factory产生的service单实例的一个引用（service都是单例的，只要创建了一个Service，那么程序都在使用这唯一的Service) 以$开头的，都是内置服务，eg：$http service可以被用来传递数据、实现代码复用 创建并使用：通过service工厂函数来创建（factory函数）123456789101112131415 angular.module('myServiceModule', []). controller('MyController', ['$scope', 'notify', function($scope, notifyInstance) &#123;//3.这里notyfy被依赖，所以立马被实例化并将2处的匿名函数赋值给了notifyInstance $scope.callNotify = function(msg) &#123; notifyInstance (msg); &#125;; &#125;]).factory('notify', ['$window', function(win) &#123;// 1.这里注册了一个notify的服务，而且还依赖另一个内置服务$winodw，注意这里还只是注册一个notify的构造函数，并没有创建notify的实例 var msgs = []; return function(msg) &#123;// 2.return里的是当服务被加载(依赖时)返回的实例对象或函数 msgs.push(msg); if (msgs.length === 3) &#123; win.alert(msgs.join('\\n')); msgs = []; &#125; &#125;; &#125;]); Scope 特点 它只是一个普通的js对象 它指向了应用的model 它是表达式的执行环境context 它拥有和DOM一样的树形结构 它能监视表达式 它能传播事件 它提供了$watch来观察模型的变化 它提供了$apply来传播模型的变化 它可以嵌套以限制对应用程序组件属性的访问，同时提供对共享模型属性的访问。 它是controller和view间的胶水 层次结构（类似DOM的树形结构） 每个angularApp都有一个根scope，$rootScope，$rootScope有一个或多个子scope 查找某属性时，会像js作用域一样，逐层向上找 angularJs会在每个绑定了scope元素的class上添加ng-scope directive可以创建scope 获取DOM元素上绑定的scope 可以通过angular.element(dom元素).scope() 在chrome中，也可以通过 angular.element($0).scope()或者在选中一个dom元素后直接在控制台中$scope，就能得到相应dom上的$scope 可以通过安装 AngularJS Batarang插件来查看 事件传播 $emit(eventName) 向上传播事件 $broadcast(eventName) 向下传播事件 生命周期： Creation-&gt; Watcher registration-&gt; Model mutation-&gt; Mutation observation-&gt; Scope destruction DependencyInjection(DI) 使用 services、directives、filter、animation可以将”services”、”value”型组件作为依赖注入 123456789angular.module('myModule', []).factory('serviceId', ['depService', function(depService) &#123; // ...&#125;]).directive('directiveName', ['depService', function(depService) &#123; // ...&#125;]).filter('filterName', ['depService', function(depService) &#123; // ...&#125;]); controller可以将”services”、”value”型组件作为依赖注入，但他们还可以注入一些特殊的依赖如$scope 1234567someModule.controller('MyController', ['$scope', 'dep1', 'dep2', function($scope, dep1, dep2) &#123;...$scope.aMethod = function() &#123;...&#125;...&#125;]); 为module提供run、config方法时，可以使用DI config接收一个函数，函数可以注入”provider”、”constant”型组件；不可将”services”、”value”型注入到config中 run接收一个函数，函数可以注入”services”、”value”以及”constant”(常数)型组件；不可将”providers”型注入到run中12345angular.module('myModule', []).config(['depProvider', function(depProvider) &#123;// ...&#125;]).run(['depService', function(depService) &#123;// ...&#125;]); 依赖声明 行内数组声明(推荐、最优) 123someModule.controller('MyController', ['$scope', 'greeter', function($scope, greeter) &#123;// ...&#125;]); 使用$inject(可让controller通过js压缩) 12345var MyController = function($scope, greeter) &#123;// ...&#125;MyController.$inject = ['$scope', 'greeter'];someModule.controller('MyController', MyController); 隐式声明依赖(压缩时，会出错)-&gt;尽量避免用此方法 123someModule.controller('MyController', function($scope, greeter) &#123;// ...&#125;); 通过在ng-app指令所在html元素上添加 ng-strict-di指令，以限制隐式声明的使用(若使用隐式声明 ，会报错) Templates angularJS中的template是由html以及angularJs声明的元素及特性组成。angularJs通过controller组合model中的信息和模板以呈现动态的view给用户 templates中可以使用 directive {{}} filter form controller 1234567891011&lt;html ng-app&gt; &lt;!-- Body tag augmented with ngController directive --&gt; &lt;body ng-controller=\"MyController\"&gt; &lt;input ng-model=\"foo\" value=\"bar\"&gt; &lt;!-- Button tag with ngClick directive, and string expression 'buttonText' wrapped in \"&#123;&#123; &#125;&#125;\" markup --&gt; &lt;button ng-click=\"changeFoo()\"&gt;&#123;&#123;buttonText&#125;&#125;&lt;/button&gt; &lt;script src=\"angular.js\"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 在复杂的app中,可以将不同的模板放在单独的html中，然后通过ng-view来引用 Expressions 主要用在插值绑定(interpolation bindings)中，但也可以直接用在指令中；如ng-click=”functionExpression()”；以下都是合法的 1+2 a+b user.name items[index] 和Js的表达式的异同 context：js中的context一般是全局变量window；angular中表达式的context则是scope js中尝试计算未定义的属性，会报错；angular则不会直接报错，而是转为undefined或null 在angular表达式中可以用filter在展示数据前进行数据格式化 在angular的表达式中没有条件控制相关语句；如if、for等，但三元操作符中可以用 在angular的表达式中不能有函数声明，及时在ng-init指令中 在angular的表达式中不能创建正则表达式 在angular的表达式中不能通过new创建对象 在angular的表达式中不能使用位运算、void、逗号等操作符 如果想解析angularJs表达式，不要用eval，使用$eval 总结：如果想使用复杂js代码，可以将其封装在controller中，然后在view中调用。不推荐直接在表达式中书写大量代码； $event 在执行ng-click、ng-focus等指令时，会在表达式范围内将$event暴露出来，$event是类似jquery Event的对象 one-time绑定(数据只绑定一次) 优势：只绑定一次，可减少监视次数 使用：在变量前添加双冒号；类似{{::name}} 何时( 当表达式被设定后，就不会被改变时 ) 用在插值文本和特性时 1&lt;div name=\"attr: &#123;&#123;::color&#125;&#125;\"&gt;text: &#123;&#123;::name | uppercase&#125;&#125;&lt;/div&gt; 当用directive双向绑定数据并且参数不会改变时 1234567891011someModule.directive('someDirective', function() &#123; return &#123; scope: &#123; name: '=', color: '@' &#125;, template: '&#123;&#123;name&#125;&#125;: &#123;&#123;color&#125;&#125;' &#125;;&#125;);&lt;div some-directive name=\"::myName\" color=\"My color is &#123;&#123;::myColor&#125;&#125;\"&gt;&lt;/div&gt; 指令中包含表达式时 123&lt;ul&gt; &lt;li ng-repeat=\"item in ::items | orderBy:'name'\"&gt;&#123;&#123;item.name&#125;&#125;;&lt;/li&gt;&lt;/ul&gt; Interpolation 针对布尔attr，如disabled、required、selected、checked、readOnly、open，不要使用原生的，使用ng-disabled、ng-required… 使用ng-attr-xxx绑定任意特性，如ng-attr-cx；若为驼峰形式，则用下划线代替，如viewBox，则使用ng-attr-view_box Filters 在view中的语法 正常语法 1&#123;&#123; expression | filterName &#125;&#125; Filter Chain-&gt;用上一个filter的输出作为下一个filter的输入 1&#123;&#123; expression | filter1Name | filter2Name | ... &#125;&#125; 带参数 12&#123;&#123; expression | filterName:argument1:argument2:... &#125;&#125;如 &#123;&#123; 1234 | number:2 &#125;&#125; 当filter用在controller、services、directives上时，需采用Filter形式 需要在controller中使用number过滤器时1234angular.module('numberFilterExample', []).controller('ExampleController', ['numberFilter', function(numFilter) &#123; // ....&#125;]); 创建自定义filter 使用filter函数123456789101112angular.module('myReverseFilterApp', []).filter('reverse', function() &#123; return function(input) &#123;// return 一个函数 input = input || ''; var out = ''; for (var i = 0; i &lt; input.length; i++) &#123; out = input.charAt(i) + out; &#125; return out; &#125;;&#125;)// html中直接&#123;&#123; data | reverse&#125;&#125; 常用filter date日期格式-&gt; {{ now | date:'yyyy-MM-dd hh:mm:ss a' }} currency货币格式化 fiter对数组、字符串、对象等进行筛选显示 1234567891011$scope.city = [&#123; id: \"001\", name: \"上海\" &#125;, &#123; id: \"002\", name: \"北京\"&#125;];// view &#123;&#123;city&#125;&#125; &#123;&#123;city|filter:'上海'&#125;&#125;// 默认筛选出所有value值为'上海'的object &#123;&#123;city|filter:&#123;name:'北京'&#125; &#125;&#125;// 筛选出name为北京的object orderBy排序 {{city |orderBy:'id'}} 默认正序 {{city |orderBy:'-id'}} 反序 json 将对象解析成json，主要用来调试 Forms angularJs对表单域做了增强，添加了很多功能 使用ng-model就可以将表单的值和model进行双向绑定 使用novalidate屏蔽浏览器原生验证 angualrJs会添加一些class类，来标识验证的状态，根据这些验证状态class类，来写不同的样式 ng-valid：model验证通过 ng-invalid：model未验证通过 ng-valid-[ruleName]：ruleName的验证规则已通过 ng-invalid-[ruleName ]：ruleName的验证规则未通过 ng-pristine：这个表单域还没有交互过(未修改过) ng-dirty：这个表单域已经交互过(修改过) ng-touched：这个表单域 失去焦点 ng-untouched：这个表单域未失去焦点 ng-pending：异步验证还未完成 可以根据表单验证的一些状态，来辅助添加帮助信息 通过ng-model-options来设置一些属性 ng-model-options=”{ updateOn: ‘blur’ }” 在blur时更新model 延时更新model ng-model-options=”{ debounce: 500 }” ng-model-options=”{ updateOn: ‘default blur’, debounce: { default: 500, blur: 0 } }” 可通过编写directive来创建自己的验证规则、表单域 可以修改内置的验证规则 相关状态 字段错误信息-&gt;formName.fieldName.$error-&gt;验证通过的规则会显示false，未通过的显示true 字段无效信息-&gt;formName.fieldName.$invalid 字段有效信息-&gt;formName.fieldName.$valid 字段是否更改-&gt;formName.fieldName.$dirty 字段是否未更改-&gt;formName.fieldName.$pristine $scope.formName.$setPristine-&gt;将表单恢复到最初状态，class、$dirty等都被恢复 Directives 匹配 12345678&lt;div ng-controller=\"Controller\"&gt;&lt;!-- 下面这几种形式，都将input和model中name绑定起来了，绑定这个指令就匹配上了 --&gt; Hello &lt;input ng-model='name'&gt; &lt;hr/&gt;&lt;!-- 建议形式 --&gt; &lt;span ng-bind=\"name\"&gt;&lt;/span&gt; &lt;br/&gt;&lt;!-- 建议形式 --&gt; &lt;span ng:bind=\"name\"&gt;&lt;/span&gt; &lt;br/&gt; &lt;span ng_bind=\"name\"&gt;&lt;/span&gt; &lt;br/&gt; &lt;span data-ng-bind=\"name\"&gt;&lt;/span&gt; &lt;br/&gt; &lt;span x-ng-bind=\"name\"&gt;&lt;/span&gt; &lt;br/&gt;&lt;/div&gt; ng-attr-xxx-&gt;所有ng-attr开头的特性，最后都会转化到原生的特性上，建议不要在原生的特性上绑定值，都用ng-attr开头(因为某些原生特性和ng配合的不好) 123&lt;svg&gt; &lt;circle ng-attr-cx=\"&#123;&#123;cx&#125;&#125;\"&gt;&lt;/circle&gt;&lt;!-- 将&#123;&#123;cx&#125;&#125;绑定到了原生的cx上 --&gt;&lt;/svg&gt; 指令类型 A（attribute）、E（element）、M（comment）、C（class）;M和C不常用，如果需要兼容IE8，建议全部用A 1234&lt;my-dir&gt;&lt;/my-dir&gt;&lt;span my-dir=\"exp\"&gt;&lt;/span&gt;&lt;!-- directive: my-dir exp --&gt;&lt;span class=\"my-dir: exp;\"&gt;&lt;/span&gt; 注意：由于历史原因，浏览器在解析html标签和标签attribute时，会自动忽略大小写，统一使用小写形式；这就导致了，用驼峰形式定义的html标签（&lt;myTag&gt;）和特性会被转换为全小写（&lt;mytag&gt;）；那么用驼峰形式定义的指令在匹配E和A时，就找不到（无法匹配），为了解决这问题，ng会在定义时用的驼峰形式directive(“myTag”,xxx)转换成my-tag，这样在html中my-tag形式的标签和特性就会被匹配到。如果定义时没用驼峰形式(全小写)，则不会转换，直接匹配。驼峰形式的指令名在匹配M和C时不会存在转换-&gt;总结:在定义指令时如果用了驼峰形式匹配EA，则在html中使用时就要转换成短横线连接的形式如myTag转换成my-tag-&gt;最佳实践：ng中指令若用驼峰则html中用短横线连接； 创建指令 module.directive(directiveName,fn); 12345678910angular.module('docsSimpleDirective', []).controller('Controller', ['$scope', function($scope) &#123; $scope.customer = &#123; name: 'Naomi', address: '1600 Amphitheatre' &#125;;&#125;]).directive('myCustomer', function() &#123; return &#123;// 尽量都返回一个object，不要只返回一个函数 template: 'Name: &#123;&#123;customer.name&#125;&#125; Address: &#123;&#123;customer.address&#125;&#125;' // 除非你的模板很小，否则使用templateUrl来引入外部单独的模板html文件 &#125;;&#125;); templateUrl-&gt;除非你的模板很小，否则使用templateUrl来引入外部单独的模板html文件 当replace为true时，tpl文件内容必须被包裹在一个标签内，也即tpl文件只能有一个根标签；即不能存在有文本未被标签包裹，也不能存在多个根标签；因为替换的时候ng找不到一个唯一的节点做为替换节点，所以必须得有一个最外层的根节点；template也存在同样情况-&gt;最佳实践，任何情况下，都让模板文件包裹在一个根标签中，这样也方便文件的组织管理 可以在模板中使用$scope中的变量 templateUrl中可以指定type=text/ng-template的script为模板，只需要在templateUrl中写上script模板的id；注意：这个script模板必须在ng-app中，而且，若replact为true，则也需要一个根标签1234567891011angular.module('docsTemplateUrlDirective', []).controller('Controller', ['$scope', function($scope) &#123; $scope.customer = &#123; name: 'Naomi', address: '1600 Amphitheatre' &#125;;&#125;]).directive('myCustomer', function() &#123; return &#123; templateUrl: 'my-customer.html' &#125;;&#125;); restrict-&gt;设置指令的匹配模式(AEMC)；默认是AE（匹配attribute、element类型指令)；M和C不常用 123456789101112131415angular.module('docsRestrictDirective', []).controller('Controller', ['$scope', function($scope) &#123; $scope.customer = &#123; name: 'Naomi', address: '1600 Amphitheatre' &#125;;&#125;]).directive('myCustomer', function() &#123; return &#123; restrict: 'E', templateUrl: 'my-customer.html' &#125;;&#125;);// 什么情况下该用元素名，什么情况下该用属性名？ 当创建一个含有自己模板的组件的时候，建议使用元素名，常见情况是，当你想为你的模板创建一个DSL（特定领域语言）的时候。如果仅仅想为已有的元素添加功能，建议使用属性名.// 当需要创建一个自己的组件时-&gt;创建E型指令// 为已有元素添加新功能-&gt;创建A型指令 isolate scope 存在原因：若无独立作用域，则在一个作用域下，多个指令无法独立执行；使用独立作用域，可以将指令限制在独立的作用域下执行，互不干扰 创建：在创建directive时指定scope属性 1234567891011angular.module('docsIsolateScopeDirective', []).controller('Controller', ['$scope', function($scope) &#123; $scope.naomi = &#123; name: 'Naomi', address: '1600 Amphitheatre' &#125;; $scope.igor = &#123; name: 'Igor', address: '123 Somewhere' &#125;;&#125;]).directive('myCustomer', function() &#123; return &#123; restrict: 'E', scope: &#123; customerInfo: '=info' // 将customerInfo绑定到指令所在元素的info特性上，如果外面的特性也叫customerInfo，则可以直接使用缩写形式\"=\" &#125;, templateUrl: 'my-customer-iso.html' &#125;;&#125;); 独立作用域会隔离除你添加到scope: {} 对象中的数据模型之外的一切东西。 因为它可以阻止除你传入的数据模型之外的一切东西改变你内部数据模型的状态。 如果要使你的组件在应用范围内可重用，那么使用scope选项去创建一个独立作用域1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" ng-app=\"myApp\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div ng-controller=\"myController\"&gt; &#123;&#123;books&#125;&#125; &lt;div book-list book-a=\"books\" book-b=\"books\" book-c=\"&#123;&#123;title&#125;&#125;\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;script type=\"text/javascript\" src=\"js/angularjs.js\"&gt;&lt;/script&gt; &lt;script&gt; angular.module('myApp', []).directive(\"bookList\", function() &#123; return &#123; restrict: \"EAMC\", template: '&lt;div&gt;&lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt;&lt;ul&gt;&lt;li ng-repeat=\"book in books\"&gt;&#123;&#123;book.name&#125;&#125;&lt;/li&gt;&lt;/ul&gt; &lt;/div&gt;', // bookList指令中包含一个booAdd指令 replace: true, // scope: false,// scope为独立作用域，当为false，表示直接使用父级作用域，为true，表示创建一个作用域并继承自父作用域；当scope为一个对象时，则表示创建了一个不继承父作用域的继承链的独立作用域(就是可以访问到父作用域，但是无法访问到父作用域之上的作用域) scope: &#123; // &amp;attr表示作用域将父作用域的属性包装成一个函数，从而以函数的形式读写父作用域的属性；一般用在执行父作用域上的某个事件处理函数；若作用域和父作用域的属性名称一要，则可以使用简写形式&amp;,@和=同理 a: \"&amp;bookA\" // 会查找当前指令匹配的元素上的bookA特性，然后取得值books，并将books做为a调用的返回值进行返回； // =attr会将作用域上的属性和父级的作用域上的属性进行双向绑定，任何一方的修改都会修改另外一方 // b: \"=bookB\" // 会查找当前指令匹配的元素上的bookB特性，会将其值和b进行双向绑定 // @attr代表只能读取父级作用域上的值，单向的，并只能读取简单值，引用值不行，因为他最终得到的只会是简单值； // c: \"@bookC\" &#125;, controller: function($scope) &#123; $scope.books = $scope.a(); console.log($scope.a()); // $scope.books = $scope.b; // $scope.b.push(&#123; // name: \"nodeJs\" // &#125;); // console.log($scope.b); // $scope.title = $scope.c; // console.log($scope.c); &#125;, &#125; &#125;).controller('myController', ['$scope', function($scope) &#123; $scope.books = [&#123; name: \"php\" &#125;, &#123; name: \"js\" &#125;, &#123; name: \"java\" &#125;]; $scope.title = \"书籍\"; &#125;]); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; compile 主要用在DOM渲染之前( link之前) 改变DOM结构，并不需要$scope参数。它必须返回一个link函数，因此如果指令中compile和link都写了，则link会被覆盖-&gt;用的比较少123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" ng-app=\"myApp\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div ng-controller=\"myController\"&gt; &lt;div ng-repeat=\"user in users\" my-tag my-tag2&gt;&lt;/div&gt; &lt;/div&gt; &lt;script type=\"text/javascript\" src=\"js/angularjs.js\"&gt;&lt;/script&gt; &lt;script&gt; angular.module('myApp', []).directive('myTag', function() &#123; return &#123; restrict: \"EAMC\", template: '&lt;div&gt;&#123;&#123;user.name&#125;&#125;&lt;/div&gt;', replace: true, compile: function(tElement, tAttrs, transclude) &#123; // 主要用来在实际渲染之前修改DOM结构，compile必须返回一个link函数 // console.log(tElement); //返回匹配的当前类jQuery对象 // console.log(tAttrs); // 返回tElement上的所有attr // console.log(transclude); // 如果指令中transclue为true，则它返回的就是被transclude的原始数据 console.log(\"myTag 编译阶段\"); // 在实际渲染前变更DOM结构 tElement.append(angular.element(\"&lt;h1&gt;test&lt;/h1&gt;\")); return &#123; // 若在compile中直接return一个函数，则返回的是postLink函数 pre: function(scope, iElement, iAttrs, controller) &#123; // preLink是在compile阶段结束后，link阶段之前触发 console.log(\"myTag preLink\"); &#125;, post: function(scope, iElement, iAttrs, controller) &#123; // postLink是指令link后触发 console.log(\"myTag postLink\"); &#125; &#125; &#125;, link: function(scope, iElement, iAttrs, controller) &#123; // 主要在link中进行绑定事件和操纵DOM；一般定义了compile，就不会定义link了;此处的link其实就是compile中postLink console.log(\"因为上面执行了，compile，所以我不会再被执行了\"); &#125; &#125; &#125;).directive('myTag2', function() &#123; return &#123; restrict: \"EAMC\", compile: function(tElement, tAttrs, transclude) &#123; console.log(\"myTag2 编译阶段\"); return &#123; pre: function() &#123; console.log(\"myTag2 preLink\"); &#125;, post: function() &#123; console.log(\"myTag2 postLink\"); &#125; &#125; &#125; &#125; &#125;).controller(\"myController\", [\"$scope\", function($scope) &#123; $scope.users = [&#123; id: 10, name: \"张三\" &#125;, &#123; id: 20, name: \"李四\" &#125;]; &#125;]); &lt;/script&gt;&lt;/body&gt; &lt;/html&gt; link 主要在这里来操作DOM和添加事件 scope-&gt;指令所处的作用域(如果有独立作用域，则为独立作用域，否则值为父级的作用域); element-&gt;指令所匹配的那个元素 attrs-&gt;指令匹配元素的所有特性的集合 controller-&gt;指令需要依赖的controller实例123456789101112131415161718192021222324252627282930angular.module('docsTimeDirective', []).controller('Controller', ['$scope', function($scope) &#123; $scope.format = 'M/d/yy h:mm:ss a';&#125;]).directive('myCurrentTime', ['$interval', 'dateFilter', function($interval, dateFilter) &#123; function link(scope, element, attrs) &#123; var format, timeoutId; function updateTime() &#123; element.text(dateFilter(new Date(), format)); &#125; scope.$watch(attrs.myCurrentTime, function(value) &#123; format = value; updateTime(); &#125;); element.on('$destroy', function() &#123; $interval.cancel(timeoutId); &#125;); // start the UI update process; save the timeoutId for canceling timeoutId = $interval(function() &#123; updateTime(); // update DOM &#125;, 1000); &#125; return &#123; link: link &#125;;&#125;]); replace-&gt;是否替换匹配的元素 若为true则在找到匹配的元素后，会用指令中的template内容替换匹配的内容(包括被匹配的元素)；默认情况下，指令会在找到匹配的元素时，会将匹配元素的内容替换为指令中template的内容； 一般在匹配E时，会选择将其设置为true，因为一般E型指令都是创建新标签，是不符合规范的，所以会选择将其替换 transclude-&gt;主要用来处理指令嵌套 默认情况下，指令会替换匹配元素内部的内容，这样就无法实现指令的相互嵌套使用(原指令的内容会被新指令全部替换掉)； 当设置transclude为true时，则可以保留原先的指令模板以及对应的作用域；注意，在新指令的模板中要用ng-transclude保留老指令的内容； 123456789101112// jsangular.module('docsTransclusionDirective', []).controller('Controller', ['$scope', function($scope) &#123; $scope.name = 'Tobias';&#125;]).directive('myDialog', function() &#123; return &#123; restrict: 'E', transclude: true, scope: &#123;&#125;, templateUrl: 'my-dialog.html' &#125;;&#125;);// my-dialog.html&lt;h1&gt;新内容&lt;/h1&gt;&lt;div class=\"alert\" ng-transclude&gt;&lt;/div&gt; &lt;!-- 指定ng-transclude --&gt; 仅当你要创建一个包裹任意内容的指令的时候使用transclude: true 创建一个包裹任意内容的dialogBox 12345678910111213141516171819202122232425262728293031323334353637// jsangular.module('docsIsoFnBindExample', []).controller('Controller', ['$scope', '$timeout', function($scope, $timeout) &#123; $scope.name = 'Tobias'; $scope.message = ''; $scope.hideDialog = function(message) &#123; $scope.message = message; $scope.dialogIsHidden = true; $timeout(function() &#123; $scope.message = ''; $scope.dialogIsHidden = false; &#125;, 2000); &#125;;&#125;]).directive('myDialog', function() &#123; return &#123; restrict: 'E', transclude: true, scope: &#123; 'close': '&amp;onClose' // &amp;prop 用来绑定一个函数到独立作用域，允许独立作用域调用它，同时保留了函数的原来作用域；当你的指令想要开放一个API去绑定特定的行为，在scope选项中使用&amp;prop。 &#125;, templateUrl: 'my-dialog-close.html' &#125;;&#125;);// html&lt;div ng-controller=\"Controller\"&gt; &#123;&#123;message&#125;&#125; &lt;my-dialog ng-hide=\"dialogIsHidden\" on-close=\"hideDialog(message)\"&gt; Check out the contents, &#123;&#123;name&#125;&#125;! &lt;/my-dialog&gt;&lt;/div&gt;// my-dialog-close.html&lt;div class=\"alert\"&gt; &lt;a href class=\"close\" ng-click=\"close(&#123;message: 'closing for now'&#125;)\"&gt;&amp;times;&lt;/a&gt; &lt;div ng-transclude&gt;&lt;/div&gt; &lt;!-- 保留原先指令内容 --&gt;&lt;/div&gt; 创建添加事件的指令 12345678910111213141516171819202122232425262728293031323334353637angular.module('dragModule', []).directive('myDraggable', ['$document', function($document) &#123; return &#123; link: function(scope, element, attr) &#123; // 在link中为指令匹配的元素element绑定事件 var startX = 0, startY = 0, x = 0, y = 0; element.css(&#123; position: 'relative', border: '1px solid red', backgroundColor: 'lightgrey', cursor: 'pointer' &#125;); element.on('mousedown', function(event) &#123; // Prevent default dragging of selected content event.preventDefault(); startX = event.pageX - x; startY = event.pageY - y; $document.on('mousemove', mousemove); $document.on('mouseup', mouseup); &#125;); function mousemove(event) &#123; y = event.pageY - startY; x = event.pageX - startX; element.css(&#123; top: y + 'px', left: x + 'px' &#125;); &#125; function mouseup() &#123; $document.off('mousemove', mousemove); $document.off('mouseup', mouseup); &#125; &#125; &#125;;&#125;]); controller-&gt;指令中的controller属性可以用来完成指令间的相互通信 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// jsangular.module('docsTabsExample', []).directive('myTabs', function() &#123; return &#123; restrict: 'E', transclude: true, scope: &#123;&#125;, controller: ['$scope', function MyTabsController($scope) &#123; var panes = $scope.panes = []; $scope.select = function(pane) &#123; angular.forEach(panes, function(pane) &#123; pane.selected = false; &#125;); pane.selected = true; &#125;; this.addPane = function(pane) &#123;// 这个方法需要暴露给其他指令用 if (panes.length === 0) &#123; $scope.select(pane); &#125; panes.push(pane); &#125;; &#125;], templateUrl: 'my-tabs.html' &#125;;&#125;).directive('myPane', function() &#123; return &#123; require: '^^myTabs', // 依赖一个myTabs控制器，并在指令的父元素上查找这个控制器 restrict: 'E', transclude: true, scope: &#123; title: '@' // 相当于@title &#125;, link: function(scope, element, attrs, tabsCtrl) &#123; tabsCtrl.addPane(scope); &#125;, templateUrl: 'my-pane.html' &#125;;&#125;);// index.html&lt;my-tabs&gt; &lt;my-pane title=\"Hello\"&gt; &lt;p&gt;Lorem ipsum dolor sit amet&lt;/p&gt; &lt;/my-pane&gt; &lt;my-pane title=\"World\"&gt; &lt;em&gt;Mauris elementum elementum enim at suscipit.&lt;/em&gt; &lt;p&gt;&lt;a href ng-click=\"i = i + 1\"&gt;counter: &#123;&#123;i || 0&#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;/my-pane&gt;&lt;/my-tabs&gt;// tabs&lt;div class=\"tabbable\"&gt; &lt;ul class=\"nav nav-tabs\"&gt; &lt;li ng-repeat=\"pane in panes\" ng-class=\"&#123;active:pane.selected&#125;\"&gt; &lt;a href=\"\" ng-click=\"select(pane)\"&gt;&#123;&#123;pane.title&#125;&#125;&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;div class=\"tab-content\" ng-transclude&gt;&lt;/div&gt;&lt;/div&gt;// panel&lt;div class=\"tab-pane\" ng-show=\"selected\"&gt; &lt;h4&gt;&#123;&#123;title&#125;&#125;&lt;/h4&gt; &lt;div ng-transclude&gt;&lt;/div&gt;&lt;/div&gt; 当你想暴露一个API给其它的指令调用那就用controller,否则用link。 controllerAs-&gt;给指令中的controller起个别名，并可做controller中的第四个参数传入 priority-&gt;设置指令执行的优先级顺序(权重)；多个指令时，ng必须知道哪个先执行；默认ng-repeat优先级很高，为1000；-&gt;不常用 terminal-&gt;是否设置当前指令的权重priority 为结束界限；若为true，则节点上小于当前指令权重priority的指令不会被执行，相同权重的会执行 require-&gt;可以将其他指令传给自己，有以下值 directiveName-&gt;默认值，会从同一个元素上查找 ^directiveName-&gt;会在父级上查找 ?directiveName-&gt;表示指令是可选的，找不到也不会抛出异常 Animations 可参考https://css-tricks.com/animations-the-angular-way/ 无需引入任何模块，直接利用切换class配合css的过渡，来实现过渡动画-&gt;无法做到全兼容；-&gt;https://codepen.io/bdsimmons/pen/NqYjaV angualr中内置了$animate服务，可以提供简单的动画操作，enter、leave…-&gt;核心方法，ngAnimate模块也依赖这个核心服务 更强大的动画-&gt;引入ngAnimate模块；angualr没有直接包含动画模块(ngAnimate)，需要在引入angular.js后引入angular-animate.js 重点：ngAnimate动画的核心都是基于css，通过变换元素的class类配合过渡和animation进而实现动画，js动画除外 如何使用ngAnimate模块 整个app没有模块，则可以直接指定ng-app=”ngAnimate”来从ngAnimate模块启动app，也能有动画效果；-&gt;不推荐-&gt;http://www.runoob.com/try/try.php?filename=try_ng_animation 当做模块依赖来使用-&gt;var app=angular.module(“myApp”,[“ngAnimate”]); 当引入ngAnimate模块后，就会自动在一些指令执行的特殊时机，为元素添加上对应的class类，可以利用这个配合css实现动画 css过渡动画-&gt;需要设置动画的起点、终点的动画属性值；例如在.ng-enter上设置过渡动画初始值，在.ng-enter-active上设置过渡动画终点值-&gt;https://codepen.io/bdsimmons/pen/OPmNxXs css3Animation-&gt;css3Animtions，无需在2个class上设置动画，只需要在一个class上设置动画，并给定动画时间即可，所以如上面的只需要在.ng-enter上设置一个animation动画即可，无需在ng-enter-active在设置动画-&gt;https://codepen.io/anon/pen/NjJLMZ JS动画-&gt;当引入ngAnimate模块后 就自动在app上添加了animation方法，app.animation()；可以通过animation方法，实现动画-&gt;https://codepen.io/bdsimmons/pen/YXLZEw Module 基本用法 创建模块-&gt;用angular.module(“moduleName”,[“依赖的模块”]); 获取已有模块-&gt;用angular.module(“moduleName”);注意获取时，没有后面的依赖数组 让模块运作起来 声明一个module,然后在ng-app中引用它，即可让app从module中开始运行 模块划分 服务模块 指令模块 过滤器模块 一个应用的模块，依赖于上述的三个模块，而且包含应用的初始化及启动代码12345678910111213141516171819202122232425262728293031323334angular.module('xmpl.service', []) // 服务 .value('greeter', &#123; salutation: 'Hello', localize: function(localization) &#123; this.salutation = localization.salutation; &#125;, greet: function(name) &#123; return this.salutation + ' ' + name + '!'; &#125; &#125;) .value('user', &#123; load: function(name) &#123; this.name = name; &#125; &#125;);angular.module('xmpl.directive', []); // directiveangular.module('xmpl.filter', []);// filterangular.module('xmpl', ['xmpl.service', 'xmpl.directive', 'xmpl.filter']) // xmpl依赖service、directive、filter .run(function(greeter, user) &#123; // 初始化 // This is effectively part of the main method initialization code greeter.localize(&#123; salutation: 'Bonjour' &#125;); user.load('World'); &#125;) .controller('XmplController', function($scope, greeter, user)&#123; $scope.greeting = greeter.greet(user.name); &#125;); 模块是配置代码块和运行代码块的集合 配置代码块config-&gt;在 provider 注册和配置阶段执行（注：provider 是 ng 服务的一种）。只有 provider 和 constant 可以被注入配置代码块。这是为了防止服务在完全配置好之前被意外地初始化。-&gt;config为配置 执行代码块run-&gt;在 injector 被创建后执行，被用来启动整个应用。只有服务的实例对象以及 constant 可以被注入到执行代码块。这是为了防止在应用执行期间系统的更进一步的配置。-&gt;run为初始化 123456789angular.module('myModule', []). config(function(injectables) &#123; // provider型注入器 // 这是配置(config)代码块的范例，你可以有任意多个配置代码块 // 配置块中你只能注入Provider类（注意：不是由Provider类生成的实例）以及`constant` &#125;). run(function(injectables) &#123; // instance型注入器 // 这是运行(run)代码块的范例，你可以有任意个运行代码块 // 运行块中你只能注入Provider实例（注意：不是Provider类） &#125;); 配置代码块的快捷方法 123456789101112131415161718192021222324angular.module('myModule', []).value('a', 123).factory('a', function() &#123; return 123; &#125;).directive('directiveName', ...).filter('filterName', ...);// 等同于angular.module('myModule', []).config(function($provide, $compileProvider, $filterProvider) &#123; $provide.value('a', 123); $provide.factory('a', function() &#123; return 123; &#125;); $compileProvider.directive('directiveName', ...); $filterProvider.register('filterName', ...);&#125;);//.config等同于设置module函数的第三个参数angular.module(\"myModule\",[],[\"$provide\",\"$compileProvider\",\"$filterProvier\",function(provide,compileProvier,filterProvider)&#123; provide.value('a', 123); provide.factory('a', function() &#123; return 123; &#125;); compileProvider.directive('directiveName', ...); filterProvider.register('filterName', ...); &#125;]); 配置语句的执行顺序就是根据它们注册的顺序而定的。唯一的例外是 constant 的定义，它会被调整到所有配置块的最前面执行。 执行代码块 执行代码块是 ng 中最接近 main 函数的一个东西。执行代码块是应用启动时运行的代码。它在所有的服务被配置好以及 注入器(injector)被创建好之后执行。通常，执行代码块包含的代码都很难进行单元测试，正因为如此，它通常应该被丢在一个单独的模块中，这样我们可以在单元测试时忽略它。 模块依赖 A依赖B，则A的配置阶段要在B的配置阶段完成后进行，执行阶段同理，A的执行要在B的执行结束后。 注意每个模块只能被加载一次，即使有多个别的模块依赖它。 IE兼容性 1.3及以上不再支持IE8-&gt;所以如果需要支持IE8，请使用ng1.2.x-&gt;1.2的最新版本为1.2.32 IE7及以下不支持JSON.stringify-&gt;使用json2.js 123&lt;!--[if lte IE 7]&gt; &lt;script src=\"/path/to/json2.js\"&gt;&lt;/script&gt;&lt;![endif]--&gt; 在根元素上添加id=”ng-app”并结合ng-app=”xxModule”来启动app 1234&lt;!doctype html&gt;&lt;html xmlns:ng=\"http://angularjs.org\" id=\"ng-app\" ng-app=\"optionalModuleName\"&gt; ...&lt;/html&gt; 不要使用自定义节点 如，用attribute方式代替如ng-view 如果你由于语义或者第三方的Angular组件需要使用tag的方式的话,那么你必须按照如下步骤 make IE happy 1234567891011121314151617181920&lt;!doctype html&gt;&lt;html xmlns:ng=\"http://angularjs.org\" id=\"ng-app\" ng-app=\"optionalModuleName\"&gt;&lt;head&gt;&lt;!--[if lte IE 8]&gt; &lt;script&gt; document.createElement('ng-include'); document.createElement('ng-pluralize'); document.createElement('ng-view'); // Optionally these for CSS document.createElement('ng:include'); document.createElement('ng:pluralize'); document.createElement('ng:view'); &lt;/script&gt;&lt;![endif]--&gt;&lt;/head&gt;&lt;body&gt;...&lt;/body&gt;&lt;/html&gt; 重要的部分: xmlns:ng- 命名空间 - 你需要为每一个将使用的自定义tag注册一个命名空间(译者注:IE作为严格xml模式解析). document.createElement(yourTagName) - 自定义节点创建 - 由于这只是老版本的IE issues，所以你需要按条件加载这些脚本(IE低版本特有的条件注释)。对于每一个需要使用的没有注册命名空间以及非HTML定义的tag你需要利用它来预申明来make IE happy。 IE在处理关于非标准HTML tag 的问题主要由两类，每种类型又其自己的修复方式. If the tag name starts with my: prefix then it is considered an XML namespace and must have corresponding namespace declaration on 以my:为前缀的tag 考虑到严格的XML命名空间，你必须有相应的命名空间申明,如。 If the tag has no : but it is not a standard HTML tag, then it must be pre-created using document.createElement(‘my-tag’) 没有:的非标准HTML tag, 你需要使用document.createElement(&#39;my-tag&#39;)来预申明改节点(译者注:ie-shv)。 If you are planning on styling the custom tag with CSS selectors, then it must be pre-created using document.createElement(&#39;my-tag&#39;) regardless of XML namespace. 如果你希望采用CSS选择器的方式，那么你需要使用document.createElement(&#39;my-tag&#39;)预申明，忽略XML命名空间。 使用ng-style代替style=;后者在&lt;IE11的版本上无法运行 Angualr会在执行的某些时间点为标签添加上一些标识用的class类 ng-scope样式类会在创建了新作用域(Scope)的HTML元素上生成 ng-binding样式类会在ng-bind 或 绑定了任何数据的元素上生成 ng-invalid、ng-valid样式类会在进行了验证操作的所有input组件元素上生成 ng-pristine、ng-dirty angular的input指令给所有新的、还没有与用户交互的input元素附加上ng-pristine类，当用户有任何输入时，则附加上 ng-dirty. 国际化I18n和本地化L10n 引入特定的语言包 12345678&lt;html ng-app&gt;&lt;head&gt;…. &lt;script src=\"angular.js\"&gt;&lt;/script&gt; &lt;script src=\"i18n/angular-locale_zh-cn.js\"&gt;&lt;/script&gt;….&lt;/head&gt;&lt;/html&gt; 启动即bootstrap(这里bootstrap并非指ui库，bootstrap本身就有启动的意思) 自动启动 在angular要控制的范围最外层元素上添加ng-app指令 若未指定ng-app的具体值，会从默认模块开始启动；若指定了则从指定模块上启动 若需支持IE7，则还上在ng-app除添加id=”ng-app” 若需支持老式ng:风格的指令，则还需要在html上添加xml命名空间 1&lt;html xmlns:ng=\"http://angularjs.org\"&gt; 手动启动 使用angular.bootstrap 1234567891011121314151617181920&lt;!doctype html&gt;&lt;html&gt;&lt;body&gt; &lt;div ng-controller=\"MyController\"&gt; Hello &#123;&#123;greetMe&#125;&#125;! &lt;/div&gt; &lt;script src=\"http://code.angularjs.org/snapshot/angular.js\"&gt;&lt;/script&gt; &lt;script&gt; angular.module('myApp', []) .controller('MyController', ['$scope', function ($scope) &#123; $scope.greetMe = 'World'; &#125;]); angular.element(document).ready(function() &#123; angular.bootstrap(document, ['myApp']); // 手动启动 &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; bootstrap要在需要的module创建或加载完成后，才能调用 当手动启动app时，就不应当在用ng-app指令了 安全性 不要混用前台和后台的模板 不要使用用户的输入动态生成模板 Do not run user input through $scope.$eval 考虑使用ngCSP模块 Providers injector可以创建两种对象 专有对象-&gt;angular框架提供的，如controller、filter、directives等 服务-&gt;服务的API由开发人员自己制定-&gt;说明服务可以自己定制 injector需要知道如何创建服务，它需要一个”图纸” 图纸provider、factory、service、value、constant 最底层的图纸是provider，其余四种图纸都是基于provider的语法糖（在provider上又封装了一层） value图纸 用来创建可在运行阶段使用的常量 1234567891011var myApp = angular.module('myApp', []);myApp.value('clientId', 'a12345654321x');myApp.controller('DemoController', ['clientId', function DemoController(clientId) &#123; this.clientId = clientId;&#125;]);&lt;html ng-app=\"myApp\"&gt; &lt;body ng-controller=\"DemoController as demo\"&gt; Client ID: &#123;&#123;demo.clientId&#125;&#125;&lt;/body&gt;&lt;/html&gt; factory图纸 可以创建任何类型的服务 factory图纸相较value图纸增加了下面功能 可以有依赖 服务初始化 延迟/惰性初始化 factory图纸通过一个拥有0～n个参数(参数表示该服务对其他服务的依赖)的函数来创建服务，而函数返回值就是factory图纸创建的服务实例。 123myApp.factory('clientId', function clientIdFactory() &#123; return 'a12345654321x';// 返回的是服务的实例，不过这里clientId是一个常量，所以还是用value靠谱&#125;); 更适合用factory的例子，计算token 12345678910111213myApp.factory('apiToken', ['clientId', function apiTokenFactory(clientId) &#123;//将工厂方法命名为\"Factory\"是最佳实践（比如，apiTokenFactory）.虽然这种命名方式不是强制性的，但是它有助于浏览代码仓库或者在调试器里跟踪调用堆栈。 var encrypt = function(data1, data2) &#123; // NSA-proof加密算法： return (data1 + ':' + data2).toUpperCase(); &#125;; var secret = window.localStorage.getItem('myApp.secret'); var apiToken = encrypt(clientId, secret); return apiToken;&#125;]);``` service图纸 必须返回引用类型 自定义类型，并携带token 1234567891011function UnicornLauncher(apiToken) &#123; this.launchedCount = 0; this.launch() &#123; // 带上apiToken来发起远程调用 ... this.launchedCount++; &#125;&#125;myApp.factory('unicornLauncher', [\"apiToken\", function(apiToken) &#123;// 使用factory图纸来实现 return new UnicornLauncher(apiToken);&#125;]);myApp.service('unicornLauncher', [\"apiToken\", UnicornLauncher]);// 使用services语法更加简介，在内部还是会像factory一样，new 一下 provider图纸 注意必须实现$get方法 其它图纸的底层都是通过provider实现的，如factory 123function factory(name, factoryFn) &#123; return provider(name, &#123; $get: factoryFn &#125;); &#125; 当你需要为在应用运行前就必须设置好的全局配置项提供API时，你才需要用到provider图纸 假设我们的unicornLauncher服务是如此棒，以至于有好多应用都用到它。默认情况下，发射器将独角兽发射到太空中不需要任何保护屏障。但是在某些星球上，由于大气层非常厚，我们在将独角兽送去做星际旅行前必须将它们包裹在铝箔里，不然它们在穿越大气层时就被烧毁了。在一些应用里，需要设置发射器在每次发射时都使用铝箔屏蔽，如果我们能按需配置这一点那就太棒了。我们可以像下面这样让它变得可配置 12345678910111213myApp.provider('unicornLauncher', function UnicornLauncherProvider() &#123; var useTinfoilShielding = false; this.useTinfoilShielding = function(value) &#123; useTinfoilShielding = !!value; &#125;; this.$get = [\"apiToken\", function unicornLauncherFactory(apiToken) &#123; // 这里我们假设UnicornLauncher的构造函数也被改造得支持useTinfoilShielding参数了 return new UnicornLauncher(apiToken, useTinfoilShielding); &#125;];&#125;);myApp.config([\"unicornLauncherProvider\", function(unicornLauncherProvider) &#123; unicornLauncherProvider.useTinfoilShielding(true);&#125;]); constant图纸 用来创建可以在配置阶段使用的图纸 在angular开始创建服务之前，angular会配置和实例化所有provider，此时服务还不能用，因为他们还没有被创建(只是provider被实例化了，由provider创建并返回的服务此时还没有被创建)；一旦配置阶段结束，与provider的交互就被禁止了，而创建服务的过程开始；-&gt;所以在配置阶段，没有服务可用，这就导致了一些没有依赖用value写的常量也无法被使用-&gt;使用constant 假设在配置阶段提供了发射独角兽的星球名称，那么我们的unicornLauncher服务就能通过这个名字来标识一个独角兽。星球名是各个应用特有的，并且在应用运行时也会被各个控制器使用。我们可以像下面的代码那样把星球名定义为一个常量 123456myApp.constant('planetName', 'Greasy Giant');myApp.config(['unicornLauncherProvider', 'planetName', function(unicornLauncherProvider, planetName) &#123;// 在配置阶段，使用constant，因为value无法使用 unicornLauncherProvider.useTinfoilShielding(true); unicornLauncherProvider.stampText(planetName);&#125;]);``` value图纸也可以在控制器、模板、指令中使用 1234567891011myApp.controller('DemoController', [\"clientId\", \"planetName\", function DemoController(clientId, planetName) &#123; this.clientId = clientId; this.planetName = planetName;&#125;]);&lt;html ng-app=\"myApp\"&gt; &lt;body ng-controller=\"DemoController as demo\"&gt; Client ID: &#123;&#123;demo.clientId&#125;&#125; &lt;br&gt; Planet Name: &#123;&#123;demo.planetName&#125;&#125; &lt;/body&gt;&lt;/html&gt; 总结 injector用五种图纸来创建服务和专有对象 provider图纸是最底层的方法，其他的图纸都是基于其之上的语法糖 provider是最复杂的图纸类型，除非你正在构建需要全局配置的可复用代码，否则不要使用它 除了控制器，其他所有专用对象都是通过factory图纸来定义的(factory定义的，都是单例对象，而controller不是单例的) factory和service是最常用的图纸。它们之间的唯一区别就是service图纸存在一个new过程，所以最好返回一个构造函数，而factory可以创建任意类型 constant用在配置时，value用在运行时 12* 有直接使用new操作符预先初始化的开销。** 在配置阶段，服务对象是不能被访问的，但Provider实例是可以被访问的。（参见我们上面列举的unicornLauncherProvider例子）。 HTML Compiler HTML compiler 让开发者可以教浏览器一些新的语法技能 Compiler是 Angular 提供的一项服务，用来遍历DOM节点，查找特定的属性。编译过程分为两个阶段： 编译compile：遍历DOM节点，收集所有的指令，返回一个连接函数（link func） 连接link：将上一步收集到的每个指令与其所在的作用域（scope）连接生成一个实时视图。任何作用域中的模型改变都会实时在视图中反映出来，同时任何用户与视图的交互则会映射到作用域的模型中。这样，作用域中的数据模型就成了唯一的数据源。 指令directive 在编译过程中，遇到特定的HTML结构（也就是指令）时，指令所声明的行为操作会被触发 指令其实就是在编译器遍历DOM时碰到就需要执行的函数。 指令是如何被编译的 知道 Angular 的编译是在DOM节点上发生而非字符串上是很重要的。如果你自己手动调用 $compile 时，如果你传给它一个字符串，显然是要报错的。所以，在你传值给 $compile 之前，用 angular.element 将字符串转化为DOM。 编译流程 $compile 遍历DOM节点，匹配指令。 如果编译器发现某个元素匹配一个指令，那么这个指令就被添加到指令列表中（该列表与DOM元素对应）。一个元素可能匹配到多个指令（译注：也就是一个元素里面可能有多个指令）。 当所有指令都匹配到相应的元素时，编译器按照指令的 priority 属性来排列指令的编译顺序。 然后依次执行每个指令的 compile 函数。每个 compile 函数有一次更改该指令所对应的DOM模板的机会。然后，每个 compile 函数返回一个 link 函数。这些函数构成一个“合并的”连接函数，它会调用每个指令返回的 link 函数。 之后，$compile 调用第二步返回的连接函数，将模板和对应的作用域连接。而这又会依次调用连接函数中包含的每个指令对应的 link 函数，进而在各个DOM元素上注册监听器以及在相应的 scope 中设置对应的 $watchs。 用代码表示大概是下面流程 1234567891011121314151617181920212223var $compile = ...; // 已经存在的编译器var scope = ...;// 作用域var parent = ...; // DOM element where the compiled template can be appended，要被追加内容的DOM元素var html = '&lt;div ng-bind=\"exp\"&gt;&lt;/div&gt;';// 指令模板字符串// Step 1: parse HTML into DOM element，将html字符串解析为DOM，因为如果传给$compile字符串会报错var template = angular.element(html);// Step 2: compile the template，遍历整个template的DOM，找到所有指令，并按priority排序，并依次执行每个指令里的compile函数，每个compile函数会返回一个link函数，以供第三部用var linkFn = $compile(template);// Step 3: link the compiled template with the scope.，$compile会依次调用第二步返回的link函数，将模板和对应的作用域连接，会依次调用连接函数中包含的每个指令对应的 link 函数，进而在各个DOM元素上注册监听器以及在相应的 scope 中设置对应的 $watchesvar element = linkFn(scope);// Step 4: Append to DOM (optional)，可选的将一切就绪的dom追加到html中parent.appendChild(element); 总结：compile(找指令、排序、依次执行指令中compile函数并返回link函数)-&gt;执行每个指令中的link(DOM和作用域进行连接，设置事件监听并添加$watch) ngModel模块 当需要对数据进行深层处理时，可以用ngModel模块-&gt;一般是指令，这个ngModel对应的就是指令匹配元素上的ng-model 主要参考http://docs.ngnice.com/guidehttps://code.angularjs.org/1.2.32/docs/guide小猫杯的angular视频教程大漠穷秋的angular实战","tags":[{"name":"MVC","slug":"MVC","permalink":"http://yoursite.com/tags/MVC/"},{"name":"framework","slug":"framework","permalink":"http://yoursite.com/tags/framework/"},{"name":"Angular","slug":"Angular","permalink":"http://yoursite.com/tags/Angular/"}]},{"title":"Graphviz","date":"2017-03-24T08:55:14.000Z","path":"2017/03/24/Graphviz/","text":"Graphviz的安装以及基本使用介绍Graphviz可通过代码的方式生成图形 安装win下，可在官网http://http://www.graphviz.org/Download_windows.php下载，安装好后，手动将bin文件夹添加到环境变量即可。cmd 下键入dot -version,能出现Graphviz相关信息，则表示安装成功 生成图片12dot 源文件 -T 图片格式 -o 输出文件dot input.dot -T png -o output.png 可利用sublimeText的编译系统，实现图片实时预览 具体可参考这篇文章https://zhuanlan.zhihu.com/p/22820399 新建*.dot文件，然后编写相应代码，再编译就能生成图 基本语法123图类型 图名&#123; //其他&#125; 无向图1234567// 无向图用--表示节点之间的关系graph graphname &#123; a -- b--e; b -- c; b -- d; d -- a;&#125; 有向图123456// 有向图用a-&gt;b表示从a节点指向b节点digraph graphname&#123; a-&gt;b b-&gt;c a-&gt;c&#125; 定义一类节点123456digraph graphname&#123; T [label=&quot;Teacher&quot;,fontcolor=&quot;red&quot;] //定义节点T，并给予属性 P [label=&quot;Pupil&quot;] //定义节点P，并给予属性 T-&gt;P [label=&quot;Instructions&quot;, fontcolor=darkgreen] //定义边T-&gt;P，并给予属性 &#125; 设置属性(样式)12345678910111213141516171819202122232425262728293031323334353637graph G &#123; // 设置当前图和子图的属性 fontname=&quot;Microsoft JhengHei&quot;; fontsize=20; label=&quot;图&quot;; fontcolor=blue; //设置当前大括号范围内所有节点和边的属性，包含子图里面节点和边，类css中标签选择器 node[fontname=&quot;Microsoft JhengHei&quot;,fontsize=16]; edge[fontname=&quot;Microsoft JhengHei&quot;,fontsize=16]; // 可针对某一类节点设置属性，类css中class选择器 &quot;黑海&quot;[fontcolor=&quot;pink&quot;,style =&quot;filled&quot;,fillcolor = &quot;black&quot;]; &quot;黑海&quot; -- &quot;亚速海&quot;; &quot;黑海&quot; -- &quot;博斯普鲁斯海峡&quot;; &quot;达达尼尔海峡&quot; -- &quot;爱琴海&quot;; // 子图，用subgraph声明，并图名字前缀必须是cluster_否则识别失败；子图和父图的类型必须一致，父图是无向则子图也必须是无向，不能是有向 subgraph cluster_T &#123; // 设置子图的label属性，它的颜色继承父图的fontcolor=blue label=&quot;黑海海峡&quot;; &quot;达达尼尔海峡&quot; -- &quot;马尔马拉海&quot; -- &quot;博斯普鲁斯海峡&quot;; &#125; subgraph cluster_M &#123; label=&quot;黑海海峡&quot;; // 一对多，空格分隔 &quot;中部地中海&quot; -- &#123; &quot;爱琴海&quot; &quot;爱奥尼亚海&quot; &quot;西西里海峡&quot; &#125;; // 一对多，并设置每对都有一个label标签说明，并把字体颜色设置为red，线条颜色设置为yellow &quot;西部地中海&quot; -- &#123; &quot;西西里海峡&quot; &quot;第勒尼安海&quot; &quot;利古里亚海&quot; &quot;伊比利海&quot; &quot;阿尔沃兰海&quot; &#125;[label=&quot;标签说明&quot;,fontcolor=&quot;red&quot;,color=&quot;yellow&quot;]; &quot;爱奥尼亚海&quot; -- &quot;亚得里亚海&quot;; &quot;阿尔沃兰海&quot; -- &quot;直布罗陀海峡&quot;; &#125;&#125; 最终生成的 中文乱码保证.dot文件是以UTF-8编码通过设置fontname为中文字体来解决 参考链接 https://zhuanlan.zhihu.com/p/21993254https://zhuanlan.zhihu.com/p/22820399http://blog.csdn.net/xiajian2010/article/details/23748557http://www.tuicool.com/articles/vy2Ajyu","tags":[{"name":"Graphviz","slug":"Graphviz","permalink":"http://yoursite.com/tags/Graphviz/"},{"name":"绘图","slug":"绘图","permalink":"http://yoursite.com/tags/绘图/"}]},{"title":"mock-js","date":"2017-03-24T02:52:19.000Z","path":"2017/03/24/mock-js/","text":"Mock.js的基本用法如何使用123456789101112131415161718192021&lt;script type=\"text/javascript\" src=\"js/jquery-2.2.4.min.js\"&gt;&lt;/script&gt;&lt;!-- 引入Mock.js --&gt;&lt;script type=\"text/javascript\" src=\"js/mock-min.js\"&gt;&lt;/script&gt;&lt;script&gt; // 根据数据模板生成模拟数据。 Mock.mock('http://test.cn', &#123; \"userName\": \"@cname\", \"sex|1\": [\"男\", \"女\"], \"avator\": Mock.Random.image('100x100', '#894FC4', '#FFF', 'png', '头像') &#125;); // 模拟请求 $.ajax(&#123; url: 'http://test.cn', dataType: 'json' &#125;).done(function(data, status, xhr) &#123; // 请求成功，do something console.log(data); &#125;);&lt;/script&gt; 语法规范 数据模板定义规范（Data Template Definition，DTD） 数据占位符定义规范（Data Placeholder Definition，DPD） 数据模板定义语法1234&apos;name|rule&apos;:valuename:属性名rule:生成规则vale:属性值 注意 属性名(name)和生成规则(value)之间要用|分隔 生成规则(rule)不是必须的 最终生成值的类型和初始值由属性值(value)确定 属性值(value)中可以包含数据占位符(@占位符) 生成规则有7种格式 ‘name|min-max’: value ‘name|count’: value ‘name|min-max.dmin-dmax’: value ‘name|min-max.dcount’: value ‘name|count.dmin-dmax’: value ‘name|count.dcount’: value ‘name|+step’: value 生成规则的具体含义还要配合属性值(value)的类型来确定 规则 属性值(value)是String ‘name |min-max’:stringValue 通过重复stringValue，生成一个字符串。重复次数在[min,max]区间取值(次数大于等于min，小于等于max) ‘name |count’:stringValue 通过重复stringValue字符串count次，生成一个字符串。 属性值(value)是Number ‘name|+1’: numberValue 属性值自动加 1，初始值为numberValue。 ‘name|min-max’:numberValue 生成一个[min,max]之间的整数，此时属性值numberValue只是用来确定类型。 ‘name|min-max.dmin-dmax’: numberValue 生成一个整数部分在[min,max]间取值,小数保留的位数在[dmin,dmax]间取值的浮点数。同理此时属性值(value)也只是用来确定最终返回的数据的类型。 属性值是Boolean ‘name|1’: booleanValue 随机生成一个布尔值，值为 booleanValue 的概率是 1/2，值为 !booleanValue 的概率同样是 1/2。 ‘name|min-max’: booleanValue 随机生成一个布尔值，值为 booleanValue 的概率是 min / (min + max)，值为 !booleanValue 的概率是 max / (min + max)。此处属性值必须是Boolean类型，若为Number,则意义不同，见2 “test|1-2”:true 生成一个布尔值，为true的概率为1/3，为false概率为2/3 属性值是对象 Object ‘name|count’: object 返回的对象只包含从属性值object中随机选取的count个属性。 ‘name|min-max’: object 返回的对象只包含从属性值object中随机选取的min到max个属性。 属性值是数组 Array ‘name|1’: array 从属性值 array 中随机选取 1 个元素，作为最终值。 ‘name|+1’: array 从属性值 array 中顺序选取 1 个元素，作为最终值。 ‘name|min-max’: array 通过重复属性值array的值生成一个新数组，重复次数大于等于 min，小于等于 max。 ‘name|count’: array 通过重复属性值array的值生成一个新数组，重复次数为 count。 属性值是函数 Function ‘name’: function 执行函数 function，取其返回值作为最终的属性值，函数的上下文为属性 ‘name’ 所在的对象。 属性值是正则表达式 RegExp ‘name’: regexp 根据正则表达式 regexp 反向生成可以匹配它的字符串。用于生成自定义格式的字符串。 数据占位符定义语法Mock中的占位符和Sass中的placeholder很像。可以直接用在数据模板的属性值中。Mock中提供了很多预先定义的占位符，当然你也可以自定义占位符。 基本调用格式1234@占位符@占位符(参数 [, 参数])或者Mock.Random.占位符(参数 [, 参数]) 注意： 用@来标识其后的字符串是占位符。 占位符引用的是Mock.Random中的方法。 通过 Mock.Random.extend() 来扩展自定义占位符。 占位符也可以引用数据模板中的属性。 占位符会优先引用数据模板中的属性。 占位符支持相对路径和绝对路径。 预定义的占位符 Basic 提供一些基础占位符，如布尔值、整数、自然数、字符串等 Date 提供日期相关的占位符 Image 提供图片相关的占位符 Color 提供色值相关的占位符 Text 提供文本相关的占位符 Name 提供英文、中文名称相关的占位符 Web 提供了url、IP、protocol等相关的占位符 Address 提供省份、城市等地域相关信息的占位符 Helper 提供一些常用工具如字母转换大小写等相关占位符 Miscellaneous 提供了guid、身份证、自增等相关占位符号 自定义扩展符1234567891011121314Mock.Random.extend(&#123; constellation: function(date) &#123; var constellations = ['白羊座', '金牛座', '双子座', '巨蟹座', '狮子座', '处女座', '天秤座', '天蝎座', '射手座', '摩羯座', '水瓶座', '双鱼座'] return this.pick(constellations) &#125;&#125;)Mock.Random.constellation()// =&gt; \"水瓶座\"Mock.mock('@CONSTELLATION')// =&gt; \"天蝎座\"Mock.mock(&#123; constellation: '@CONSTELLATION'&#125;)// =&gt; &#123; constellation: \"射手座\" &#125; 更多API请参考 https://github.com/nuysoft/Mock/wiki‘ 更多实例请参考 http://mockjs.com/examples.html 可以一边看API、一边看实例，很容易就能上手","tags":[{"name":"mock","slug":"mock","permalink":"http://yoursite.com/tags/mock/"},{"name":"模拟数据","slug":"模拟数据","permalink":"http://yoursite.com/tags/模拟数据/"}]},{"title":"Markdown-Learning","date":"2017-03-23T03:21:16.000Z","path":"2017/03/23/Markdown-Learning/","text":"Markdown-Github Flavored Markdown常用操作Markdown拥有多种语法风格 标准风格-不支持表格 扩展风格-支持表格 github风格-Github Flavored Markdown它在标准风格上做了很多改进，如对表格的支持，针对不同编程语言实现代码高亮等 因为经常使用github，所以选择了Github Flavored Markdown风格。 Hexo搭建的博客也是使用github风格来解析markdown的。 win上支持Github Flavored Markdown风格的编辑器我常用的有:markdown pad2和typora。typora最让我心动的是支持快捷键创建表格，非常的方便。 标题12345# 一级标题## 二级标题，二级标题自带下划线### 三级标题...###### 六级标题 粗体斜体1234**两个星号为粗体***一个星号为斜体***粗中带 _斜_***内部换行用&lt;br&gt;,第二行* 引用1&gt; 这样引用 无序列表12345- 无序 - 我前面有2个空格，我能缩进 - 无序- 无序- 无序 有序列表12341. 第一行 1. 我前面有2个空格2. 第二行3. 第三行 任务列表123- [x] 我代表选中- [ ] 我没选中- [ ] 我没选中 图片与链接12[链接名](链接地址)![图片alt](图片地址) 代码段1使用`包裹的区域会形成代码段,区段内的 &amp;、&lt; 和 &gt; 都会被自动的转换成HTML实体，一般用在行内 代码块1使用三个`会产生格式化好的代码块,而 &amp;、&lt; 和 &gt; 也一样会自动转成HTML实体，一般用于一大段代码 代码块高亮123function show()&#123; console.log(\"我是带语法高亮的代码块，在三个`后添加上语言类型即可高亮\");&#125; 表格12345| Tables | Are | Cool || ------------- |:-------------:| -----:|| col 3 is | right-aligned | $1600 || col 2 is | centered | $12 || zebra stripes | are neat | $1 | Markdown中表格生成较为麻烦，建议使用编辑器快速生成,如typora中使用ctrl+t 分割线1***或--- 会产生分割线 还有很多东西因为没用到，所以不做介绍。更多的可以参考这 https://help.github.com/categories/writing-on-github/","tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://yoursite.com/tags/Markdown/"}]},{"title":"Handlebars-guide","date":"2017-03-17T10:48:09.000Z","path":"2017/03/17/Handlebars-guide/","text":"#HandleBars备忘 表达式{{xxx}} {{{xxxx}}}因为双大括号默认会进行HTML转义,将&lt;转换为&amp;lt;,通过三括号可以避免 Helper默认Helper{{#if a}}如果a为真执行这个{{/if}} {{#else}}否则执行这个{{/else}} {{#unless a}}当a为假的时候执行这个{{/unless}} {{#each obj}}遍历obj的每个属性{{/each}} #each内可以用{{@index}}获取当前遍历的索引值，用{{@key}}获取当前属性的属性名，用{{this}}可以获当前属性的值 如何获取父对象 可以通过{{../父对象某属性}}来获取父对象的某个属性，{{@../index}}获取父对象当前的所引值 {{#with obj}}xxx{{/with}}类似js中with，可改变作作用域，在each中也可通过#with 父对象名 来访问父对象 {{lookup xxx}}一般用来按照索引来找兄弟变量对应的值{{lookup ../父对象某属性 @index}}，查找父对象在当前索引下值 自定义Helper行级Helper语法{{helperName [普通值参数][hash值参数]}} {{customHelper \"My Text\" class=\"my-class\" visible=true counter=4}} Handlebars.registerHelper(&apos;customHelper&apos;, function() { console.log(arguments[0]);//==&gt;&quot;My Text&quot; console.log(arguments[1].hash);//==&gt;{class:&quot;my-class&quot;,visible:true,conter:4} }); 块级Helper语法{{#helperName context [普通值参数][hash值参数]}}xxxxxxxxx{{/helperName}} {{#customHelper nav \"normalValue\" class=\"my-class\" visible=true counter=4}} {{if name}} aaaaaa {{else}} bbbbbbb {{/if}} {{/customHelper}} Handlebars.registerHelper(&apos;customHelper&apos;, function(context,options) { console.log(arguments[0]);//==&gt;context console.log(arguments[1]);//==&gt;normalValue console.log(arguments[2]);//==&gt;options //说明在registerHelper内部,第二个参数匿名函数,只会存在3个实参，第一个为当前使用的上下文，第二个如果有则为一个普通值参数，另外一个就是封装了函数相关信息的options对象，它有hash(封装好一个或多个键值对参数)、fn(传入一个上下文，并在此上下文中执行customHelper模板中的{{#if}}到{{else}}中的模板)、inverse(同fn相反执行{{else}}到{{/if}}之间的)、name、data等属性。 }); 参考:http://cnodejs.org/topic/56a2e8b1cd415452622eed2dhttp://www.cnblogs.com/iyangyuan/archive/2013/12/12/3471227.html","tags":[{"name":"Handlebars","slug":"Handlebars","permalink":"http://yoursite.com/tags/Handlebars/"}]},{"title":"break-word、word-wrap、white-space","date":"2017-03-10T09:04:18.000Z","path":"2017/03/10/break-word-word-wrap-white-space/","text":"white-spacewhite-space的定义是用来设置如何处理元素中的空白。这里的空白指的是空格、tab制表符。 默认情况下，html中连续出现的多个空格会被合并成一个空格，Tab也会被替换成一个空格。回车换行(br换行不在内)会被忽略并将其替换成一个空格。当在容器剩余空间不足以容纳一个单词时，浏览器会在单词结束处自动换行。(默认情况下，是无法在一个单词内进行自动换行的，只能在结尾处换行。) 值 是否合并空白符(空格、tab) 是否忽略回车换行 是否允许自动换行 normal 合并 忽略 允许 nowrap 合并 忽略 不允许 pre 保留 保留 不允许 pre-wrap 保留 保留 允许 pre-line 合并 保留 允许 word-wrapword-wrap的定义是用来说明当一个不能被分开的字符串太长而不能填充其包裹盒时，为防止其溢出，浏览器是否允许这样的单词中断换行。既指明是否允许浏览器在单词内进行自动换行 值 解释 normal 在单词结束处换行 break-word 如果行内没有多余空间容纳该单词到行尾，则会强制将单词截断，在单词内进行换行 word-breakword-break指定了怎样在单词内断行 值 解释 normal 默认换行规则 break-all 对于non-CJK (中文/日文/韩文) 文本，可在任意字符间断行。 keep-all CJK 文本不断行。 Non-CJK 文本表现同 normal。 在white-space、word-wrap、word-break都为normal值时，既默认情况下时。一行的剩余空间不足以容纳一个单词时，浏览器会将这个单词挪到下一行显示。挪后如果这个单词比容器还长，则这个单词会直接溢出，因为默认情况下，浏览器是无法在单词内进行换行的。中文会一行空间不足以容纳一个字时，在字后进行换行 此时如果设置word-wrap:break-word，则会将这个长单词进行截断，从截断处进行换行。 可以发现第一行仍然有一点空间没有利用，此时就需要用到word-break:break-all; 可以说word-break:break-all是word-wrap:break-word的升级版本，它不会在剩余空间不够的时候将长单词挪到下一行，它将单词放在原位，并在容器边界处直接将这个长单词进行截断，然后换行。 将这三个属性，组合使用会怎么样 当设置了white-space:nowrap;时，word-wrap:break-word;和word-break:break-all;都将失效。文本将会强制在一行内显示 当同时设置word-wrap:break-word;和word-break:break-all时，word-break:break-all的效果会生效 word-spacing规定英文单词之间的间距 letter-spacing规定英文字符之间的间距 总结: 默认情况下，当一行的剩余空间不足以容纳某一单词时，浏览器会将此单词整体挪到下一行显示。此时，若这个单词超长(长度超出容器的宽度)，则此单词会直接溢出(此时上一行会留下一段空白)。 word-wrap:指明是否允许在长单词中换行，当设置其属性为break-word，则会把超过容器长度的单词进行截断，并换行(上一行留下的空白并不会被清除) word-break:当其设置break-all时，它是word-wrap:break-word的升级版，它能解决上一行留白问题。它会让单词先在当前行显示，当单词某个字符到达容器边界时，会直接在此字符出进行截断，并换行。这样就最大限度的利用了空间。 white-space:指定处理空白符的方式，比较有用的属性为nowrap，设置文本不换行。一般配合其它css实现文本过长省略号 word-spacing:规定英文单词之间的间距 letter-spacing:规定英文单词字符之间的间距 图片引用在自http://www.cnblogs.com/2050/archive/2012/08/10/2632256.html","tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]}]