[{"title":"Deferred_Promise","date":"2017-09-07T12:56:31.000Z","path":"2017/09/07/Deferred-Promise/","text":"在最近项目中经常会遇到异步处理的相关问题，在查阅相关资料后，特在此做一篇笔记。 使用Deferred、Promise解决jQuery中异步相关问题问题 ABC是3个异步请求，现在要求C在AB三个异步请求都成功返回的情况下再执行。这种就比较麻烦，可以尝试设置请求完成状态变量，当AB的请求完成变量都true时再请求C；如果不只3个请求，这种方法就会很糟糕。 ABC是3个异步请求，现在要求ABC3个请求按顺序依次执行，A-&gt;B-&gt;C。这种用传统方法可能就需要用回调嵌套的方法来实现 以上两种情况是在异步中经常遇到的，用传统方法编写，会导致嵌套层次过多，不仅影响可读性，还不易于维护。为了解决这种问题，CommonJs组织制定了异步编程规范Promises/A。这个规范有很多实现，如when.js、ES6的Promise等。今天就借助jQuery的Deferred、Promise对象来做个简单了解。 Promise状态Promise对象存在3种状态 pending(未完成状态) resolved(肯定状态) rejected(否定状态) 这三种状态的转换关系 pending-&gt;resolved pending-&gt;rejected pending-&gt;pending 当转换到resolved或者rejected状态时，状态是无法再发生变化，即下面的状态转换都是不可行的 resolved-&gt;rejected resolved-&gt;pending rejected-&gt;resolved rejected-&gt;pending 创建一个Promise对象在jQuery中Deferred可以理解为Promise的加强版，先不做区分，可以将Deferred当成就是Promise，后面会介绍二者区别。123456789var dfr=$.Deferred();// 创建一个Deferred对象(就是Promise对象)console.log(dfr.state());// 获取当前状态,pendingdfr.resolve();// 将Deferred对象状态改变为resolvedconsole.log(dfr.state());// resolvedvar dfr2=$.Deferred();console.log(dfr2.state());// 获取当前状态,pendingdfr.reject();// 将Deferred对象状态改变为rejectedconsole.log(dfr2.state());// rejected 状态的作用 通过上面的例子，我们可以知道，可以人为的改变Deferred对象的状态。状态不一样有什么用呢？我们可以根据不同的状态进行不同的操作(添加不同的回调函数)。 给Promise对象添加回调添加回调，并触发12345678910111213var dfr=$.Deferred();// 创建Deferred对象dfr.done(function()&#123;// Deferred对象状态变为resolved时的回调 alert('成功');&#125;).fail(function()&#123;// Deferred对象状态变为reject时的回调 alert('失败');&#125;).progress(function()&#123;// Deferred对象状态为pending时的回调 alert('进行中...');&#125;);dfr.notify(); // 触发Deferred对象pending状态的回调dfr.resolve();// 触发Deferred对象resolved状态的回调 通过done()、fail()、progress()给Deferred对象的不同状态分别添加了回调，并通过notify()、resolve触发了响应的回调 传递数据 通过done()、fail()、progress()触发Deferred对象的回调时，可传递一些数据(任何类型)给回调函数12345678910111213var dfr2=$.Deferred();// 创建Deferred对象dfr2.done(function(msg)&#123;// Deferred对象状态变为resolved时的回调 alert(msg+'成功');&#125;).fail(function(msg)&#123;// Deferred对象状态变为reject时的回调 alert(msg+'失败');&#125;).progress(function(msg)&#123;// Deferred对象状态为pending时的回调 alert(msg+'进行中...');&#125;);dfr2.notify('dfr2'); // dfr2进行中...dfr2.reject('dfr2');// dfr2失败 链式调用 done()、fail()、progress()会返回调用者对象Deferred对象，因此可以进行无限的链式调用；可以在done()后再添加done()、fail()、progress()，他们会在对应状态被激活时，依次按照添加顺序调用。12345678910111213141516var dfr=$.Deferred();dfr.done(function()&#123; // 回调1 alert('成功1');&#125;).fail(function()&#123; alert('失败');&#125;).progress(function()&#123; alert('进行中...');&#125;).done(function()&#123;// 回调2 alert('成功2');&#125;);dfr.resolve();// 成功1-&gt;成功2 deferred.always() 通过deferred.always()添加的回调，无论状态是resolved还是rejected都会在最后被调用12345678910111213141516var dfr=$.Deferred();dfr.done(function()&#123;// alert('成功1');&#125;).fail(function()&#123; alert('失败');&#125;).progress(function()&#123; alert('进行中...');&#125;).always(function()&#123; alert('我总会被执行');&#125;);dfr.resolve();// 成功1-&gt;我总会被执行 Deferred对象使用方式1234567891011var dfr = $.Deferred();// 创建一个Deferred对象var task = function(dtd) &#123; setTimeout(function() &#123; console.log('timeOut'); dtd.resolve(); // 异步任务结束，手动resolve &#125;, 3000); return dtd;// 返回Deferred对象，供$.when()使用&#125;;$.when(task(dfr)).done(function() &#123; alert('success');// 3s后弹出&#125;); 上面例子由于dfr是全局对象，并且包含改变状态的方法resolve、reject，所以可以在外部提前终止任务 123456789101112var dfr = $.Deferred();// 创建一个Deferred对象var task = function(dtd) &#123; setTimeout(function() &#123; console.log('timeOut'); dtd.resolve(); // 异步任务结束，手动resolve &#125;, 3000); return dtd;// 返回Deferred对象，供$.when()使用&#125;;$.when(task(dfr)).done(function() &#123; alert('success');// 立即弹出&#125;);dfr.resolve();// 外部resolve后会立即执行done 防止外部终止，可以将全局的dfr放到函数内部 123456789101112var task = function() &#123; var dfr = $.Deferred();// 创建一个Deferred对象 setTimeout(function() &#123; console.log('timeOut'); dfr.resolve(); // 异步任务结束，手动resolve &#125;, 3000); return dfr;// 返回Deferred对象，供$.when()使用&#125;;$.when(task()).done(function() &#123; alert('success');// 立即弹出&#125;);dfr.resolve();// 无法调用 jQuery中Deferred和Promise的区别 Deferred对象可以理解为Promise对象的加强版。 Deferred对象包含改变状态的方法，如dfr.resolve()、dfr.reject()、dfr.notify() Promise对象则不包含以上方法； 要想改变状态必须在Deferred对象上调用相关方法，Promise对象没有相关方法。 通过deferred.promise()可以将Deferred对象转换为Promise对象 在ajax中使用Promiseajax和Promise的关系 在jQuery1.5之前$.ajax()返回的是一个jqXHR对象，1.5之后返回的是一个类Promise对象，它在原先的jqXHR对象基础上又添加一些Promise方法，因此我们能在$.ajax()之后链式调用Promise相关方法； 注意返回的是一个类Promise对象，因此它不包含改变状态的相关方法； 改变相关状态由ajax内部完成，无需手动调用相关方法(也无法调用)；1234567891011121314151617// 老的ajax写法 $.ajax(&#123; url: \"a.html\", success: function()&#123; alert(\"成功\"); &#125;, error:function()&#123; alert(\"错误\"); &#125; &#125;); // 使用promise后的写法 $.ajax(\"test.html\") .done(function()&#123;&#125;) .fail(function()&#123;&#125;) .done(function()&#123;&#125;) .fail(function()&#123;&#125;); 解决问题1 问题1要求C在AB都执行完后再执行。即A&amp;&amp;B-&gt;C；这时候就需要使用jQuery提供的$.when()函数。$.when()返回一个Promise对象。所以可以调用done、fail、progress等函数 12345678$.when($.ajax(url1),$.ajax(url2)).done(function()&#123; console.log('url1、url2都请求成功'); $.ajax(url3)&#125;).fail(function()&#123; console.log('url1、url2有一个或者两个没请求成功');&#125;); $.when()实现了多个ajax请求完成后再执行某些操作；即实现了A&amp;&amp;B-&gt;C的效果 解决问题2 问题2的要求是ABC3个异步请求顺序执行。传统写法可能是 1234567891011121314$.ajax(&#123; url:'a.json', success:function()&#123; $.ajax(&#123; url:'b.json', success:function()&#123; $.ajax(&#123; url:'c.json', success:function()&#123; console.log('gg'); &#125; &#125; &#125;&#125;); 可读性很差，还不方便维护。为解决问题2需要使用到jQuery提供的Deferred.then()方法； then方法可以传入3个回调，分别是resolved、rejected、pending状态的回调； 123456789101112131415161718192021222324252627function success(data) &#123; alert(\"success data = \" + data); &#125; function fail(data) &#123; alert(\"fail data = \" + data); &#125; function progress(data) &#123; alert(\"progress data = \" + data); &#125; var deferred = $.Deferred(); // 一起注册回调 deferred.then(success, fail, progress); // 分别注册回调 deferred.done(success); deferred.fail(fail); deferred.progress(progress); deferred.notify(\"10%\"); deferred.resolve(\"ok\"); 其实在执行then方法后将返回一个新的Promise对象 可以在后面无限级联调用相关Promise方法.then().then().done().fail()…. 这就意味着在then后就无法在返回对象(返回的是Promise对象)上手动改变状态了。 必须在原先的Deferred对象上调用方法改变状态12345678910111213141516171819202122232425function success(data) &#123; alert(\"success data = \" + data); &#125; function fail(data) &#123; alert(\"fail data = \" + data); &#125; function progress(data) &#123; alert(\"progress data = \" + data); &#125; var dfr=$.Deferred();var pro=dfr.then(success,fail,progress);console.log(dfr===pro);// false// 没有改变状态的方法console.log('resolve' in pro); // falseconsole.log('reject' in pro); // falseconsole.log('notify' in pro); // false// 只能在原先的Deferred对象调用相关方法dfr.resolve('resolved'); // success data = resolved 其实then()中传入的不是回调函数，官方说法又叫做过滤函数；前面说过Deferred对象在调用改变状态方法时，可以传递数据，其实通过then注册的回调可以对数据进行过滤，然后通过return将数据传递给下一个回调函数(done、fail、progress)，如果下一个回调函数是通过then注册的，则可以继续对数据进行过滤，并传递给下一个对应状态的回调函数； 我们知道deferred.resolve()、deferred.reject()、deferred.notify()可以指定参数值，这个参数会传递给相应状态下的回调函数。 如果我们使用的是done()、fail()、progress()注册的回调函数，那么某个状态下的所有回调函数得到的都是相同参数。 不是通过then注册的回调函数，无法对数据过滤并通过return传递给下一个回调，他们得到的都是相同值，可看下面例子 1234567891011121314var dfr = $.Deferred();dfr.done(function(type) &#123; console.log(type);// resolved return type + 'first';&#125;).done(function(type) &#123; console.log(type);// resolved return type + 'last';&#125;).done(function(type) &#123; console.log(type);// resolved&#125;);dfr.resolve('resolved'); 但是如果我们使用了then()注册回调函数，那么第一回调函数的返回值将作为第二个回调函数的参数，同样的第二个函数的返回值是第三个回调函数的参数。 12345678910111213141516var deferred = $.Deferred(); // then()返回的是一个新Promise对象 //then注册的回调函数的返回值将作为这个新Promise的参数 var then_ret = deferred.then(function(data)&#123; alert(\"data=\"+data);//5 对数据进行过滤 return 2 * data; // 并通过return 传递给下一个done&#125;); alert(then_ret == deferred);//false then_ret.done(function(data)&#123; alert(\"data=\"+data);//10 &#125;); deferred.resolve( 5 ); 如果仔细观察，会发现在上面例子中，我们返回的是普通值，如果我们返回的是Deferred或者Promise对象，它会将返回的Deferred、Promise对象的状态和返回值传递给下一个回调函数，做为其触发依据和参数。可以用这种方法解决问题2 12345678910var promise1 = $.ajax(url1); var promise2 = promise1.then(function(data)&#123; return $.ajax(url2, &#123; \"data\": data &#125;);// 返回一个promise，它的状态将决定触发promise2.then中的哪个回调，它的返回值将传递给对应的回调函数&#125;); var promise3 = promise2.then(function(data)&#123; return $.ajax(url3);// 返回一个promise，它的状态将决定触发promise3中的哪个回调，它的返回值将传递给对应的回调函数&#125;); promise3.done(function(data)&#123; console.log(data);&#125;); 这样其实我们可以得到一个范式，处理有依赖关系的异步请求时，可以.then().then().done().fail()，通过then中的回调(过滤)函数，对数据进行加工，最后交给不是通过then注册的done或者fail来进行最后处理；done其实就预示着对传过来的数据不进行加工了； 总结 jQuery中的Deferred、Promise对象主要用来解决异步任务中嵌套问题 Deferred可以理解为Promise对象的加强版 Deferred对象拥有方法resolve、reject、notify来手动改变状态 Promise对象无法手动改变状态 deferred.promise()可以将一个Deferred对象转换成Promise对象 jQuery中异步任务返回的都是Promise对象或者类Promise对象(ajax返回的)，它们都无法手动改变状态，它们状态的改变是jQuery在内部自动完成的 $.Deferred()返回一个Deferred对象 deferred.done、deferred.fail、deferred.progress用来定义Deferred对象状态对应的回调函数 deferred.always()来用定义无论成功还是失败都会调用回调函数 deferred.resolve()、deferred.reject()手动改变Deferred对象的状态 改变状态时，可以传递数据给回调函数 deferred.resolve(‘msg’) 防止改变状态方法在异步任务外调用 可将Deferred对象定义为异步任务内的局部变量 可以使用deferred.promise()转换成Promise对象 deferred.notify()用来触发deferred.progress定义的回调函数，实际可以用来完成进度条效果 deferred.then()会返回一个新的promise对象 then中定义的回调函数可以理解为过滤函数，可对resolve、reject中传递的数据进行加工、过滤，然后通过return传递给下一个回调函数 如果return的是Deferred或者Promise对象，它会将返回的Deferred、Promise对象的状态和返回值传递给下一个回调函数，做为其触发依据和参数。 A&amp;&amp;B-&gt;C类型异步任务可以使用$.when()来解决；见上面例子 范式123456$.when($.ajax(url1),$.ajax(url2)).done(function()&#123; $.ajax(url3);&#125;).fail(function()&#123; console.log('出错');); A-&gt;B-&gt;C类型异步任务可以使用Promise对象的then()来解决；见上面例子 范式12345678910111213$.ajax(url1).then(function(url1Data)&#123; return $.ajax(url2);&#125;).then(function(url2Data)&#123; return $.ajax(url3);&#125;).done(function(url3Data)&#123; // 最终成功处理&#125;).fail(function(url3Data)&#123; // 最终失败处理&#125;);","tags":[{"name":"异步","slug":"异步","permalink":"http://yoursite.com/tags/异步/"},{"name":"Promise","slug":"Promise","permalink":"http://yoursite.com/tags/Promise/"}]},{"title":"Bootstrap-table_API","date":"2017-09-07T12:44:29.000Z","path":"2017/09/07/Bootstrap-table-API/","text":"最近在项目中需要使用到表格控件，调研几个常用的表格控件(jquery-dataTable、list.js、jqGrid、Bootstrap-table)后，决定使用Bootstrap-table，特意将常用API记录下来，以备后用。源码可在这https://github.com/BryanAdamss/SourceSave/tree/master/Practice 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 引入bootstrap样式 --&gt; &lt;link rel=\"stylesheet\" href=\"./vendors/bootstrap-3.3.7-dist/css/bootstrap.min.css\"&gt; &lt;!-- 引入bootstrap-table样式 --&gt; &lt;link rel=\"stylesheet\" href=\"./vendors/bootstrap-table/bootstrap-table.css\"&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"btn-group hidden-xs\" id=\"js_caremaTableToolBar\" role=\"group\"&gt; &lt;a href=\"#\" class=\"btn btn-outline btn-default\"&gt;&lt;i class=\"glyphicon glyphicon-plus\" aria-hidden=\"true\"&gt;&lt;/i&gt;&lt;/a&gt; &lt;/div&gt; &lt;table id=\"js_caremaTable\" data-height=\"400\" data-icon-size=\"outline\" data-striped=\"true\"&gt; &lt;/table&gt; &lt;script src=\"./js/jquery.min.js\"&gt;&lt;/script&gt; &lt;!-- 引入bootstrap.js --&gt; &lt;script src=\"./vendors/bootstrap-3.3.7-dist/js/bootstrap.min.js\"&gt;&lt;/script&gt; &lt;!-- bootstrap-table主js --&gt; &lt;script src=\"./vendors/bootstrap-table/bootstrap-table.js\"&gt;&lt;/script&gt; &lt;!-- bootstrap-table本地化文件 --&gt; &lt;script src=\"./vendors/bootstrap-table/locale/bootstrap-table-zh-CN.js\"&gt;&lt;/script&gt; &lt;script&gt; var caremaTable = $('#js_caremaTable').bootstrapTable(&#123; url: './json/bootstrap_table_test.json', method: 'get', // 请求方式 uniqueId: 'id', // 每一行的唯一id，一般设置为主键列，此处用数据中的'id'做为每一行的唯一标识；可用在一些方法中如removeByUniqueId，不设置uniqueId时，调用此类方法会出错 search: true, // 启用搜索 sortable: true, // 全局配置，是否启用列排序；若为false，即使列上设置了sortable:true，列也无法进行排序 pagination: true, // 启用分页 sidePagination: 'client', // 设置在哪里进行分页，可选值为 'client' 或者 'server'。设置 'server'时，必须设置 服务器数据地址（url）或者重写ajax方法 showRefresh: true, // 启用刷新 showColumns: true, // 启用内容列下拉框 showToggle: true, // 是否显示 切换试图（table/card）按钮 showPaginationSwitch: true, // 是否显示切换分页按钮 toolbar: '#js_caremaTableToolBar', // 工具栏 cache: true, // 设置为 false 禁用 AJAX 数据缓存 singleSelect: false, // 设置True 将禁止radio、checkbox多选，并隐藏选择全部按钮 class: 'cgh_dfjakdjfklasjdfklajslkdfjlkaf', columns: [&#123; checkbox: true, // 此列为checkbox &#125;, // &#123; // radio: true // 此列为radio // &#125;, &#123; field: 'id', title: '编号', sortable: true, // 此列表头点击，可进行排序，前提必须是表格的sortable为true titleTooltip: '点击可进行排序', // 悬停tooltip width: '100px' &#125;, &#123; field: 'name', title: '名称', &#125;, &#123; field: 'place', title: '预置位' &#125;, &#123; field: 'userName', title: '连接用户名' &#125;, &#123; field: 'password', title: '连接密码' &#125;, &#123; field: 'channel', title: '远程频道' &#125;, &#123; field: 'lng', title: '经度' &#125;, &#123; field: 'lat', title: '纬度', &#125;, &#123; title: '操作', formatter: function(value, row, index) &#123; return '&lt;a href=\"javascript:;\" class=\"text-danger m-l js_delete\"&gt;删除&lt;/a&gt;' &#125;, events: &#123; // 按钮点击事件 'click .js_delete': function(e, value, row, index) &#123; console.log(e, value, row, index); if (confirm('确定删除此行吗？')) &#123; caremaTable.bootstrapTable('removeByUniqueId', row.id); // 当表格配置了uniqueId: 'id'时，可通过removeByUniqueId来删除当前行 // caremaTable.bootstrapTable('remove', &#123; // 删除name列值为'测试0'的行 // field: 'name', // values: ['测试0'] // 注意values必须是一个数组 // &#125;); // caremaTable.bootstrapTable('remove', &#123; // 删除当前行，由于id在创建数据时是唯一的，所以通过点击获取row中的id数据，然后删除id列值为row.id的行；不过还是建议通过配置uniqueId然后通过removeByUniqueId方法来删除 // field: 'id', // values: [row.id] // &#125;); &#125; &#125; &#125; &#125; ], onCheck: function(row) &#123; // 单独选中某一个check时触发 console.log('onCheck', row); &#125;, onUncheck: function(row) &#123; console.log('onUncheck', row); // uncheck某一个check时触发 &#125;, onCheckAll: function(rows) &#123; console.log('onCheckAll', rows); // 全选check时触发 &#125;, onUncheckAll: function(rows) &#123; console.log('onUncheckAll', rows); // uncheck所有check时触发 &#125; &#125;); // 常用方法 // 调用方法的语法：$('#table').bootstrapTable('method', parameter); // 全部方法请参阅http://bootstrap-table.wenzhixin.net.cn/zh-cn/documentation/#方法 // caremaTable.bootstrapTable('getSelections'); // 返回所选的行，当没有选择任何行的时候返回一个空数组。 // caremaTable.bootstrapTable('getAllSelections'); // 返回所有选择的行，包括搜索过滤前的，当没有选择任何行的时候返回一个空数组。 // caremaTable.bootstrapTable('getData'); // 获取当前加载的数据。 // caremaTable.bootstrapTable('getRowByUniqueId', 3); // 根据 uniqueId 获取行数据。 // caremaTable.bootstrapTable('load', data); // 加载数据到表格中，旧数据会被替换。 // caremaTable.bootstrapTable('showAllColumns'); // 显示所有列。 // caremaTable.bootstrapTable('hideAllColumns'); // 隐藏所有列。 // caremaTable.bootstrapTable('append'); // 添加数据到表格在现有数据之后。 // caremaTable.bootstrapTable('prepend'); // 插入数据到表格在现有数据之前。 // caremaTable.bootstrapTable('remove', &#123; field: 'id', values: someArr &#125;); // 从表格中删除数据，包括两个参数： field: 需要删除的行的 field 名称。values: 需要删除的行的值，类型为数组。 // caremaTable.bootstrapTable('removeAll'); // 删除表格所有数据。 // caremaTable.bootstrapTable('removeByUniqueId'); // 根据 uniqueId 删除指定的行。 // caremaTable.bootstrapTable('insertRow', &#123; index: 1, row: row &#125;); // 插入新行，参数包括：index: 要插入的行的 index。row: 行的数据，Object 对象。 // caremaTable.bootstrapTable('updateRow', &#123; index: 1, row: row &#125;); // 更新指定的行，参数包括：index: 要更新的行的 index。row: 行的数据，Object 对象。 // caremaTable.bootstrapTable('showRow', &#123; index: 1 &#125;); // 显示指定的行，参数包括：index: 要更新的行的 index 或者 uniqueId。isIdField: 指定 index 是否为 uniqueid。 // caremaTable.bootstrapTable('hideRow', &#123; index: 1 &#125;); // 隐藏指定的行，参数包括：index: 要更新的行的 index 或者 uniqueId。isIdField: 指定 index 是否为 uniqueid。 // caremaTable.bootstrapTable('checkAll'); // 选中所有行 // caremaTable.bootstrapTable('uncheckAll'); // uncheck所有行 // caremaTable.bootstrapTable('check', 0); // 选中第一行 // caremaTable.bootstrapTable('uncheck', 0); // 取消选中第一行 // caremaTable.bootstrapTable('checkBy', &#123; field: \"field_name\", values: [\"value1\", \"value2\", \"value3\"] &#125;); // 选中field_name为value1、value2、value3的行 // caremaTable.bootstrapTable('uncheckBy', &#123; field: \"field_name\", values: [\"value1\", \"value2\", \"value3\"] &#125;); // 取消选中field_name为value1、value2、value3的行 $(window).resize(function() &#123; // 防止thead和tbody在缩放情况下不对齐 caremaTable.bootstrapTable('resetView'); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","tags":[{"name":"表格","slug":"表格","permalink":"http://yoursite.com/tags/表格/"}]},{"title":"type-existence","date":"2017-08-04T08:08:31.000Z","path":"2017/08/04/type-existence/","text":"本来在《编写可维护性的javascript》中已经做过总结，但最近在使用上又出现一点问题，所以推翻以前的单独写篇关于类型检测和存在性检测的文章 类型检测和存在性检测必备知识点 哪些值会被转成false “”、0、NaN、false、null、undefined会在期待布尔值的地方被转成false; 非上面提及的值都会被转成true； 注意空对象(没有任何属性/方法的对象)也会视为true1234var a=&#123;&#125;;if(a)&#123; console.log(true);// true&#125; 声明和赋值 未声明(更未赋值)的变量 直接使用，会报错 1console.log(b);// Uncaught ReferenceError: b is not defined 如果通过typeof b来使用，则不会报错；因为typeof存在一个特殊的安全防范机制； 已声明未赋值的变量 会有默认值undefined123var a;console.log(a===undefined);// trueconsole.log(typeof a);// 'undefined' 注意:当未声明的变量使用typeof检测时，并不会报错，而且返回&#39;undefined&#39;；因为typeof存在一个特殊的安全防范机制； 1console.log(typeof b);// 'undefined'，并没有报错 总结 未声明和已声明未赋值的变量使用typeof检测时，都会返回&#39;undefined&#39; 访问对象上不存在的属性/方法时，并不会报错，而是返回一个undefined 1234var obj=&#123; a:3&#125;;console.log(obj.b);// undefined 类型检测-&gt;(判断值的类型) 首先变量是没有类型的，类型本质指的是变量持有的值的类型，一般说的变量类型，实际指的是变量持有的值的类型 判断类型主要用来，检测输入的参数是否为想要的类型 12345function test(fn)&#123; if(typeof fn==='function')&#123; // xxxxx &#125;&#125; 一般值 string、number、boolean、undefined-&gt;typeof来判断 null一般不用做类型检测，只有在变量是一个可预期的null值时，才用来判断1234var obj=null;if(obj===null)&#123; // xxx&#125; 引用值 自定义、非数组、非函数-&gt;使用obj instanceof constructor 12345678function People(name)&#123; this.name=name;&#125;var p=new People();console.log(p instanceof People);// truevar date=new Date();console.log(date instanceof Date);// true 函数-&gt;typeof 12function fn()&#123;&#125;console.log(typeof fn==='function');// 'function' 数组 es5的isArray 12var arr=[];console.log(Array.isArray(arr));// true Object.prototype.call(arr); 12var arr=[];console.log(Object.prototype.toString.call(arr)==='[object Array]'); 存在性 常用检测存在性的不足 12345var obj=&#123; b:0&#125;;if(b)&#123;&#125;// 如果b存在，则xxx；当b为\"\",0,NaN,false,null,undefined时，就无法检测；同理b&amp;&amp;b()也会出现类似问题，所以只有在明确知道要检测的值不会是\"\",0,NaN,false,null,undefined中的一种时才能用 变量是否存在(是否已经声明) 全局变量的存在性 1console.log('a' in window);// false;判断变量a在全局环境下是否声明 局部变量的存在性 局部变量无法用in判断，只能退而求其次用typeof，typeof无法准确判断出是未声明还是已声明未赋值，如下123var a;console.log(typeof a==='undefined');// true;a已经声明但未赋值 console.log(typeof b==='undefined');// true;b没有声明 对象的属性是否存在 一般属性-&gt;统一使用in 实例属性存在性-&gt;统一使用hasOwnProperty IE8及以下判断实例属性存在性-&gt;先判断hasOwnProperty的存在性，再调用hasOwnProperty123456var obj_a=&#123; test:'测试'&#125;;console.log('test' in obj_a);// trueconsole.log('toString' in obj_a);// true，能检测到原型链上的方法console.log(obj_a.hasOwnProperty('toString'));//false,obj_a并没有实例属性(方法)`toString`，`toString`存在于其原型对象上，hasOwnProperty无法检测到","tags":[{"name":"类型检测","slug":"类型检测","permalink":"http://yoursite.com/tags/类型检测/"},{"name":"存在性","slug":"存在性","permalink":"http://yoursite.com/tags/存在性/"}]},{"title":"Vue-guide","date":"2017-08-01T02:35:14.000Z","path":"2017/08/01/Vue-guide/","text":"VueJs官网教程学习笔记安装 兼容性:不支持IE8及以下版本浏览器；因为使用了IE8无法模拟的Object.defineProperty 开发版本-&gt;包含了完整的警告和调试模式 CLI-&gt;可以构建一个完整的vue项目 介绍 是一套构建用户界面的框架，本身只关注视图层，但可以和第三方库结合来构建复杂的spa Vue实例 构造器 Vue(选项对象) 123var vm = new Vue(&#123; // 选项&#125;); 可扩展Vue构造器 12345var MyComponent = Vue.extend(&#123; // 扩展选项&#125;)// 所有的 `MyComponent` 实例都将以预定义的扩展选项被创建var myComponentInstance = new MyComponent() 属性与方法 每个vue实例会代理其data对象里有所有属性，这些属性都是响应式的； $开头的为vue实例属性/方法 不要在实例属性或者回调函数中使用箭头函数，箭头函数会绑定上级context，this预期将不会是vue实例 实例生命周期 生命周期钩子-&gt;自定义事件 可以在选项对象中进行配置 生命周期钩子中的this指向实例化后的对象12345678910var vm = new Vue(&#123; data: &#123; a: 1 &#125;, created: function () &#123; // `this` 指向 vm 实例 console.log('a is: ' + this.a) &#125;&#125;)// -&gt; \"a is: 1\" 模板语法插值 文本 绑定文本 v-text 会将对应表达式求值后，当做字符串替换元素内的内容 {{ msg }} msg 改变时，视图也会发生改变;是v-text的简写，求值后，当做字符串替换 {{ }}处的内容;{{ }}中可以使用表达式，但不能使用语句，流程控制也不能用(使用三元表达式代替) {{ }}形式会和ng中的一样，存在首次加载闪烁的问题，如果是首屏内容，可以尝试使用v-text绑定 一次性插值 在元素上使用v-once指令，这样元素内部的所有数据绑定，只会显示第一次绑定时的数据，当数据发生变化时，它们都不会得到更新，可以用在不会发生改变的数据的绑定；1&lt;span v-once&gt;This will never change: &#123;&#123; msg &#125;&#125;,&#123;&#123; test &#125;&#125;&lt;/span&gt; 纯html v-html {{ }}和v-text会将数据当做纯文本处理，不会对其做html解析;v-html会将对应表达表达式当做html解析后，输出到元素内 属性(特性) v-bind 主要用来绑定特性 v-bind:title=&quot;test&quot; 将test绑定到元素的title特性上； 缩写 v-bind:href=&quot;url&quot;-&gt;:href=&quot;url&quot; 指令 指令是v-开头(ng中以ng-开头)，它的预期是一个单一js表达式(v-for除外) 可以带参数 12&lt;a v-bind:href=\"url\"&gt;&lt;/a&gt;&lt;a v-on:click=\"doSomething\"&gt; 修饰符 指令后通过添加.来附加修饰符（Modifiers），用于指出一个指令应该以特殊方式绑定。1&lt;form v-on:submit.prevent=\"onSubmit\"&gt;&lt;/form&gt;// submit时阻止默认行为 过滤器 vue2.0中没有预定义的过滤器了，所有filter都需要自定义 主要用在{{ }}和v-bind中，达到格式化输出文本的作用 可级联使用 可带参数1234567891011121314151617181920//使用&lt;!-- in mustaches --&gt;&#123;&#123; message | capitalize &#125;&#125;&lt;!-- in v-bind --&gt;&lt;div v-bind:id=\"rawId | formatId\"&gt;&lt;/div&gt;// 定义new Vue(&#123; // ... filters: &#123; capitalize: function (value) &#123; if (!value) return '' value = value.toString() return value.charAt(0).toUpperCase() + value.slice(1) &#125; &#125;&#125;)// 级联使用&#123;&#123; message | filterA | filterB &#125;&#125;// 带参数&#123;&#123; message | filterA('arg1', arg2) &#125;&#125;// 这里，filterA 是个拥有三个参数的函数。message 的值将会作为第一个参数传入。字符串 'arg1' 将作为第二个参数传给 filterA，表达式 arg2 的值将作为第三个参数。 缩写 v-bind 1234&lt;!-- 完整语法 --&gt;&lt;a v-bind:href=\"url\"&gt;&lt;/a&gt;&lt;!-- 缩写 --&gt;&lt;a :href=\"url\"&gt;&lt;/a&gt; v-on 1234&lt;!-- 完整语法 --&gt;&lt;a v-on:click=\"doSomething\"&gt;&lt;/a&gt;&lt;!-- 缩写 --&gt;&lt;a @click=\"doSomething\"&gt;&lt;/a&gt; 计算属性计算属性 可以将计算属性当成data中属性添加了一个getter方法，并返回一个新属性，但新属性依赖data中的属性； 123456789101112131415// jsvar vm = new Vue(&#123; el: '#example', data: &#123; message: 'Hello' &#125;, computed: &#123; // a computed getter reversedMessage: function () &#123; // `this` 指向vm实例，由于vm实例代理了所有data中的属性，所以this.message能被访问到 return this.message.split('').reverse().join('') &#125; &#125;&#125;);// 当data中的message发生变化时，reversedMessage也会重新计算 计算属性vsMethods 1&lt;p&gt;Reversed message: \"&#123;&#123; reversedMessage() &#125;&#125;\"&lt;/p&gt; 123456methods: &#123; reversedMessage: function () &#123; return this.message.split('').reverse().join('') &#125;&#125;// 这样也能实现反转的效果 不同点 计算属性是基于它们的依赖进行缓存的；如上面计算属性的例子，只要data中的message没有发生变化，computed中的reversedMessage都不会重新计算，每次访问reversedMessage都将会是之前缓存的数据； methods则不存在缓存一说，如上面methods例子，只要`Reversed message: \"{{ reversedMessage() }}\"`需要重新渲染，reversedMessage就会被重新调用并计算一次 计算setter 计算属性默认只有getter，可以提供setter方法12345678910111213141516// ...computed: &#123; fullName: &#123; // getter get: function () &#123; return this.firstName + ' ' + this.lastName &#125;, // setter set: function (newValue) &#123; var names = newValue.split(' ') this.firstName = names[0] this.lastName = names[names.length - 1] &#125; &#125;&#125;// ... watch 主要用来观测数据的变化，并进行一系列的操作 1234567&lt;div id=\"watch-example\"&gt; &lt;p&gt; Ask a yes/no question: &lt;input v-model=\"question\"&gt; &lt;/p&gt; &lt;p&gt;&#123;&#123; answer &#125;&#125;&lt;/p&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!-- Since there is already a rich ecosystem of ajax libraries --&gt;&lt;!-- and collections of general-purpose utility methods, Vue core --&gt;&lt;!-- is able to remain small by not reinventing them. This also --&gt;&lt;!-- gives you the freedom to just use what you're familiar with. --&gt;&lt;script src=\"https://unpkg.com/axios@0.12.0/dist/axios.min.js\"&gt;&lt;/script&gt;&lt;script src=\"https://unpkg.com/lodash@4.13.1/lodash.min.js\"&gt;&lt;/script&gt;&lt;script&gt;var watchExampleVM = new Vue(&#123; el: '#watch-example', data: &#123; question: '', answer: 'I cannot give you an answer until you ask a question!' &#125;, watch: &#123; // 如果 question 发生改变，这个函数就会运行 question: function (newQuestion) &#123; this.answer = 'Waiting for you to stop typing...' this.getAnswer() &#125; &#125;, methods: &#123; // _.debounce 是一个通过 lodash 限制操作频率的函数。 // 在这个例子中，我们希望限制访问yesno.wtf/api的频率 // ajax请求直到用户输入完毕才会发出 // 学习更多关于 _.debounce function (and its cousin // _.throttle), 参考: https://lodash.com/docs#debounce getAnswer: _.debounce( function () &#123; if (this.question.indexOf('?') === -1) &#123; this.answer = 'Questions usually contain a question mark. ;-)' return &#125; this.answer = 'Thinking...' var vm = this axios.get('https://yesno.wtf/api') .then(function (response) &#123; vm.answer = _.capitalize(response.data.answer) &#125;) .catch(function (error) &#123; vm.answer = 'Error! Could not reach the API. ' + error &#125;) &#125;, // 这是我们为用户停止输入等待的毫秒数 500 ) &#125;&#125;)&lt;/script&gt; 什么时候用computed、methods、watch computed主要用在根据原有属性，进行计算，返回新属性的操作；即适合用在对数据(属性)的set和get上 methods主要用来编写一些通用，没有什么依赖的方法。 watch主要用来观测数据(属性)的变化，当变化时进行一系列操作（异步操作或开销较大的操作） 总结 computed适合用来对数据进行set、get watch适合用来在数据变化时，进行大开销的操作 methods 用来编写通用的方法 Class与Style绑定绑定 HTML Class类似ng-class 对象语法 传一个对象，以动态切换class 1&lt;div v-bind:class=\"&#123; active: isActive &#125;\"&gt;&lt;/div&gt;// isActive为true时，则添加active样式类，为false则去除 可以传多个属性，进行动态切换class；并v-bind:class可以和普通class属性共存 123&lt;div class=\"static\" v-bind:class=\"&#123; active: isActive, 'text-danger': hasError &#125;\"&gt;&lt;/div&gt; 可以直接绑定data里的一个对象 12345678&lt;div v-bind:class=\"classObject\"&gt;&lt;/div&gt;// jsdata: &#123; classObject: &#123; active: true, 'text-danger': false &#125;&#125; 也可以绑定一个computed里的对象 1234567891011121314&lt;div v-bind:class=\"classObject\"&gt;&lt;/div&gt;// jsdata: &#123; isActive: true, error: null&#125;,computed: &#123; classObject: function () &#123; return &#123; active: this.isActive &amp;&amp; !this.error, 'text-danger': this.error &amp;&amp; this.error.type === 'fatal', &#125; &#125;&#125; 数组语法 可以把数组传递给v-bind:class，以应用一个class列表 123456&lt;div v-bind:class=\"[activeClass, errorClass]\"&gt;// jsdata: &#123; activeClass: 'active', errorClass: 'text-danger'&#125; 可以在数组中使用条件表达式 1&lt;div v-bind:class=\"[isActive ? activeClass : '', errorClass]\"&gt; 可以在数组中使用对象语法 1&lt;div v-bind:class=\"[&#123; active: isActive &#125;, errorClass]\"&gt; 绑定内联样式类似ng-style 对象语法 直接绑定一个对象，CSS属性名用驼峰式(camelCase) 123456&lt;div v-bind:style=\"&#123; color: activeColor, fontSize: fontSize + 'px' &#125;\"&gt;&lt;/div&gt;// jsdata: &#123; activeColor: 'red', fontSize: 30&#125; 数组语法 v-bind:style 的数组语法可以将多个样式对象应用到一个元素上1&lt;div v-bind:style=\"[baseStyles, overridingStyles]\"&gt; 多重值 从 2.3.0 起你可以为 style 绑定中的属性提供一个包含多个值的数组，常用于提供多个带前缀的值1&lt;div :style=\"&#123; display: ['-webkit-box', '-ms-flexbox', 'flex'] &#125;\"&gt; 条件渲染类似ng-if v-if 条件为true时，则渲染，将元素添加到DOM中，为false，则将其从dom中删除 1&lt;h1 v-if=\"ok\"&gt;Yes&lt;/h1&gt; 条件渲染一组 可以将需要条件渲染的元素放到&lt;template&gt;元素中，然后用v-if条件渲染12345&lt;template v-if=\"ok\"&gt; &lt;h1&gt;Title&lt;/h1&gt; &lt;p&gt;Paragraph 1&lt;/p&gt; &lt;p&gt;Paragraph 2&lt;/p&gt;&lt;/template&gt; v-else 可以使用v-else指令来表示v-if的”else块” 123456&lt;div v-if=\"Math.random() &gt; 0.5\"&gt; Now you see me&lt;/div&gt;&lt;div v-else&gt; Now you don't&lt;/div&gt; v-else元素必须紧跟在v-if或者v-else-if元素的后面——否则它将不会被识别 v-else-if 充当”else if块”；可链式调用 123456789101112&lt;div v-if=\"type === 'A'\"&gt; A&lt;/div&gt;&lt;div v-else-if=\"type === 'B'\"&gt; B&lt;/div&gt;&lt;div v-else-if=\"type === 'C'\"&gt; C&lt;/div&gt;&lt;div v-else&gt; Not A/B/C&lt;/div&gt; 类似于 v-else，v-else-if 必须紧跟在 v-if 或者 v-else-if 元素之后 用 key 管理可复用的元素 默认情况下，vue会尽可能的高效渲染元素，通常会复用已有元素而不是从头开始渲染。 123456789&lt;template v-if=\"loginType === 'username'\"&gt; &lt;label&gt;Username&lt;/label&gt; &lt;input placeholder=\"Enter your username\"&gt;&lt;/template&gt;&lt;template v-else&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input placeholder=\"Enter your email address\"&gt;&lt;/template&gt;// 这里的input会被复用，并不会因为if和else而渲染两个，只是改变placeholder，这样效率更高 有时，我们就是需要渲染两个，这是就需要使用key；如上面例子，为这两个input分别添加一个唯一的key值时，切换时，vue就不会复用他们，而是重新渲染一个 123456789&lt;template v-if=\"loginType === 'username'\"&gt; &lt;label&gt;Username&lt;/label&gt; &lt;input placeholder=\"Enter your username\" key=\"username-input\"&gt;&lt;/template&gt;&lt;template v-else&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input placeholder=\"Enter your email address\" key=\"email-input\"&gt;&lt;/template&gt;// 注意, &lt;label&gt; 元素仍然会被高效地复用，因为它们没有添加 key 属性。 v-show 通过切换元素的display属性，元素会一直保留在DOM中，并不会因为为false，就把元素从DOM中删除，这点和v-if不同 v-if和v-show v-if是通过增加、删除元素来达到显示/隐藏 v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。 v-show通过css切换(display属性)来显示/隐藏 v-show不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。 一般来说， v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件不太可能改变，则使用 v-if 较好。 v-if和v-for一起使用 v-for 具有比 v-if 更高的优先级；先循环，再判断显示隐藏 列表渲染v-for 数组迭代 12345678910111213141516&lt;ul id=\"example-2\"&gt; &lt;li v-for=\"(item, index) in items\"&gt; &#123;&#123; parentMessage &#125;&#125; - &#123;&#123; index &#125;&#125; - &#123;&#123; item.message &#125;&#125; &lt;/li&gt;&lt;/ul&gt;// jsvar example2 = new Vue(&#123; el: '#example-2', data: &#123; parentMessage: 'Parent', items: [ &#123; message: 'Foo' &#125;, &#123; message: 'Bar' &#125; ] &#125;&#125;); 渲染多个元素块-&gt;使用&lt;template&gt;包裹 123456&lt;ul&gt; &lt;template v-for=\"item in items\"&gt; &lt;li&gt;&#123;&#123; item.msg &#125;&#125;&lt;/li&gt; &lt;li class=\"divider\"&gt;&lt;/li&gt; &lt;/template&gt;&lt;/ul&gt; 对象迭代 在遍历对象时，是按 Object.keys() 的结果遍历，但是不能保证它的结果在不同的 JavaScript 引擎下是一致的。1234567891011121314&lt;div v-for=\"(value, key, index) in object\"&gt; &#123;&#123; index &#125;&#125;. &#123;&#123; key &#125;&#125; : &#123;&#123; value &#125;&#125;&lt;/div&gt;// jsnew Vue(&#123; el: '#repeat-object', data: &#123; object: &#123; firstName: 'John', lastName: 'Doe', age: 30 &#125; &#125;&#125;); 整数迭代 1234&lt;div&gt; &lt;!-- span会重复10次 --&gt; &lt;span v-for=\"n in 10\"&gt;&#123;&#123; n &#125;&#125; &lt;/span&gt;&lt;/div&gt; v-for和v-if 当它们处于同一节点， v-for 的优先级比 v-if 更高，这意味着 v-if 将分别重复运行于每个 v-for 循环中。相当于在for循环中，再用if判断； 123&lt;li v-for=\"todo in todos\" v-if=\"!todo.isComplete\"&gt; &#123;&#123; todo &#125;&#125;&lt;/li&gt; 如果想条件判断了再循环，可以先if再for 12345&lt;ul v-if=\"shouldRenderTodos\"&gt; &lt;li v-for=\"todo in todos\"&gt; &#123;&#123; todo &#125;&#125; &lt;/li&gt;&lt;/ul&gt; key vue默认会采取”就地复用”的策略,如果数据项的顺序被改变，Vue将不是移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性。123&lt;div v-for=\"item in items\" :key=\"item.id\"&gt; &lt;!-- 内容 --&gt;&lt;/div&gt; 建议尽可能使用 v-for 来提供 key ，除非迭代 DOM 内容足够简单，或者你是故意要依赖于默认行为来获得性能提升。因为它是 Vue 识别节点的一个通用机制， key 并不特别与 v-for 关联，key 还具有其他用途，我们将在后面的指南中看到其他用途。 数组更新检测 变异方法 会改变原数组的方法都为变异方法push()、pop()、shift()、unshift()、splice()、sort()、reverse()；所有变异方法(会改变原数组的方法)都会触发更新检测,若发现数组有变化，则会更新依赖它的地方 重塑数组 不会改变原数组的方法为非变异方法，非变异方法会返回一个新的数组；filter(), concat(), slice()都是非变异方法；当使用新返回的数组替换原先的数组时(重塑数组)，不用担心vue会丢弃现有DOM重新渲染，vue会智能的复用DOM元素，123example1.items = example1.items.filter(function (item) &#123; return item.message.match(/Foo/)&#125;); 注意 由于js的限制，vue不能检测下面变动的数组，将不会触发更新 当你利用索引直接设置一个项时，例如： vm.items[indexOfItem] = newValue 当你修改数组的长度时，例如： vm.items.length = newLength 解决方法 第一种问题，可以使用Vue.set或者splice方法 1234// Vue.setVue.set(example1.items, indexOfItem, newValue)// splice方法example1.items.splice(indexOfItem, 1, newValue) 第二种问题可以使用splice 1example1.items.splice(newLength) 显示过滤/排序结果 我们想要显示一个数组的过滤或排序副本，而不实际改变或重置原始数据。在这种情况下，可以创建返回过滤或排序数组的计算属性。123456789101112&lt;li v-for=\"n in evenNumbers\"&gt;&#123;&#123; n &#125;&#125;&lt;/li&gt;// jsdata: &#123; numbers: [ 1, 2, 3, 4, 5 ]&#125;,computed: &#123; evenNumbers: function () &#123; return this.numbers.filter(function (number) &#123; return number % 2 === 0 &#125;) &#125;&#125; 事件处理器监听事件 v-on 使用v-on监听事件 1234&lt;div id=\"example-1\"&gt; &lt;button v-on:click=\"counter += 1\"&gt;增加 1&lt;/button&gt; &lt;p&gt;这个按钮被点击了 &#123;&#123; counter &#125;&#125; 次。&lt;/p&gt;&lt;/div&gt; 缩写 v-on:click=&quot;xxx&quot;-&gt;@click=&quot;xxx&quot; 方法事件处理器 为事件指定一个处理函数123456789101112131415161718192021222324&lt;div id=\"example-2\"&gt; &lt;!-- `greet` 是在下面定义的方法名 --&gt; &lt;button v-on:click=\"greet\"&gt;Greet&lt;/button&gt;&lt;/div&gt;// jsvar example2 = new Vue(&#123; el: '#example-2', data: &#123; name: 'Vue.js' &#125;, // 在 `methods` 对象中定义方法 methods: &#123; greet: function (event) &#123; // `this` 在方法里指当前 Vue 实例 alert('Hello ' + this.name + '!') // `event` 是原生 DOM 事件 if (event) &#123; alert(event.target.tagName) &#125; &#125; &#125;&#125;)// 也可以用 JavaScript 直接调用方法example2.greet() // -&gt; 'Hello Vue.js!' 内联处理器方法 直接将处理逻辑写在v-on:click=之后 1234&lt;div id=\"example-3\"&gt; &lt;button v-on:click=\"say('hi')\"&gt;Say hi&lt;/button&gt; &lt;button v-on:click=\"say('what')\"&gt;Say what&lt;/button&gt;&lt;/div&gt; 传递event给内联处理器需要使用$event 1234567891011&lt;button v-on:click=\"warn('Form cannot be submitted yet.', $event)\"&gt; Submit&lt;/button&gt;// jsmethods: &#123; warn: function (message, event) &#123; // 现在我们可以访问原生事件对象 if (event) event.preventDefault() alert(message) &#125;&#125; 事件修饰符 事件中经常需要调用event.preventDefault() 或 event.stopPropagation()，为了简化操作，也为了让处理函数中只有业务逻辑没有事件相关细节，所以vue在v-on:上添加修饰符 .stop,.prevent,.capture,.self,.once 1234567891011121314&lt;!-- 阻止单击事件冒泡 --&gt;&lt;a v-on:click.stop=\"doThis\"&gt;&lt;/a&gt;&lt;!-- 提交事件不再重载页面 --&gt;&lt;form v-on:submit.prevent=\"onSubmit\"&gt;&lt;/form&gt;&lt;!-- 修饰符可以串联 --&gt;&lt;a v-on:click.stop.prevent=\"doThat\"&gt;&lt;/a&gt;&lt;!-- 只有修饰符 --&gt;&lt;form v-on:submit.prevent&gt;&lt;/form&gt;&lt;!-- 添加事件侦听器时使用事件捕获模式 --&gt;&lt;div v-on:click.capture=\"doThis\"&gt;...&lt;/div&gt;&lt;!-- 只当事件在该元素本身（比如不是子元素）触发时触发回调 --&gt;&lt;div v-on:click.self=\"doThat\"&gt;...&lt;/div&gt;&lt;!-- 点击事件将只会触发一次 --&gt;&lt;a v-on:click.once=\"doThis\"&gt;&lt;/a&gt; 使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 @click.prevent.self 会阻止所有的点击，而 @click.self.prevent 只会阻止元素上的点击。 键值修饰符 Vue 允许为 v-on 在监听键盘事件时添加关键修饰符 123456&lt;!-- 只有在 keyCode 是 13 时调用 vm.submit() --&gt;&lt;input v-on:keyup.13=\"submit\"&gt;&lt;!-- 同上 --&gt;&lt;input v-on:keyup.enter=\"submit\"&gt;&lt;!-- 缩写语法 --&gt;&lt;input @keyup.enter=\"submit\"&gt; 按键别名 .enter,.tab,.delete(捕获“删除”和“退格”键),.esc,.space,.up,.down,.left,.right 可以通过全局 config.keyCodes 对象自定义键值修饰符别名12// 可以使用 v-on:keyup.f1Vue.config.keyCodes.f1 = 112 修饰键 .ctrl,.alt,.shift,.meta 1234&lt;!-- Alt + C --&gt;&lt;input @keyup.alt.67=\"clear\"&gt;&lt;!-- Ctrl + Click --&gt;&lt;div @click.ctrl=\"doSomething\"&gt;Do something&lt;/div&gt; 滑鼠按键修饰符 .left,.right,.middle 表单控件绑定基础用法 v-model v-model可以实现表单控件的双向绑定；它会根据控件类型自动选取正确的方法来更新元素；类似ng-model v-model会忽略所有表单元素的value、checked、selected特性的初始值。因为它会选择Vue实例数据来作为具体的值。应该通过data选项声明初始值。 v-model在中文输入(IME)时不会更新，可以监听input事件 简单的表单 12345678&lt;!-- 文本 --&gt;&lt;input v-model=\"message\" placeholder=\"edit me\"&gt;&lt;p&gt;Message is: &#123;&#123; message &#125;&#125;&lt;/p&gt;&lt;!-- 多行文本 --&gt;&lt;span&gt;Multiline message is:&lt;/span&gt;&lt;p style=\"white-space: pre-line\"&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;&lt;br&gt;&lt;textarea v-model=\"message\" placeholder=\"add multiple lines\"&gt;&lt;/textarea&gt;&lt;!-- 在文本区域插值( &lt;textarea&gt;&lt;/textarea&gt; ) 并不会生效，应用 v-model 来代替 --&gt; 复选框 单个复选框，逻辑值 12&lt;input type=\"checkbox\" id=\"checkbox\" v-model=\"checked\"&gt;&lt;label for=\"checkbox\"&gt;&#123;&#123; checked &#125;&#125;&lt;/label&gt; 多个复选框，v-model需要绑定到同一个数组上 123456789101112131415&lt;input type=\"checkbox\" id=\"jack\" value=\"Jack\" v-model=\"checkedNames\"&gt;&lt;label for=\"jack\"&gt;Jack&lt;/label&gt;&lt;input type=\"checkbox\" id=\"john\" value=\"John\" v-model=\"checkedNames\"&gt;&lt;label for=\"john\"&gt;John&lt;/label&gt;&lt;input type=\"checkbox\" id=\"mike\" value=\"Mike\" v-model=\"checkedNames\"&gt;&lt;label for=\"mike\"&gt;Mike&lt;/label&gt;&lt;br&gt;&lt;span&gt;Checked names: &#123;&#123; checkedNames &#125;&#125;&lt;/span&gt;// jsnew Vue(&#123; el: '...', data: &#123; checkedNames: [] &#125;&#125;); 单选按钮 同一组，v-model需要绑定到同一个数组上12345678910111213141516&lt;div id=\"example-4\"&gt; &lt;input type=\"radio\" id=\"one\" value=\"One\" v-model=\"picked\"&gt; &lt;label for=\"one\"&gt;One&lt;/label&gt; &lt;br&gt; &lt;input type=\"radio\" id=\"two\" value=\"Two\" v-model=\"picked\"&gt; &lt;label for=\"two\"&gt;Two&lt;/label&gt; &lt;br&gt; &lt;span&gt;Picked: &#123;&#123; picked &#125;&#125;&lt;/span&gt;&lt;/div&gt;// jsnew Vue(&#123; el: '#example-4', data: &#123; picked: '' &#125;&#125;); select 单选 12345678910&lt;div id=\"example-5\"&gt; &lt;select v-model=\"selected\"&gt; &lt;option disabled value=\"\"&gt;请选择&lt;/option&gt; &lt;option&gt;A&lt;/option&gt; &lt;option&gt;B&lt;/option&gt; &lt;option&gt;C&lt;/option&gt; &lt;/select&gt; &lt;span&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/span&gt;&lt;/div&gt;// 如果 v-model 表达初始的值不匹配任何的选项，&lt;select&gt; 元素就会以”未选中”的状态渲染。在 iOS 中，这会使用户无法选择第一个选项，因为这样的情况下，iOS 不会引发 change 事件。因此，像以上提供 disabled 选项是建议的做法。 多选列表（绑定到一个数组） 12345678910111213141516&lt;div id=\"example-6\"&gt; &lt;select v-model=\"selected\" multiple style=\"width: 50px\"&gt; &lt;option&gt;A&lt;/option&gt; &lt;option&gt;B&lt;/option&gt; &lt;option&gt;C&lt;/option&gt; &lt;/select&gt; &lt;br&gt; &lt;span&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/span&gt;&lt;/div&gt;// jsnew Vue(&#123; el: '#example-6', data: &#123; selected: [] &#125;&#125;); 动态选项(使用v-for渲染) 123456789101112131415161718&lt;select v-model=\"selected\"&gt; &lt;option v-for=\"option in options\" v-bind:value=\"option.value\"&gt; &#123;&#123; option.text &#125;&#125; &lt;/option&gt;&lt;/select&gt;&lt;span&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/span&gt;// jsnew Vue(&#123; el: '...', data: &#123; selected: 'A', options: [ &#123; text: 'One', value: 'A' &#125;, &#123; text: 'Two', value: 'B' &#125;, &#123; text: 'Three', value: 'C' &#125; ] &#125;&#125;); 绑定value 对于单选按钮，勾选框及选择列表选项， v-model 绑定的 value 通常是静态字符串（对于勾选框是逻辑值）;但有时我们想绑定value到Vue实例的一个动态属性上 复选框 123456&lt;input type=\"checkbox\" v-model=\"toggle\" v-bind:true-value=\"a\" v-bind:false-value=\"b\"&gt;// 当选中时vm.toggle === vm.a// 当没有选中时vm.toggle === vm.b 单选按钮 123&lt;input type=\"radio\" v-model=\"pick\" v-bind:value=\"a\"&gt;// 当选中时vm.pick === vm.a select 1234567&lt;select v-model=\"selected\"&gt; &lt;!-- 内联对象字面量 --&gt; &lt;option v-bind:value=\"&#123; number: 123 &#125;\"&gt;123&lt;/option&gt;&lt;/select&gt;// 当选中时typeof vm.selected // -&gt; 'object'vm.selected.number // -&gt; 123 v-model的修饰符 .lazy在默认情况下， v-model 在 input 事件中同步输入框的值与数据 (除了 上述 IME 部分)，但你可以添加一个修饰符 lazy ，从而转变为在 change 事件中同步 12&lt;!-- 在 \"change\" 而不是 \"input\" 事件中更新 --&gt;&lt;input v-model.lazy=\"msg\" &gt; .number如果想自动将用户的输入值转为 Number 类型（如果原值的转换结果为 NaN 则返回原值），可以添加一个修饰符 number 给 v-model 来处理输入值 1&lt;input v-model.number=\"age\" type=\"number\"&gt; .trim如果要自动过滤用户输入的首尾空格，可以添加 trim 修饰符到 v-model 上过滤输入 1&lt;input v-model.trim=\"msg\"&gt; 组件vue中的组件很类似ng1中的directive，通过自定义的html元素扩展功能 使用组件 注册 全局注册 123456789101112131415161718// Vue.component('组件名',选项对象 );// 选项对象和new Vue()中的几乎一样，只有个别属性使用不一样；//组件名建议使用kebab-case(短横线隔开式)连接，不要使用camelCased(驼峰式)，因为html特性不区分大小写，类似ng1中的directive命名，为方便，同意使用kebab-case形式// Vue.component()；不存在类似函数的声明提升机制，所以全局组件必须在根实例之前注册&lt;div id=\"example\"&gt; &lt;my-component&gt;&lt;/my-component&gt;&lt;/div&gt;// 注册-&gt;在创建根实例之前注册Vue.component('my-component', &#123; template: '&lt;div&gt;A custom component!&lt;/div&gt;' // template必须只有一个跟节点，类似ng1&#125;)// 创建根实例new Vue(&#123; el: '#example'&#125;);// 渲染为&lt;div id=\"example\"&gt; &lt;div&gt;A custom component!&lt;/div&gt; // vue中自定义元素将直接被替换，类似ng1中定义指令时配置了replace:true&lt;/div&gt; 局部注册 通过使用组件选项对象中的components来注册，让其仅在一个实例/组件的作用域中可用12345678910var Child = &#123; template: '&lt;div&gt;A custom component!&lt;/div&gt;'&#125;;new Vue(&#123; el:'#test', components: &#123; // &lt;my-component&gt; 将只在父模板可用(#test实例的范围中使用) 'my-component': Child &#125;&#125;); is 在现有html上添加功能，类似ng1指令中的restrict:A-&gt;因为html的限制，某些标签下只能出现特定的标签，出现其他标签视为无效，如select下只能是option；所以变通的方法是采用is特性 12345678// 无效&lt;table&gt; &lt;my-row&gt;...&lt;/my-row&gt;&lt;/table&gt;// 有效&lt;table&gt; &lt;tr is=\"my-row\"&gt;&lt;/tr&gt;&lt;/table&gt; 下来源之一的字符串模板，此限制将不适用： &lt;script type=&quot;text/x-template&quot;&gt; JavaScript 内联模版字符串 .vue组件 data必须是函数 通过 Vue 构造器传入的各种选项大多数都可以在组件里用。data是一个例外，它必须是函数，若不是函数，Vue将发出警告 如果通过data函数返回一个对象(引用值)，那么注册的所有组件都将共用这个对象1234567891011121314151617&lt;div id=\"example-2\"&gt; &lt;simple-counter&gt;&lt;/simple-counter&gt; &lt;simple-counter&gt;&lt;/simple-counter&gt; &lt;simple-counter&gt;&lt;/simple-counter&gt;&lt;/div&gt;var data = &#123; counter: 0 &#125;;Vue.component('simple-counter', &#123; template: '&lt;button v-on:click=\"counter += 1\"&gt;&#123;&#123; counter &#125;&#125;&lt;/button&gt;', // 技术上 data 的确是一个函数了，因此 Vue 不会警告， // 但是我们返回给每个组件的实例的却引用了同一个data对象 data: function () &#123; return data &#125;&#125;);new Vue(&#123; el: '#example-2'&#125;); 父子组件如何通信 props down, events up; 父组件通过子组件的props接口，将数据传递给子组件；子组件通过事件的形式给父组件发送消息 proprs 组件期望获得的数据，有点类似ng1指令中的scope属性 123456789Vue.component('child', &#123; // 声明 props props: ['message'], // 就像 data 一样，prop 可以用在模板内 // 同样也可以在 vm 实例中像“this.message”这样使用 template: '&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;'&#125;);// 通过child组件的message接口将数据传入&lt;child message=\"hello!\"&gt;&lt;/child&gt; 动态prop 在模板中，要动态地绑定父组件的数据到子模板的 props，与绑定到任何普通的HTML特性相类似，就是用 v-bind。每当父组件的数据变化时，该变化也会传导给子组件 12345&lt;div&gt; &lt;input v-model=\"parentMsg\"&gt; &lt;br&gt; &lt;child v-bind:my-message=\"parentMsg\"&gt;&lt;/child&gt;&lt;/div&gt; 用v-bind绑定的数据发生发生变化时，会将变化传导到子组件 123456789101112131415161718192021222324&lt;div id=\"app\"&gt; &lt;child message='纯文本'&gt;&lt;/child&gt; &lt;child message='test1'&gt;&lt;/child&gt; &lt;child message='test2'&gt;&lt;/child&gt; &lt;child v-bind:message='test2'&gt;&lt;/child&gt;&lt;/div&gt;&lt;button&gt;点击&lt;/button&gt;var vm = new Vue(&#123; el: '#app', data: &#123; test1: '我是变量1', test2: '我是变量2' &#125;, components: &#123; 'child': &#123; props: ['message'], template: '&lt;h1&gt;&#123;&#123;message&#125;&#125;&lt;/h1&gt;' &#125; &#125;&#125;);document.querySelector('button').onclick = function() &#123; vm.test2 = '我是变量2，我被改变了'; console.log(vm);&#125;; 不要使用字面量形式传递数值，使用v-bind将其转化成表达式；下面例子，因为它是一个字面 prop，它的值是字符串 “1” 而不是 number。如果想传递一个实际的 number，需要使用 v-bind，从而让它的值被当作 JavaScript 表达式计算 1234&lt;!-- 传递了一个字符串 \"1\" --&gt;&lt;comp some-prop=\"1\"&gt;&lt;/comp&gt;&lt;!-- 传递实际的 number --&gt;&lt;comp v-bind:some-prop=\"1\"&gt;&lt;/comp&gt; 单向数据流 prop是单向的，只能父传递到子，反之则不行 父组件更新时，子组件的所有prop也将得到更新 遇到下面情况，可能需要修改prop中的数据 prop 作为初始值传入后，子组件想把它当作局部数据来用 解决方法 定义一个局部变量，并用 prop 的值初始化它1234props: ['initialCounter'],data: function () &#123; return &#123; counter: this.initialCounter &#125;&#125; prop 作为初始值传入，由子组件处理成其它数据输出 解决方法 定义一个计算属性，处理 prop 的值并返回123456props: ['size'],computed: &#123; normalizedSize: function () &#123; return this.size.trim().toLowerCase() &#125;&#125; 注意在 JavaScript 中对象和数组是引用类型，指向同一个内存空间，如果 prop 是一个对象或数组，在子组件内部改变它会影响父组件的状态。 prop验证 有时需要对传入组件的数据先进行验证再操作 12345678910111213141516171819202122232425262728293031Vue.component('example', &#123; props: &#123; // 基础类型检测 (`null` 意思是任何类型都可以) propA: Number, // 多种类型 propB: [String, Number], // 必传且是字符串 propC: &#123; type: String, required: true &#125;, // 数字，有默认值 propD: &#123; type: Number, default: 100 &#125;, // 数组/对象的默认值应当由一个工厂函数返回 propE: &#123; type: Object,// 注意是构造器，并不是字符串 default: function () &#123; return &#123; message: 'hello' &#125; &#125; &#125;, // 自定义验证函数 propF: &#123; validator: function (value) &#123; return value &gt; 10 &#125; &#125; &#125;&#125;); 验证时的type可以是:String、Number、Boolean、Function、Object、Array、Symbol 注意是构造器，不是字符串1234// 这样是错误的type:'Boolean'// 这样是对的type:Boolean 当 prop 验证失败，Vue 会在抛出警告 (如果使用的是开发版本)。注意 props 会在组件实例创建之前进行校验，所以在 default 或 validator 函数里，诸如 data、computed 或 methods 等实例属性还无法使用。 非Prop属性 所谓非 prop 属性，就是它可以直接传入组件，而不需要定义相应的 prop。 明确给组件定义 prop 是传参的推荐方式 非prop属性，将会被自动添加到模板的根元素上 123456&lt;!-- 有个非prop属性，data-3d-data-picker --&gt;&lt;bs-date-input data-3d-date-picker=\"true\"&gt;&lt;/bs-date-input&gt;&lt;!-- bs-data-input的模板 --&gt;&lt;input type=\"date\" class=\"form-control\"&gt;&lt;!-- 渲染后 --&gt;&lt;input type=\"date\" class=\"form-control\" data-3d-date-picker=\"true\"&gt; 替换/覆盖现有的特性 默认情况下，在发生特性冲突时，会采取覆盖策略，传递给组件的值会覆盖组件本身设定的值。即例如传递 type=”large” 将会覆盖 type=”date” class和style特性，在发生冲突时，会采取合并策略，而不是覆盖策略12345&lt;bs-date-input type=\"num\" data-3d-date-picker=\"true\" class=\"date-picker-theme-dark\"&gt;&lt;/bs-date-input&gt;&lt;!-- 模板 --&gt;&lt;input type=\"date\" class=\"form-control\"&gt;&lt;!-- 渲染后，传进来的type覆盖了原先的type，class实现了合并 --&gt;&lt;input type=\"num\" class=\"form-control date-picker-theme-dark\" data-3d-date-picker=\"true\"&gt; 自定义事件 可以通过props向子组件传递数据，子组件可以通过自定义事件向父组件发消息 每个vue实例都实现了事件接口 vm.$on(eventName)监听事件 vm.$emit(eventName)触发事件 父组件可以在使用子组件的地方直接用v-on来监听子组件触发的自定义事件，注意在子组件的自定义标签上直接使用v-on只能绑定子组件主动分发(通过$emit触发)的事件，这是一种特殊写法,告诉父组件要监听某个自定义事件。如果想直接使用v-on为子组件绑定事件，将无法触发；例子见下一小节 不能用 $on 侦听子组件抛出的事件，而必须在模板里直接用 v-on 绑定 12345678910111213141516171819202122232425262728293031323334353637&lt;div id=\"counter-event-example\"&gt; &lt;p&gt;&#123;&#123; total &#125;&#125;&lt;/p&gt; &lt;!-- 这里的v-on:increment=\"incrementTotal\"，其实在告诉父组件(这里是根实例)要监听increment事件了 --&gt; &lt;button-counter v-on:increment=\"incrementTotal\"&gt;&lt;/button-counter&gt; &lt;button-counter v-on:increment=\"incrementTotal\"&gt;&lt;/button-counter&gt;&lt;/div&gt;// jsVue.component('button-counter', &#123; template: '&lt;button v-on:click=\"incrementCounter\"&gt;&#123;&#123; counter &#125;&#125;&lt;/button&gt;', data: function () &#123; return &#123; counter: 0 &#125; &#125;, methods: &#123; incrementCounter: function () &#123; this.counter += 1; this.$emit('increment');// 分发'increment'自定义事件 &#125; &#125;,&#125;);new Vue(&#123; el: '#counter-event-example', data: &#123; total: 0 &#125;, methods: &#123; incrementTotal: function () &#123;// 接收到子组件分发'increment'自定义事件后触发 this.total += 1 &#125; &#125;&#125;);// 在v1版本中，子组件分发的自定义事件的触发函数是写在父组件的events中;// 这样写，有个不好的地方就是父组件不知道这个事件到底是哪个子组件分发的，如果多个子组件分发了同个自定义事件，就无法分辨。// 所以作者为了清晰的知道具体是哪个组件分发了事件，就将v-on移到了子组件的自定义标签上// https://v1.vuejs.org/guide/components.html#Custom-Events// https://segmentfault.com/q/1010000004486740/a-1020000004487413 给组件绑定原生事件 有时候，你可能想在某个组件的根元素上监听一个原生事件。 注意：在子组件的自定义标签上直接使用v-on:mouseenter，这种事件是无法直接触发的(只有子组件主动$emit了mouseenter事件，才会触发)，在子组件上直接使用v-on绑定的只能是子组件主动分发的事件，它是在告诉父组件要监听某个自定义事件，是一种特殊写法； 想为某个组件绑定一个原生事件(在某个组件的根元素上监听一个原生事件)，必须在自定义标签上使用v-on:事件.native=xxx 1234&lt;!-- 这个mouseenter绑定的回调无法触发，除非子组件主动$emit了mouseenter，count才会被调用 --&gt;&lt;button-counter v-on:child_increment=\"incrementTotal\" v-on:mouseenter=\"count\"&gt;&lt;/button-counter&gt;&lt;!-- v-on:mouseenter.native这种写法，给button-counter的根标签绑定了一个原生mouseenter事件，鼠标移入，就会触发count --&gt;&lt;button-counter v-on:child_increment=\"incrementTotal\" v-on:mouseenter.native=\"count\"&gt;&lt;/button-counter&gt; 小结 子组件的自定义标签上直接使用v-on只适合子组件发消息给父组件这种情况，并且需要子组件主动$emit配合，经过这两步才能完成子组件给父组发消息，具体步骤如下 子组件的自定义标签上直接使用v-on:子组件主动分发的事件名=xxx 子组件在条件合适时主动$emit(事件名) 想在子组件自定义标签上直接使用v-on给组件根元素绑定事件，必须添加.native修饰符 双向绑定.sync 当一个子组件改变了一个 prop 的值时，这个变化也会同步到父组件中所绑定的值。123456&lt;comp :foo.sync=\"bar\"&gt;&lt;/comp&gt;&lt;!-- 本质为下面的 --&gt;&lt;comp :foo=\"bar\" @update:foo=\"val =&gt; bar = val\"&gt;&lt;/comp&gt;&lt;!-- 子组件值变化时，主动触发update事件 --&gt;this.$emit('update:foo', newValue)&lt;!-- 其实这里的.sync也佐证了自定义标签上直接使用v-on绑定的事件，需要配合$emit才能触发 --&gt; v-model v-model常用来针对表单实行双向数据绑定，它的本质是个语法糖；value属性+input事件 123&lt;input v-model=\"something\"&gt;&lt;!-- 本质如下 --&gt;&lt;input v-bind:value=\"something\" v-on:input=\"something = $event.target.value\"&gt; 创建自定义input组件时 12345678910111213141516171819202122232425262728293031323334353637&lt;!-- 下面2种效果一样 --&gt;&lt;currency-input v-model=\"price\"&gt;&lt;/currency-input&gt;&lt;currency-input v-bind:value=\"price\" v-on:input=\"price = arguments[0]\"&gt;&lt;/currency-input&gt;Vue.component('currency-input', &#123; template: '&lt;span&gt;$&lt;input ref=\"input\" v-bind:value=\"value\" v-on:input=\"updateValue($event.target.value)\"&gt;&lt;/span&gt;', props: &#123; value: Number &#125;, methods: &#123; // 不是直接更新值，而是使用此方法来对输入值进行格式化和位数限制 updateValue: function(value) &#123; var formattedValue = value // 删除两侧的空格符 .trim() // 保留 2 小数位 .slice( 0, value.indexOf('.') === -1 ? value.length : value.indexOf('.') + 3 ) // 如果值不统一，手动覆盖以保持一致 if (formattedValue !== value) &#123; this.$refs.input.value = formattedValue &#125; // 通过 input 事件发出数值 this.$emit('input', Number(formattedValue)) &#125; &#125;&#125;);var vm = new Vue(&#123; el: '#app', data: &#123; price: 3 &#125;&#125;); 定制v-model 从上节可知，v-model需要使用到表单的value属性和input事件，但单选、复选之类的表单会把value用做别的目的；此时使用组件选项对象的model选项即可避免冲突1234567891011121314151617181920Vue.component('my-checkbox', &#123; model: &#123;// v-model使用checked属性和change事件完成双向绑定，而不用原来的value属性和input属性 prop: 'checked', event: 'change' &#125;, props: &#123; checked: Boolean, // this allows using the `value` prop for a different purpose，value属性可以用做其他用途 value: String &#125;, // ...&#125;);&lt;my-checkbox v-model=\"foo\" value=\"some value\"&gt;&lt;/my-checkbox&gt;&lt;!-- 等价于 --&gt;&lt;my-checkbox :checked=\"foo\" @change=\"val =&gt; &#123; foo = val &#125;\" value=\"some value\"&gt;&lt;/my-checkbox&gt; 非父子组件通信 有时，非父子关系的组件也需要通信，这时需要一个中介来传递信息，在简单的场景下，可以使用一个空的 Vue 实例作为中央事件总线 1234567var bus = new Vue();// 触发组件 A 中的事件bus.$emit('id-selected', 1);// 在组件 B 创建的钩子中监听事件bus.$on('id-selected', function (id) &#123; // ...&#125;); 案例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;div id=\"app\"&gt; &lt;my-num :init-num=\"price\"&gt;&lt;/my-num&gt; &lt;my-div&gt;&lt;/my-div&gt;&lt;/div&gt;Vue.component('my-num', &#123; template: '&lt;input type=\"num\" v-model=\"num\" @input=\"numChanged\"&gt;', props: &#123; 'initNum': &#123; type: Number &#125; &#125;, data: function() &#123; return &#123; num: this.initNum &#125;; &#125;, methods: &#123; numChanged: function() &#123; console.log(this.num); bus.$emit('my-num-change', this.num); // 通过bus触发my-num-change &#125; &#125;&#125;);Vue.component('my-div', &#123; template: '&lt;h1&gt;&#123;&#123;text&#125;&#125;&lt;/h1&gt;', data: function() &#123; return &#123; text: '我将展示上面input的内容' &#125;; &#125;, created: function() &#123; // 创建后 var _self = this; bus.$on('my-num-change', function(str) &#123; // 监听my-num-change事件 _self.text = str; &#125;); &#125;&#125;);var bus = new Vue();var vm = new Vue(&#123; el: '#app', data: &#123; price: 3 &#125;&#125;); 使用Slot分发内容类似ng1中指令的transclude，用来混合父组件的内容和子组件的模板 编译作用域 父组件模板的内容在父组件作用域内编译；子组件模板的内容在子组件作用域内编译。1234567891011121314151617181920212223242526272829// message将在父组件/实例的作用域中编译，因为&#123;&#123;message&#125;&#125;实际是在父组件模板的内容中，而不是在子组件的模板内容中&lt;child-component&gt; &#123;&#123; message &#125;&#125;&lt;/child-component&gt;// 下例&#123;&#123;test&#125;&#125;、&#123;&#123;test2&#125;&#125;都将在根实例的作用域下编译&lt;div id=\"app\"&gt; &lt;parent-comp&gt; &#123;&#123;test&#125;&#125; &lt;br&gt; &lt;child-comp&gt; &#123;&#123;test2&#125;&#125; &lt;/child-comp&gt; &lt;/parent-comp&gt;&lt;/div&gt;// 假设someChildProperty是子组件上的属性，下面例子无效，将在父组件/实例的作用域中查找someChildProperty，你必须在child-component作用域中使用someChildProperty&lt;child-component v-show=\"someChildProperty\"&gt;&lt;/child-component&gt;// 下面有效Vue.component('child-component', &#123; // 有效，因为是在正确的作用域内 template: '&lt;div v-show=\"someChildProperty\"&gt;Child&lt;/div&gt;', data: function () &#123; return &#123; someChildProperty: true &#125; &#125;&#125;); 分发内容 父组件/实例中嵌套在子组件自定义便签中的内容都称为分发内容 分发内容是在父作用域内编译 分发内容适合混合/嵌套多个组件时使用1234&lt;!-- &#123;&#123;message&#125;&#125;属于分发内容，他将在child-component的父作用域中编译 --&gt;&lt;child-component&gt; &#123;&#123; message &#125;&#125;&lt;/child-component&gt; slot 除非子组件模板包含至少一个&lt;slot&gt;插口，否则父组件的内容将会被丢弃。类似ng1中directive模板中会指定一个标签，添加ng-transclude特性一样，这个标签将接收在父作用域中编译好的分发内容 当子组件模板只有一个没有属性的slot时，父组件整个内容片段将插入到slot所在的DOM位置，并替换掉slot标签本身 最初在 标签中的任何内容都被视为备用内容。备用内容在子组件的作用域内编译，并且只有在宿主元素为空，且没有要插入的内容时才显示备用内容。12345678910111213141516171819202122232425// 父组件模板 &lt;div&gt; &lt;h1&gt;我是父组件的标题&lt;/h1&gt; &lt;my-component&gt; &lt;p&gt;这是一些初始内容&lt;/p&gt; &lt;p&gt;这是更多的初始内容&lt;/p&gt; &lt;/my-component&gt;&lt;/div&gt;// 子组件my-component的模板&lt;div&gt; &lt;h2&gt;我是子组件的标题&lt;/h2&gt; &lt;slot&gt; 只有在没有要分发的内容时才会显示。&lt;slot&gt;整个标签将被分发内容替换 &lt;/slot&gt;&lt;/div&gt;// 渲染后&lt;div&gt; &lt;h1&gt;我是父组件的标题&lt;/h1&gt; &lt;div&gt; &lt;h2&gt;我是子组件的标题&lt;/h2&gt; &lt;!-- 下面是分发内容替换了&lt;slot&gt; --&gt; &lt;p&gt;这是一些初始内容&lt;/p&gt; &lt;p&gt;这是更多的初始内容&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 具名slot &lt;slot&gt;元素可以用一个特殊的属性 name 来配置如何分发内容。多个 slot 可以有不同的名字。具名 slot 将匹配内容片段中有对应 slot 特性的元素 仍然可以有一个匿名 slot，它是默认 slot，作为找不到匹配的内容片段的备用插槽。如果没有默认的 slot，这些找不到匹配的内容片段将被抛弃。 子组件模板上有个&lt;slot&gt;标签，通过标签上的name属性来给&lt;slot&gt;起个名字，分发内容上有个slot特性，通过这个slot特性的值找到子组件中对应名字的&lt;slot&gt;标签，并用分发内容将其替换掉。1234567891011121314151617181920212223242526272829303132// app-layout组件&lt;div class=\"container\"&gt; &lt;header&gt; &lt;slot name=\"header\"&gt;&lt;/slot&gt; // 这里将要放名字为header的分发内容 &lt;/header&gt; &lt;main&gt; &lt;slot&gt;&lt;/slot&gt;// 这里将要找不到匹配的分发内容 &lt;/main&gt; &lt;footer&gt; &lt;slot name=\"footer\"&gt;&lt;/slot&gt;// 这里将要放名字为footer的分发内容 &lt;/footer&gt;&lt;/div&gt;// 父组件模板&lt;app-layout&gt;// 这里面的都是分发内容 &lt;h1 slot=\"header\"&gt;这里可能是一个页面标题&lt;/h1&gt; // 这个将放到header的slot中 &lt;p&gt;主要内容的一个段落。&lt;/p&gt; &lt;p&gt;另一个主要段落。&lt;/p&gt; &lt;p slot=\"footer\"&gt;这里有一些联系信息&lt;/p&gt;// 这个将放到footer的slot中&lt;/app-layout&gt;// 渲染后&lt;div class=\"container\"&gt; &lt;header&gt; &lt;h1&gt;这里可能是一个页面标题&lt;/h1&gt; &lt;/header&gt; &lt;main&gt; &lt;p&gt;主要内容的一个段落。&lt;/p&gt; &lt;p&gt;另一个主要段落。&lt;/p&gt; &lt;/main&gt; &lt;footer&gt; &lt;p&gt;这里有一些联系信息&lt;/p&gt; &lt;/footer&gt;&lt;/div&gt; 作用域插槽(Scoped Slot) 正常情况下，分发内容是在父组件的作用域中编译的；考虑下面情况:我们需要创建一个组件，能使用同一份数据，根据DOM的不同渲染出不一样的界面；同一个组件，有不同的DOM结构，我们肯定不能将DOM结构固死在组件内部，肯定需要外部传入，我们很快就想到需要使用分发内容和Slot来完成，但这样会出现一个问题。我们的DOM结构是通过分发内容传入组件内部的，但是分发内容在传入子组件时，已经在父组件的作用域中编译过了，也就是说它用的数据是父组件的而不是子组件的。Scoped Slot就能解决这一问题，它能让分发内容在传入子组件前使用子组件的数据；以前分发内容只能在父组件作用域中编译，根本无法使用到子组件的数据，现在使用Scoped Slot能实现分发内容使用子组件的数据编译。这样能提高组件的复用性。 如何使用 在子组件模板&lt;slot&gt;标签上绑定需要暴露的数据(提供给父组件使用的数据)，这些数据会被封装到一个对象上，传递给父级 在父级上，必须有一个包含scope属性的&lt;template&gt;元素，表示它是作用域插槽的模板 scope的值对应一个临时变量名，此变量接收从子组件中传递过来的对象 实际例子 现在要实现一个列表组件，可以让用户自定义DOM结构12345678910111213141516171819202122232425262728293031&lt;div id=\"app\"&gt; &lt;my-awesome-list :items=\"items\"&gt; &lt;!-- 作用域插槽也可以是具名的,componProp就是子组件传递过来的对象 --&gt; &lt;template slot=\"list-item\" scope=\"componProp\"&gt; &lt;!-- 这里我可以使用任意的结构来渲染list --&gt; &lt;!-- &lt;h1&gt;&#123;&#123; componProp.text &#125;&#125;&lt;/h1&gt; --&gt; &lt;div style=\"font-style: italic;\"&gt;&#123;&#123; componProp.text &#125;&#125;&lt;/div&gt; &lt;/template&gt; &lt;/my-awesome-list&gt;&lt;/div&gt; Vue.component('my-awesome-list', &#123; props: &#123; items: &#123; type: Array, required: true &#125; &#125;, template: '&lt;div&gt;&lt;slot name=\"list-item\" v-for=\"item in items\" :text=\"item.text\"&gt;&lt;/slot&gt;&lt;/div&gt;'// 暴露text给分发内容使用&#125;); var vm = new Vue(&#123; el: '#app', data: &#123; items: [&#123; text: '11111' &#125;, &#123; text: '22222' &#125;] &#125;&#125;); 动态组件 通过使用保留的 元素，动态地绑定到它的 is 特性，我们让多个组件可以使用同一个挂载点，并动态切换 123456789101112131415&lt;component v-bind:is=\"currentView\"&gt; &lt;!-- 组件在 vm.currentview 变化时改变！ --&gt;&lt;/component&gt;var vm = new Vue(&#123; el: '#example', data: &#123; currentView: 'home' &#125;, components: &#123; home: &#123; /* ... */ &#125;, posts: &#123; /* ... */ &#125;, archive: &#123; /* ... */ &#125; &#125;&#125;); 也可以直接绑定到组件对象上 123456789var Home = &#123; template: &apos;&lt;p&gt;Welcome home!&lt;/p&gt;&apos;&#125;var vm = new Vue(&#123; el: &apos;#example&apos;, data: &#123; currentView: Home &#125;&#125;) 动态组件配合使用&lt;keep-alive&gt;来缓存非活动组件，避免重新渲染 12345&lt;keep-alive&gt; &lt;component :is=&quot;currentView&quot;&gt; &lt;!-- 非活动组件将被缓存！ --&gt; &lt;/component&gt;&lt;/keep-alive&gt; 杂项 编写可复用组件 Props 允许外部环境传递数据给组件 Events 允许从外部环境在组件内触发副作用 Slots 允许外部环境将额外的内容组合在组件中 子组件索引 尽管有 props 和 events，但是有时仍然需要在 JavaScript 中直接访问子组件。为此可以使用 ref 为子组件指定一个索引 ID 123456&lt;div id=\"parent\"&gt; &lt;user-profile ref=\"profile\"&gt;&lt;/user-profile&gt;&lt;/div&gt;var parent = new Vue(&#123; el: '#parent' &#125;);// 访问子组件var child = parent.$refs.profile 当 ref 和 v-for 一起使用时，ref 是一个数组，包含相应的子组件 $refs 只在组件渲染完成后才填充，并且它是非响应式的。它仅仅作为一个直接访问子组件的应急方案——应当避免在模版或计算属性中使用 $refs。 异步组件 在大型应用中，我们可能需要将应用拆分为多个小模块，按需从服务器下载。为了让事情更简单，Vue.js 允许将组件定义为一个工厂函数，动态地解析组件的定义。Vue.js 只在组件需要渲染时触发工厂函数，并且把结果缓存起来，用于后面的再次渲染。 12345678Vue.component(&apos;async-example&apos;, function (resolve, reject) &#123; setTimeout(function () &#123; // Pass the component definition to the resolve callback resolve(&#123; template: &apos;&lt;div&gt;I am async!&lt;/div&gt;&apos; &#125;) &#125;, 1000)&#125;) 工厂函数接收一个 resolve 回调，在收到从服务器下载的组件定义时调用。也可以调用 reject(reason) 指示加载失败。这里 setTimeout 只是为了演示。怎么获取组件完全由你决定。推荐配合使用 ：Webpack 的代码分割功能 123456Vue.component(&apos;async-webpack-example&apos;, function (resolve) &#123; // 这个特殊的 require 语法告诉 webpack // 自动将编译后的代码分割成不同的块， // 这些块将通过 Ajax 请求自动下载。 require([&apos;./my-async-component&apos;], resolve)&#125;) 你可以使用 Webpack 2 + ES2015 的语法返回一个 Promise resolve 函数 1234Vue.component( &apos;async-webpack-example&apos;, () =&gt; import(&apos;./my-async-component&apos;)) 当使用局部注册时，你也可以直接提供一个返回 Promise 的函数 123456new Vue(&#123; // ... components: &#123; &apos;my-component&apos;: () =&gt; import(&apos;./my-async-component&apos;) &#125;&#125;) 如果你是 Browserify 用户,可能就无法使用异步组件了,它的作者已经表明 Browserify 是不支持异步加载的。Browserify 社区发现 一些解决方法，可能有助于已存在的复杂应用。对于其他场景，我们推荐简单实用 Webpack 构建，一流的异步支持 高级异步组件 自 2.3.0 起，异步组件的工厂函数也可以返回一个如下的对象 123456789101112const AsyncComp = () =&gt; (&#123; // 需要加载的组件. 应当是一个 Promise component: import(&apos;./MyComp.vue&apos;), // loading 时应当渲染的组件 loading: LoadingComp, // 出错时渲染的组件 error: ErrorComp, // 渲染 loading 组件前的等待时间。默认：200ms. delay: 200, // 最长等待时间。超出此时间则渲染 error 组件。默认：Infinity timeout: 3000&#125;) 注意，当一个异步组件被作为 vue-router 的路由组件使用时，这些高级选项都是无效的，因为在路由切换前就会提前加载所需要的异步组件。另外，如果你要在路由组件中使用上述写法，需要使用 vue-router 2.4.0+。 组件命名约定 注册组件 (或者 props) 时，可以使用 kebab-case(短横线连接)，camelCase，或 PascalCase 在 HTML 模版中，使用组件推荐 kebab-case 形式 递归组件 组件在它的模板内可以递归地调用自己，不过，只有当它有 name 选项时才可以 当你利用Vue.component全局注册了一个组件, 全局的ID作为组件的 name 选项，被自动设置.局部注册需要手动设置 递归时，一定要设置终止条件 组件间的循环引用 假设你正在构建一个文件目录树，像在Finder或文件资源管理器中。你可能有一个 tree-folder组件12345678910111213// tree-folder组件&lt;p&gt; &lt;span&gt;&#123;&#123; folder.name &#125;&#125;&lt;/span&gt; &lt;tree-folder-contents :children=&quot;folder.children&quot;/&gt;&lt;/p&gt;// 然后 一个tree-folder-contents组件&lt;ul&gt; &lt;li v-for=&quot;child in children&quot;&gt; &lt;tree-folder v-if=&quot;child.children&quot; :folder=&quot;child&quot;/&gt; &lt;span v-else&gt;&#123;&#123; child.name &#125;&#125;&lt;/span&gt; &lt;/li&gt;&lt;/ul&gt;// 当你仔细看时，会发现在渲染树上这两个组件同时为对方的父节点和子节点–这点是矛盾的。当使用Vue.component将这两个组件注册为全局组件的时候，框架会自动为你解决这个矛盾 内联模版 如果子组件有 inline-template 特性，组件将把它的内容当作它的模板，而不是把它当作分发内容 123456&lt;my-component inline-template&gt; &lt;div&gt; &lt;p&gt;These are compiled as the component&apos;s own template.&lt;/p&gt; &lt;p&gt;Not parent&apos;s transclusion content.&lt;/p&gt; &lt;/div&gt;&lt;/my-component&gt; 但是 inline-template 让模板的作用域难以理解。最佳实践是使用 template 选项在组件内定义模板或者在 .vue 文件中使用 template 元素 X-Templates 另一种定义模版的方式是在 JavaScript 标签里使用 text/x-template 类型，并且指定一个 id 123456&lt;script type=&quot;text/x-template&quot; id=&quot;hello-world-template&quot;&gt; &lt;p&gt;Hello hello hello&lt;/p&gt;&lt;/script&gt;Vue.component(&apos;hello-world&apos;, &#123; template: &apos;#hello-world-template&apos;&#125;) 这在有很多模版或者小的应用中有用，否则应该避免使用，因为它将模版和组件的其他定义隔离了。 对低开销的静态组件使用 v-once 尽管在 Vue 中渲染 HTML 很快，不过当组件中包含大量静态内容时，可以考虑使用 v-once 将渲染结果缓存起来，就像这样12345678Vue.component(&apos;terms-of-service&apos;, &#123; template: &apos;\\ &lt;div v-once&gt;\\ &lt;h1&gt;Terms of Service&lt;/h1&gt;\\ ... a lot of static content ...\\ &lt;/div&gt;\\ &apos;&#125;) 深入响应式原理如何追踪变化 Vue通过Object.defineProperty将属性转化为setter/getter，在setter/getter中进行依赖追踪 把一个普通 JavaScript 对象传给 Vue 实例的 data 选项，Vue 将遍历此对象所有的属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter。 用户看不到 getter/setter，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化 每个组件实例都有相应的 watcher 实例对象，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的 setter 被调用时，会通知 watcher 重新计算，从而致使它关联的组件得以更新 变化检测问题 受现代 JavaScript 的限制（以及废弃 Object.observe），Vue 不能检测到对象属性的添加或删除。由于 Vue 会在初始化实例时对属性执行 getter/setter 转化过程，所以属性必须在 data 对象上存在才能让 Vue 转换它，这样才能让它是响应的 12345678var vm = new Vue(&#123; data:&#123; a:1 &#125;&#125;)// `vm.a` 是响应的vm.b = 2// `vm.b` 是非响应的 可以使用Vue.set(target,key,value)或者vm.$set(target,key,value)来添加响应式属性;注意target不能是 Vue 实例，或者 Vue 实例的根数据对象 有时你想向已有对象上添加一些属性，例如使用 Object.assign() 或 _.extend() 方法来添加属性。但是，添加到对象上的新属性不会触发更新。在这种情况下可以创建一个新的对象，让它包含原对象的属性和新的属性12// 代替 `Object.assign(this.someObject, &#123; a: 1, b: 2 &#125;)`this.someObject = Object.assign(&#123;&#125;, this.someObject, &#123; a: 1, b: 2 &#125;) 声明响应式属性 由于 Vue 不允许动态添加根级响应式属性，所以你必须在初始化实例前声明根级响应式属性，哪怕只是一个空值123456789var vm = new Vue(&#123; data: &#123; // 声明 message 为一个空值字符串 message: '' &#125;, template: '&lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;'&#125;)// 之后设置 `message` vm.message = 'Hello!' 异步更新队列 Vue中的DOM更新是异步的；实际的DOM更新是发生在观察到数据变化后下一个eventLoop的tick中 只要观察到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变。如果同一个 watcher 被多次触发，只会一次推入到队列中。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作上非常重要。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际（已去重的）工作。(数据变化-&gt;开启队列-&gt;去重复/缓冲)-&gt;(DOM更新)，在同一个括号中，代表发生在同一个tick中 Vue 在内部尝试对异步队列使用原生的 Promise.then 和 MutationObserver，如果执行环境不支持，会采用 setTimeout(fn, 0) 代替。例如，当你设置 vm.someData = ‘new value’ ，该组件不会立即重新渲染。当刷新队列时，组件会在事件循环队列清空时的下一个“tick”更新。 可以使用Vue.nextTick(callback),在 DOM 更新完成后立即调用callback 123456789101112&lt;div id=\"example\"&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt;var vm = new Vue(&#123; el: '#example', data: &#123; message: '123' &#125;&#125;)vm.message = 'new message' // 更改数据vm.$el.textContent === 'new message' // falseVue.nextTick(function () &#123; vm.$el.textContent === 'new message' // true&#125;) 组件内使用vm.$nextTick(callback),callback中的 this 将自动绑定到当前的 Vue 实例上 1234567891011121314151617Vue.component(&apos;example&apos;, &#123; template: &apos;&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;&apos;, data: function () &#123; return &#123; message: &apos;没有更新&apos; &#125; &#125;, methods: &#123; updateMessage: function () &#123; this.message = &apos;更新完成&apos; console.log(this.$el.textContent) // =&gt; &apos;没有更新&apos; this.$nextTick(function () &#123; console.log(this.$el.textContent) // =&gt; &apos;更新完成&apos; &#125;) &#125; &#125;&#125;) 过渡效果单元素/组件的过渡 Vue 提供了 transition 的封装组件，在下列情形中，可以给任何元素和组件添加 entering/leaving 过渡 条件渲染 （使用 v-if） 条件展示 （使用 v-show） 动态组件 组件根节点 12345678910111213141516171819202122&lt;div id=\"demo\"&gt; &lt;button v-on:click=\"show = !show\"&gt; Toggle &lt;/button&gt; &lt;transition name=\"fade\"&gt; &lt;p v-if=\"show\"&gt;hello&lt;/p&gt; &lt;/transition&gt;&lt;/div&gt;.fade-enter-active, .fade-leave-active &#123; transition: opacity 0.5s&#125;.fade-enter, .fade-leave-to &#123; opacity: 0&#125;new Vue(&#123; el: '#demo', data: &#123; show: true &#125;&#125;); 当插入或删除包含在&lt;transition&gt;组件中的元素时，Vue 将会做以下处理 自动嗅探目标元素是否应用了 CSS 过渡或动画，如果是，在恰当的时机添加/删除 CSS 类名。 如果过渡组件提供了 JavaScript 钩子函数，这些钩子函数将在恰当的时机被调用 如果没有找到 JavaScript 钩子并且也没有检测到 CSS 过渡/动画，DOM 操作（插入/删除）在下一帧中立即执行。(注意：此指浏览器逐帧动画机制，和Vue的 nextTick 概念不同) 过渡的css类名类似ng中动画会添加合适的class 会有 6 个(CSS)类名在 enter/leave 的过渡中切换 v-enter-&gt;定义开始状态，会在元素插入时生效，并在下一frame被删除 v-enter-active-&gt;定义过渡状态，插入时生效，过渡结束时删除；这个可以被用来定义过渡的过程时间，延迟和曲线函数。 v-enter-to-&gt;定义过渡结束状态，在元素插入后的下一frame被加入(v-enter正好删除),过渡结束时删除 同理，leave也一样，有v-leave、v-leave-active、v-leave-to 过渡中的类名前缀是可以更换的，通过&lt;transtion&gt;组件的name特性可以指定过渡类的前缀12// 对应的过渡样式类就是.testAnim-enter、.testAnim-enter-active、.testAnim-enter-to&lt;transtion name=&quot;testAnim&quot;&gt;xxx&lt;/transition&gt; css过渡最常用的1234567891011121314151617181920212223242526&lt;div id=&quot;example-1&quot;&gt; &lt;button @click=&quot;show = !show&quot;&gt; Toggle render &lt;/button&gt; &lt;transition name=&quot;slide-fade&quot;&gt; &lt;p v-if=&quot;show&quot;&gt;hello&lt;/p&gt; &lt;/transition&gt;&lt;/div&gt;new Vue(&#123; el: &apos;#example-1&apos;, data: &#123; show: true &#125;&#125;);/* 可以设置不同的进入和离开动画 *//* 设置持续时间和动画函数 */.slide-fade-enter-active &#123; transition: all .3s ease;&#125;.slide-fade-leave-active &#123; transition: all .8s cubic-bezier(1.0, 0.5, 0.8, 1.0);&#125;.slide-fade-enter, .slide-fade-leave-to &#123; transform: translateX(10px); opacity: 0;&#125; css动画animation CSS 动画用法同 CSS 过渡，区别是在动画中v-enter类名在节点插入 DOM 后不会立即删除，而是在 animationend 事件触发时(动画结束)删除。1234567891011121314151617181920212223242526272829&lt;div id=&quot;example-2&quot;&gt; &lt;button @click=&quot;show = !show&quot;&gt;Toggle show&lt;/button&gt; &lt;transition name=&quot;bounce&quot;&gt; &lt;p v-if=&quot;show&quot;&gt;Look at me!&lt;/p&gt; &lt;/transition&gt;&lt;/div&gt;new Vue(&#123; el: &apos;#example-2&apos;, data: &#123; show: true &#125;&#125;);.bounce-enter-active &#123; animation: bounce-in .5s;&#125;.bounce-leave-active &#123; animation: bounce-in .5s reverse;&#125;@keyframes bounce-in &#123; 0% &#123; transform: scale(0); &#125; 50% &#123; transform: scale(1.5); &#125; 100% &#123; transform: scale(1); &#125;&#125; 自定义过渡类名 可以通过以下特性来自定义过渡类名;主要用来配合第三方css动画库使用;他们的优先级高于普通的类名 enter-class enter-active-class enter-to-class (2.1.8+) leave-class leave-active-class leave-to-class (2.1.8+)123456789101112131415161718192021&lt;link href=&quot;https://unpkg.com/animate.css@3.5.1/animate.min.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;&lt;div id=&quot;example-3&quot;&gt; &lt;button @click=&quot;show = !show&quot;&gt; Toggle render &lt;/button&gt; &lt;!-- 进入离开时用特殊的class --&gt; &lt;transition name=&quot;custom-classes-transition&quot; enter-active-class=&quot;animated tada&quot; leave-active-class=&quot;animated bounceOutRight&quot; &gt; &lt;p v-if=&quot;show&quot;&gt;hello&lt;/p&gt; &lt;/transition&gt;&lt;/div&gt;new Vue(&#123; el: &apos;#example-3&apos;, data: &#123; show: true &#125;&#125;); 同时使用 Transitions 和 Animations Vue 为了知道过渡的完成，必须设置相应的事件监听器。它可以是 transitionend 或 animationend ，这取决于给元素应用的 CSS 规则。如果你使用其中任何一种，Vue 能自动识别类型并设置监听。 但是，在一些场景中，你需要给同一个元素同时设置两种过渡动效，比如 animation 很快的被触发并完成了，而 transition 效果还没结束。在这种情况中，你就需要使用 type 特性并设置 animation 或 transition 来明确声明你需要 Vue 监听的类型。 显性的过渡效果持续时间 在很多情况下，Vue 可以自动得出过渡效果的完成时机。默认情况下，Vue 会等待其在过渡效果的根元素的第一个 transitionend 或 animationend 事件。然而也可以不这样设定——比如，我们可以拥有一个精心编排的一序列过渡效果，其中一些嵌套的内部元素相比于过渡效果的根元素有延迟的或更长的过渡效果。在这种情况下你可以用 组件上的 duration 属性定制一个显性的过渡效果持续时间 (以毫秒计)：123&lt;transition :duration=&quot;1000&quot;&gt;...&lt;/transition&gt;// 你也可以定制进入和移出的持续时间：&lt;transition :duration=&quot;&#123; enter: 500, leave: 800 &#125;&quot;&gt;...&lt;/transition&gt; ###JavaScript 钩子(Js动画)可以在属性中声明 JavaScript 钩子，通过钩子在特定时间调用特定动画函数来实现js动画 beforeEnter-&gt;进入前 enter-&gt;进入中 after-enter-&gt;进入后 enter-cancelled-&gt;取消后 同理leave也有类似钩子 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;transition v-on:before-enter=&quot;beforeEnter&quot; v-on:enter=&quot;enter&quot; v-on:after-enter=&quot;afterEnter&quot; v-on:enter-cancelled=&quot;enterCancelled&quot; v-on:before-leave=&quot;beforeLeave&quot; v-on:leave=&quot;leave&quot; v-on:after-leave=&quot;afterLeave&quot; v-on:leave-cancelled=&quot;leaveCancelled&quot;&gt; &lt;!-- ... --&gt;&lt;/transition&gt;// ...methods: &#123; // -------- // 进入中 // -------- beforeEnter: function (el) &#123; // ... &#125;, // 此回调函数是可选项的设置 // 与 CSS 结合时使用 enter: function (el, done) &#123; // ... done() &#125;, afterEnter: function (el) &#123; // ... &#125;, enterCancelled: function (el) &#123; // ... &#125;, // -------- // 离开时 // -------- beforeLeave: function (el) &#123; // ... &#125;, // 此回调函数是可选项的设置 // 与 CSS 结合时使用 leave: function (el, done) &#123; // ... done() &#125;, afterLeave: function (el) &#123; // ... &#125;, // leaveCancelled 只用于 v-show 中 leaveCancelled: function (el) &#123; // ... &#125;&#125; 这些钩子函数可以结合 CSS transitions/animations 使用，也可以单独使用。 当只用 JavaScript 过渡的时候， 在 enter 和 leave 中，回调函数 done 是必须的 。 否则，它们会被同步调用，过渡会立即完成。 推荐对于仅使用 JavaScript 过渡的元素添加 v-bind:css=”false”，Vue 会跳过 CSS 的检测。这也可以避免过渡过程中 CSS 的影响。 初始渲染的过渡定义第一次渲染时，如何过渡 通过添加appear特性，可以开启初始渲染过渡动画 和enter、leave过渡一样可以自己定义css类名 12345678&lt;transition appear appear-class=&quot;custom-appear-class&quot; appear-to-class=&quot;custom-appear-to-class&quot; appear-active-class=&quot;custom-appear-active-class&quot;&gt; &lt;!-- ... --&gt;&lt;/transition&gt; 也有相应的js钩子 123456789&lt;transition appear v-on:before-appear=&quot;customBeforeAppearHook&quot; v-on:appear=&quot;customAppearHook&quot; v-on:after-appear=&quot;customAfterAppearHook&quot; v-on:appear-cancelled=&quot;customAppearCancelledHook&quot;&gt; &lt;!-- ... --&gt;&lt;/transition&gt; 多个元素的过渡 对于原生标签可以使用 v-if/v-else 。最常见的多标签过渡是一个列表和描述这个列表为空消息的元素 123456&lt;transition&gt; &lt;table v-if=&quot;items.length &gt; 0&quot;&gt; &lt;!-- ... --&gt; &lt;/table&gt; &lt;p v-else&gt;Sorry, no items found.&lt;/p&gt;&lt;/transition&gt; 当有相同标签名的元素切换时，需要通过 key 特性设置唯一的值来标记以让 Vue 区分它们，否则 Vue 为了效率只会替换相同标签内部的内容。即使在技术上没有必要，给在 组件中的多个元素设置 key 是一个更好的实践。 12345678910111213141516171819202122232425262728293031323334353637383940 &lt;style type=&quot;text/css&quot;&gt; .fade-enter, .fade-leave &#123; opacity: 0; &#125; .fade-enter-active, .fade-leave-active &#123; transition: all .3s ease-in-out; &#125; &lt;/style&gt;&lt;div id=&quot;app&quot;&gt; &lt;transition name=&quot;fade&quot;&gt; &lt;!-- 没有加key,根据vue的就地复用原则，他们将只替换内容，因此不会产生过渡动画 --&gt; &lt;!-- &lt;button v-if=&quot;isEditing&quot;&gt; Save &lt;/button&gt; &lt;button v-else&gt; Edit &lt;/button&gt; --&gt; &lt;!-- 添加key --&gt; &lt;!-- &lt;button v-if=&quot;isEditing&quot; key=&quot;save&quot;&gt; Save &lt;/button&gt; &lt;button v-else key=&quot;edit&quot;&gt; Edit &lt;/button&gt; --&gt; &lt;!-- 在一些场景中，也可以给通过给同一个元素的 key 特性设置不同的状态来代替 v-if 和 v-else，上面的例子可以重写为： --&gt; &lt;button v-bind:key=&quot;isEditing&quot;&gt; &#123;&#123; isEditing ? &apos;Save&apos; : &apos;Edit&apos; &#125;&#125; &lt;/button&gt; &lt;/transition&gt; &lt;button @click=&quot;isEditing=!isEditing&quot;&gt;点击&lt;/button&gt;&lt;/div&gt;var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123; isEditing: true &#125; &#125;); 使用多个 v-if 的多个元素的过渡可以重写为绑定了动态属性的单个元素过渡 123456789101112131415161718192021222324252627&lt;transition&gt; &lt;button v-if=&quot;docState === &apos;saved&apos;&quot; key=&quot;saved&quot;&gt; Edit &lt;/button&gt; &lt;button v-if=&quot;docState === &apos;edited&apos;&quot; key=&quot;edited&quot;&gt; Save &lt;/button&gt; &lt;button v-if=&quot;docState === &apos;editing&apos;&quot; key=&quot;editing&quot;&gt; Cancel &lt;/button&gt;&lt;/transition&gt;&lt;!-- 重写 --&gt;&lt;transition&gt; &lt;button v-bind:key=&quot;docState&quot;&gt; &#123;&#123; buttonMessage &#125;&#125; &lt;/button&gt;&lt;/transition&gt;// ...computed: &#123; buttonMessage: function () &#123; switch (this.docState) &#123; case &apos;saved&apos;: return &apos;Edit&apos; case &apos;edited&apos;: return &apos;Save&apos; case &apos;editing&apos;: return &apos;Cancel&apos; &#125; &#125;&#125; 多元素的过渡模式多元素过渡时(一个enter、一个leave)默认是进入和离开同时发生；这样可能会发生过渡时画面抖动的问题；通过多元素的过渡模式可以解决 通过在&lt;transtion&gt;上添加mode特性便可指定过渡模式 in-out: 新元素先进行过渡进入，完成之后当前元素过渡离开。-&gt;先enter后leave out-in: 当前元素先进行过渡离开，完成之后新元素过渡进入。-&gt;先leave后enter1234567891011121314151617181920212223242526272829303132&lt;style type=&quot;text/css&quot;&gt; .fade-enter, .fade-leave-to &#123; opacity: 0; &#125; .fade-enter &#123; transform: translateX(10px); &#125; .fade-leave-to &#123; transform: translateX(-10px); &#125; .fade-enter-active, .fade-leave-active &#123; transition: all .3s ease-in-out; &#125;&lt;/style&gt;&lt;div id=&quot;app&quot;&gt; &lt;transition name=&quot;fade&quot; mode=&quot;in-out&quot;&gt; &lt;button :key=&quot;isEditing&quot; @click=&quot;isEditing=!isEditing&quot; :style=&quot;&#123;position:&apos;absolute&apos;&#125;&quot;&gt; &#123;&#123; isEditing &#125;&#125; &lt;/button&gt; &lt;/transition&gt;&lt;/div&gt; var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123; isEditing: true &#125;&#125;); 多个组件的过渡 多个组件的过渡简单很多 - 我们不需要使用 key 特性。相反，我们只需要使用动态组件1234567891011121314151617181920212223&lt;transition name=&quot;component-fade&quot; mode=&quot;out-in&quot;&gt; &lt;component v-bind:is=&quot;view&quot;&gt;&lt;/component&gt;&lt;/transition&gt;new Vue(&#123; el: &apos;#transition-components-demo&apos;, data: &#123; view: &apos;v-a&apos; &#125;, components: &#123; &apos;v-a&apos;: &#123; template: &apos;&lt;div&gt;Component A&lt;/div&gt;&apos; &#125;, &apos;v-b&apos;: &#123; template: &apos;&lt;div&gt;Component B&lt;/div&gt;&apos; &#125; &#125;&#125;);.component-fade-enter-active, .component-fade-leave-active &#123; transition: opacity .3s ease;&#125;.component-fade-enter, .component-fade-leave-to&#123; opacity: 0;&#125; 列表过渡 那么怎么同时渲染整个列表，比如使用 v-for ？在这种场景中，使用&lt;transition-group&gt;组件。 不同于&lt;transition&gt;，它会以一个真实元素呈现：默认为一个 。你也可以通过tag特性更换为其他元素。 内部元素 总是需要 提供唯一的 key 属性值1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;style type=&quot;text/css&quot;&gt; .list-item &#123; display: inline-block; margin-right: 10px; &#125; .list-enter-active, .list-leave-active &#123; transition: all 1s; &#125; .list-enter, .list-leave-to &#123; opacity: 0; transform: translateY(30px); &#125;&lt;/style&gt;&lt;div id=&quot;list-demo&quot; class=&quot;demo&quot;&gt; &lt;button v-on:click=&quot;add&quot;&gt;Add&lt;/button&gt; &lt;button v-on:click=&quot;remove&quot;&gt;Remove&lt;/button&gt; &lt;!-- 因为指定了tag特性，所以transition-group将被p取代 --&gt; &lt;transition-group name=&quot;list&quot; tag=&quot;p&quot;&gt; &lt;!-- 绑定唯一的key --&gt; &lt;span v-for=&quot;item in items&quot; v-bind:key=&quot;item&quot; class=&quot;list-item&quot;&gt;&#123;&#123; item &#125;&#125;&lt;/span&gt; &lt;/transition-group&gt;&lt;/div&gt;new Vue(&#123; el: &apos;#list-demo&apos;, data: &#123; items: [1, 2, 3, 4, 5, 6, 7, 8, 9], nextNum: 10 &#125;, methods: &#123; randomIndex: function() &#123; return Math.floor(Math.random() * this.items.length) &#125;, add: function() &#123; this.items.splice(this.randomIndex(), 0, this.nextNum++) &#125;, remove: function() &#123; this.items.splice(this.randomIndex(), 1) &#125;, &#125;&#125;); 列表的位移过渡 上面的例子，当添加和移除元素的时候，周围的元素会瞬间移动到他们的新布局的位置，而不是平滑的过渡 &lt;transition-group&gt;组件还有一个特殊之处。不仅可以进入和离开动画，还可以改变定位。要使用这个新功能只需了解新增的v-move特性，它会在元素的改变定位的过程中应用。像之前的类名一样，可以通过name属性来自定义前缀，也可以通过move-class属性手动设置 12345678910111213141516171819202122232425&lt;style type=&quot;text/css&quot;&gt; /*设置-move*/ .flip-list-move &#123; transition: transform 1s; &#125;&lt;/style&gt;&lt;div id=&quot;flip-list-demo&quot; class=&quot;demo&quot;&gt; &lt;button v-on:click=&quot;shuffle&quot;&gt;洗牌&lt;/button&gt; &lt;transition-group name=&quot;flip-list&quot; tag=&quot;ul&quot;&gt; &lt;li v-for=&quot;item in items&quot; v-bind:key=&quot;item&quot;&gt; &#123;&#123; item &#125;&#125; &lt;/li&gt; &lt;/transition-group&gt;&lt;/div&gt;new Vue(&#123; el: &apos;#flip-list-demo&apos;, data: &#123; items: [1, 2, 3, 4, 5, 6, 7, 8, 9] &#125;, methods: &#123; shuffle: function() &#123; this.items = _.shuffle(this.items) // 打乱 &#125; &#125;&#125;) 内部的实现，Vue 使用了一个叫 FLIP 简单的动画队列使用 transforms 将元素从之前的位置平滑过渡新的位置。 需要注意的是使用FLIP过渡的元素不能设置为 display: inline 。作为替代方案，可以设置为 display: inline-block 或者放置于 flex 中 列表的渐进过渡 通过 data 属性与 JavaScript 通信 ，就可以实现列表的渐进过渡1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js&quot;&gt;&lt;/script&gt;&lt;div id=&quot;staggered-list-demo&quot;&gt; &lt;input v-model=&quot;query&quot;&gt; &lt;!-- 因为是全部用js完成动画，所以v-bind:css=&quot;false&quot;，避开css动画检查，提高效率；并在各个动画钩子处绑定动画函数 --&gt; &lt;transition-group name=&quot;staggered-fade&quot; tag=&quot;ul&quot; v-bind:css=&quot;false&quot; v-on:before-enter=&quot;beforeEnter&quot; v-on:enter=&quot;enter&quot; v-on:leave=&quot;leave&quot;&gt; &lt;!-- 绑定唯一的key并绑定索引 --&gt; &lt;li v-for=&quot;(item, index) in computedList&quot; v-bind:key=&quot;item.msg&quot; v-bind:data-index=&quot;index&quot;&gt;&#123;&#123; item.msg &#125;&#125;&lt;/li&gt; &lt;/transition-group&gt;&lt;/div&gt;new Vue(&#123; el: &apos;#staggered-list-demo&apos;, data: &#123; query: &apos;&apos;, list: [ &#123; msg: &apos;Bruce Lee&apos; &#125;, &#123; msg: &apos;Jackie Chan&apos; &#125;, &#123; msg: &apos;Chuck Norris&apos; &#125;, &#123; msg: &apos;Jet Li&apos; &#125;, &#123; msg: &apos;Kung Fury&apos; &#125; ] &#125;, computed: &#123; computedList: function() &#123; var vm = this return this.list.filter(function(item) &#123; return item.msg.toLowerCase().indexOf(vm.query.toLowerCase()) !== -1 &#125;) &#125; &#125;, methods: &#123; beforeEnter: function(el) &#123; el.style.opacity = 0 el.style.height = 0 &#125;, enter: function(el, done) &#123; // 根据索引创建延迟 var delay = el.dataset.index * 150; setTimeout(function() &#123; Velocity( el, &#123; opacity: 1, height: &apos;1.6em&apos; &#125;, &#123; complete: done &#125; ) &#125;, delay) &#125;, leave: function(el, done) &#123; var delay = el.dataset.index * 150 setTimeout(function() &#123; Velocity( el, &#123; opacity: 0, height: 0 &#125;, &#123; complete: done &#125; ) &#125;, delay) &#125; &#125; &#125;) 可复用的过渡 过渡可以通过 Vue 的组件系统实现复用 要创建一个可复用过渡组件，你需要做的就是将 或者 作为根组件，然后将任何子组件放置在其中就可以了。1234567891011121314151617181920Vue.component(&apos;my-special-transition&apos;, &#123; template: &apos;\\ &lt;transition\\ name=&quot;very-special-transition&quot;\\ mode=&quot;out-in&quot;\\ v-on:before-enter=&quot;beforeEnter&quot;\\ v-on:after-enter=&quot;afterEnter&quot;\\ &gt;\\ &lt;slot&gt;&lt;/slot&gt;\\ &lt;/transition&gt;\\ &apos;, methods: &#123; beforeEnter: function (el) &#123; // ... &#125;, afterEnter: function (el) &#123; // ... &#125; &#125;&#125;) 动态过渡 Vue 中即使是过渡也是数据驱动的，过渡中的各种状态能通过数据动态改变。 当你想用 Vue 的过渡系统来定义的 CSS 过渡/动画 在不同过渡间切换会非常有用 所有的过渡特性都是动态绑定。 它不仅是简单的特性，通过事件的钩子函数方法，可以在获取到相应上下文数据。 这意味着，可以根据组件的状态通过 JavaScript 过渡设置不同的过渡效果。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js&quot;&gt;&lt;/script&gt;&lt;div id=&quot;dynamic-fade-demo&quot; class=&quot;demo&quot;&gt; Fade In: &lt;input type=&quot;range&quot; v-model=&quot;fadeInDuration&quot; min=&quot;0&quot; v-bind:max=&quot;maxFadeDuration&quot;&gt; Fade Out: &lt;input type=&quot;range&quot; v-model=&quot;fadeOutDuration&quot; min=&quot;0&quot; v-bind:max=&quot;maxFadeDuration&quot;&gt; &lt;transition v-bind:css=&quot;false&quot; v-on:before-enter=&quot;beforeEnter&quot; v-on:enter=&quot;enter&quot; v-on:leave=&quot;leave&quot; &gt; &lt;p v-if=&quot;show&quot;&gt;hello&lt;/p&gt; &lt;/transition&gt; &lt;button v-if=&quot;stop&quot; v-on:click=&quot;stop = false; show = false&quot; &gt;Start animating&lt;/button&gt; &lt;button v-else v-on:click=&quot;stop = true&quot; &gt;Stop it!&lt;/button&gt;&lt;/div&gt;new Vue(&#123; el: &apos;#dynamic-fade-demo&apos;, data: &#123; show: true, fadeInDuration: 1000, fadeOutDuration: 1000, maxFadeDuration: 1500, stop: true &#125;, mounted: function () &#123; this.show = false &#125;, methods: &#123; beforeEnter: function (el) &#123; el.style.opacity = 0 &#125;, enter: function (el, done) &#123; var vm = this Velocity(el, &#123; opacity: 1 &#125;, &#123; duration: this.fadeInDuration,// 持续时间为动态绑定 complete: function () &#123; done() if (!vm.stop) vm.show = false &#125; &#125; ) &#125;, leave: function (el, done) &#123; var vm = this Velocity(el, &#123; opacity: 0 &#125;, &#123; duration: this.fadeOutDuration,// 持续时间为动态绑定 complete: function () &#123; done() vm.show = true &#125; &#125; ) &#125; &#125;&#125;) 过渡状态 Vue 的过渡系统提供了非常多简单的方法设置进入、离开和列表的动效。有些变化中间的过渡状态无法通过vue独自完成，例如 数字和运算(数字从1变为10中间的过渡) 颜色的显示(从一种颜色变化到另一种的过渡) SVG 节点的位置 元素的大小和其他的属性 所有的原始数字都被事先存储起来，可以直接转换到数字。做到这一步，我们就可以结合 Vue 的响应式和组件系统，使用第三方库来实现切换元素的过渡状态，补间动画 状态动画 与 watcher 通过 watcher 我们能监听到任何数值属性的数值更新，然后调用一些辅助用的动画库(例如tween.js、color.js)完成相应的特殊过渡123456789101112131415161718192021222324252627282930&lt;script src=&quot;https://unpkg.com/tween.js@16.3.4&quot;&gt;&lt;/script&gt;&lt;div id=&quot;animated-number-demo&quot;&gt; &lt;input v-model.number=&quot;number&quot; type=&quot;number&quot; step=&quot;20&quot;&gt; &lt;p&gt;&#123;&#123; animatedNumber &#125;&#125;&lt;/p&gt;&lt;/div&gt;new Vue(&#123; el: &apos;#animated-number-demo&apos;, data: &#123; number: 0, animatedNumber: 0 &#125;, watch: &#123; number: function(newValue, oldValue) &#123; var vm = this function animate () &#123; if (TWEEN.update()) &#123; requestAnimationFrame(animate) &#125; &#125; new TWEEN.Tween(&#123; tweeningNumber: oldValue &#125;) .easing(TWEEN.Easing.Quadratic.Out) .to(&#123; tweeningNumber: newValue &#125;, 500) .onUpdate(function () &#123; vm.animatedNumber = this.tweeningNumber.toFixed(0) &#125;) .start() animate() &#125; &#125;&#125;) 动态状态转换 类似动态过渡，每个状态都是可变的(响应式的) 通过组件组织过渡 管理太多的状态转换会很快的增加 Vue 实例或者组件的复杂性，幸好很多的动画可以提取到专用的子组件。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;script src=&quot;https://unpkg.com/tween.js@16.3.4&quot;&gt;&lt;/script&gt;&lt;div id=&quot;example-8&quot;&gt; &lt;input v-model.number=&quot;firstNumber&quot; type=&quot;number&quot; step=&quot;20&quot;&gt; + &lt;input v-model.number=&quot;secondNumber&quot; type=&quot;number&quot; step=&quot;20&quot;&gt; = &#123;&#123; result &#125;&#125; &lt;p&gt; &lt;!-- 传入输入框的值 --&gt; &lt;animated-integer v-bind:value=&quot;firstNumber&quot;&gt;&lt;/animated-integer&gt; + &lt;animated-integer v-bind:value=&quot;secondNumber&quot;&gt;&lt;/animated-integer&gt; = &lt;animated-integer v-bind:value=&quot;result&quot;&gt;&lt;/animated-integer&gt; &lt;/p&gt;&lt;/div&gt;// 这种复杂的补间动画逻辑可以被复用// 任何整数都可以执行动画// 组件化使我们的界面十分清晰// 可以支持更多更复杂的动态过渡Vue.component(&apos;animated-integer&apos;, &#123; template: &apos;&lt;span&gt;&#123;&#123; tweeningValue &#125;&#125;&lt;/span&gt;&apos;, props: &#123; value: &#123; // 接收的值 type: Number, required: true &#125; &#125;, data: function() &#123; return &#123; tweeningValue: 0 &#125; &#125;, watch: &#123; // 传过来的值有变化，触发tween value: function(newValue, oldValue) &#123; this.tween(oldValue, newValue) &#125; &#125;, mounted: function() &#123; // 刚载入，触发默认tween this.tween(0, this.value) &#125;, methods: &#123; tween: function(startValue, endValue) &#123; var vm = this; // raf function animate() &#123; if (TWEEN.update()) &#123; requestAnimationFrame(animate) &#125; &#125; // 数值变化的补间动画 new TWEEN.Tween(&#123; tweeningValue: startValue &#125;) .to(&#123; tweeningValue: endValue &#125;, 500) .onUpdate(function() &#123; vm.tweeningValue = this.tweeningValue.toFixed(0) &#125;) .start(); // 调用一次 animate(); &#125; &#125;&#125;);new Vue(&#123; el: &apos;#example-8&apos;, data: &#123; firstNumber: 20, secondNumber: 40 &#125;, computed: &#123; result: function() &#123; return this.firstNumber + this.secondNumber &#125; &#125;&#125;) Render函数-&gt;后期补自定义指令 vue2中代码复用的主要形式和抽象是组件,有的情况下,你仍然需要对纯 DOM 元素进行底层操作,这时候就会用到自定义指令。 简介 注册 全局注册 12345678// 注册一个全局自定义指令 v-focusVue.directive(&apos;focus&apos;, &#123; // 当绑定元素插入到 DOM 中。 inserted: function (el) &#123; // 聚焦元素 el.focus() &#125;&#125;) 局部注册 12345directives: &#123; focus: &#123; // 指令的定义--- &#125;&#125; 使用-&gt;&lt;input v-focus&gt; 钩子函数 自定义指令提供下面钩子 bind-&gt;只调用一次，只在第一次绑定到元素时调用，主要用做初始化工作 inserted-&gt;被绑定元素插入父节点时调用（父节点存在即可调用，不必存在于 document 中） componentUpdated-&gt;所在组件的 VNode 及其孩子的 VNode 全部更新时调用。 update-&gt;所在组件的 VNode 更新时调用,但是可能发生在其孩子的 VNode 更新之前。指令的值可能发生了改变也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 unbind-&gt; 只调用一次， 指令与元素解绑时调用 钩子函数参数 钩子函数的回调在被调用时，会自动传入一些参数el,bingding,vnode,oldVnode -el: 指令所绑定的元素，可以用来直接操作 DOM 。 binding: 一个对象，包含以下属性 name: 指令名，不包括 v- 前缀。 value: 指令的绑定值， 例如： v-my-directive=”1 + 1”, value 的值是 2。 oldValue: 指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。 expression: 绑定值的字符串形式。 例如 v-my-directive=”1 + 1” ， expression 的值是 “1 + 1”。 arg: 传给指令的参数。例如 v-my-directive:foo， arg 的值是 “foo”。 modifiers: 一个包含修饰符的对象。 例如： v-my-directive.foo.bar, 修饰符对象 modifiers 的值是 { foo: true, bar: true }。 vnode: Vue 编译生成的虚拟节点 oldVnode: 上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。 除了 el 之外，其它参数都应该是只读的，尽量不要修改他们。如果需要在钩子之间共享数据，建议通过元素的 dataset 来进行。12345678910111213141516171819&lt;div id=&quot;hook-arguments-example&quot; v-demo:foo.a.b=&quot;message&quot;&gt;&lt;/div&gt;Vue.directive(&apos;demo&apos;, &#123; bind: function (el, binding, vnode) &#123; var s = JSON.stringify el.innerHTML = &apos;name: &apos; + s(binding.name) + &apos;&lt;br&gt;&apos; + &apos;value: &apos; + s(binding.value) + &apos;&lt;br&gt;&apos; + &apos;expression: &apos; + s(binding.expression) + &apos;&lt;br&gt;&apos; + &apos;argument: &apos; + s(binding.arg) + &apos;&lt;br&gt;&apos; + &apos;modifiers: &apos; + s(binding.modifiers) + &apos;&lt;br&gt;&apos; + &apos;vnode keys: &apos; + Object.keys(vnode).join(&apos;, &apos;) &#125;&#125;);new Vue(&#123; el: &apos;#hook-arguments-example&apos;, data: &#123; message: &apos;hello!&apos; &#125;&#125;); 函数简写 大多数情况下，我们可能想在 bind 和 update 钩子上做重复动作，并且不想关心其它的钩子函数。 第二个参数不传入选项对象，而是一个函数，则表示此函数只会在bind和update时被调用123Vue.directive(&apos;color-swatch&apos;, function (el, binding) &#123; el.style.backgroundColor = binding.value&#125;) 对象字面量 如果指令需要多个值，可以传入一个 JavaScript 对象字面量12345&lt;div v-demo=&quot;&#123; color: &apos;white&apos;, text: &apos;hello!&apos; &#125;&quot;&gt;&lt;/div&gt;Vue.directive(&apos;demo&apos;, function (el, binding) &#123; console.log(binding.value.color) // =&gt; &quot;white&quot; console.log(binding.value.text) // =&gt; &quot;hello!&quot;&#125;) 混合-&gt;后期补插件-&gt;后期补单文件组件-&gt;后期补生产环境部署提示-&gt;后期补路由官方路由 Vue-router 简单路由 HTML5 History API12345678910111213141516171819const NotFound = &#123; template: &apos;&lt;p&gt;Page not found&lt;/p&gt;&apos; &#125;const Home = &#123; template: &apos;&lt;p&gt;home page&lt;/p&gt;&apos; &#125;const About = &#123; template: &apos;&lt;p&gt;about page&lt;/p&gt;&apos; &#125;const routes = &#123; &apos;/&apos;: Home, &apos;/about&apos;: About&#125;new Vue(&#123; el: &apos;#app&apos;, data: &#123; currentRoute: window.location.pathname &#125;, computed: &#123; ViewComponent () &#123; return routes[this.currentRoute] || NotFound &#125; &#125;, render (h) &#123; return h(this.ViewComponent) &#125;&#125;) 状态管理类 Flux 状态管理的官方实现 由于多个状态分散的跨越在许多组件和交互间各个角落，大型应用复杂度也经常逐渐增长。为了解决这个问题，Vue 提供 vuex： 我们有受到 Elm 启发的状态管理库 简单状态管理起步使用 Vue 应用中原始数据对象的实际来源 - 当访问数据对象时，一个 Vue 实例只是简单的代理访问。所以，如果你有一处需要被多个实例间共享的状态，可以简单地通过维护一份数据来实现共享 1234567const sourceOfTruth = &#123;&#125;const vmA = new Vue(&#123; data: sourceOfTruth&#125;)const vmB = new Vue(&#123; data: sourceOfTruth&#125;) 现在当 sourceOfTruth 发生变化，vmA 和 vmB 都将自动的更新引用它们的视图。子组件们的每个实例也会通过 this.$root.$data 去访问。现在我们有了唯一的实际来源，但是，调试将会变为噩梦。任何时间，我们应用中的任何部分，在任何数据改变后，都不会留下变更过的记录 为了解决这个问题，我们采用一个简单的 store 模式： 1234567891011121314var store = &#123; debug: true, state: &#123; message: &apos;Hello!&apos; &#125;, setMessageAction (newValue) &#123; if (this.debug) console.log(&apos;setMessageAction triggered with&apos;, newValue) this.state.message = newValue &#125;, clearMessageAction () &#123; if (this.debug) console.log(&apos;clearMessageAction triggered&apos;) this.state.message = &apos;&apos; &#125;&#125; 所有 store 中 state 的改变，都放置在 store 自身的 action 中去管理,这种集中式状态管理能够被更容易地理解哪种类型的 mutation 将会发生，以及它们是如何被触发。当错误出现时，我们现在也会有一个 log 记录 bug 之前发生了什么 此外，每个实例/组件仍然可以拥有和管理自己的私有状态：123456789101112var vmA = new Vue(&#123; data: &#123; privateState: &#123;&#125;, sharedState: store.state &#125;&#125;)var vmB = new Vue(&#123; data: &#123; privateState: &#123;&#125;, sharedState: store.state &#125;&#125;) 重要的是，注意你不应该在 action 中 替换原始的状态对象 - 组件和 store 需要引用同一个共享对象，mutation 才能够被观察 接着我们继续延伸约定，组件不允许直接修改属于 store 实例的 state，而应执行 action 来分发 (dispatch) 事件通知 store 去改变，我们最终达成了 Flux 架构 这样约定的好处是，我们能够记录所有 store 中发生的 state 改变，同时实现能做到记录变更 (mutation) 、保存状态快照、历史回滚/时光旅行的先进的调试工具 单元测试-&gt;后期补服务器端渲染-&gt;后期补Typescript支持-&gt;后期补","tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"how-does-timer-work","date":"2017-07-31T02:55:32.000Z","path":"2017/07/31/how-does-timer-work/","text":"最近看了些关于js中定时器原理解析的文章，所以特在此做一个记录本文带有个人理解，若有错误，望指正。 JS中的定时器(setTimeout)是如何工作的?定时器js中的setTimeout主要用来完成一些超时调用的任务，可以指定函数在未来的某个时间执行。123setTimeout(function()&#123; console.log('hi');&#125;,500); 理论情况下，’hi’会在500ms后被打印出来。 考虑下面这种情况12345console.log(1);setTimeout(function()&#123; console.log(2);&#125;,1000);console.log(3); 最后输出的顺序是1,3,2，你可能在想因为2被延迟了1000ms，所以最后输出的。 再看下面的12345console.log(1);setTimeout(function()&#123; console.log(2);&#125;,0);console.log(3); 这次我们将延迟的时间从1000调成了0，这次应该输出1,2,3了吧，但实际上最后的输出结果还是1,3,2这是为什么呢？要解释清楚这个就必须了解setTimeout的工作原理了。 工作原理js是单线程的，它同一时间它只能干一件事情。那你可能会问为什么不多弄几个线程，这样多管齐下，不是执行效率更高了吗？当时js的用途(交互、操作dom)决定了它只能是单线程的，如果多线程，就会存在多线程同步的问题。我在一个线程中删除了节点a，另一个线程在节点a上添加了一些内容，这样就会导致冲突，将一个简单的问题负责化了，所以最终js是单线程的。 解释下下面代码的执行过程12345console.log(1);setTimeout(function()&#123; console.log(2);&#125;,1000);console.log(3); 首先js中存在一个callstack(调用栈)的东西，它会将函数/方法压入(push)到栈中，并依次出栈(pop)执行。 默认上面代码外围有个main函数 main入栈 console.log(1)入栈 console.log(1)出栈并调用打印出1 setTimeout入栈 发现setTimeout是个延迟执行，出栈时，将需要延迟执行的回调函数交给浏览器的timer模块，timer模块负责观察延迟执行的回调函数是否到达触发条件，此时call stack会继续将后面的方法压入栈中 console.log(3)入栈 console.log(3)出栈并调用打印出3 main出栈 timer模块观察到延迟执行的函数到达触发条件后，将延迟执行的回调函数推入任务队列(task queue)中 当调用栈处于空闲状态时，它会将任务队列中的第一个任务压入callstack中，并调用，并一直重复这个过程直到任务队列为空。这个过程称为event loop 上面的setTimeout的延迟是1000，为0的时候其实也是一样的，只不过在timer模块中，它会立即到达触发条件，并被推入任务队列中，等待call stack空闲时，再压入到call stack中并调用。 上面是关于setTimeout延迟函数的调用过程，其实js中的事件、ajax的执行流程也一样(其实你会发现他们有个共同点，都有回调函数)。只不过setTimeout有一个具体的延迟时间，延迟时间到达了触发。事件是在用户进行某种操作后(点击)，立即将回调函数推入任务队列中，call stack空闲时取第一个并执行。ajax则是在返回数据后(满足触发条件)，将回调推入任务队列中，call stack空闲时取第一个并执行。 其实js的任务(代码)可以分为同步任务和异步任务(事件、ajax、setTimeout)，异步任务的回调一定是在所有同步任务都执行完了以后再被调用;12345console.log(1);setTimeout(function()&#123; console.log(2);&#125;,0);console.log(3); 如上面，即使setTimeout的延迟时间为0，它的回调函数也没有直接被调用，而是等到console.log(3)执行完，call stack为空时，再被调用执行的。所以setTimeour(fn,0)常用来在所有同步任务执行完后，尽可能早的执行； 再看下面的代码12345var req = new XMLHttpRequest();req.open('GET', url); req.onload = function ()&#123;&#125;; req.onerror = function ()&#123;&#125;; req.send(); 和12345var req = new XMLHttpRequest();req.open('GET', url);req.send();req.onload = function ()&#123;&#125;; req.onerror = function ()&#123;&#125;; 二者效果一样。 onload和onerror的位置无关紧要，不用担心先send了,load和error不会触发。因为load和error事件都属于异步任务(事件)，他们的回调函数一定是在所有同步任务完成后再被调用的。 总结： 通过上面可以发现，js中的异步任务(事件、ajax、setTimeout)，是需要call stack、浏览器中的对应模块(DOM Binding、network、timer)、task queue三者配合来完成异步任务； call stack负责压入待执行的方法/函数，遇到异步任务时，会将异步任务交给对应模块处理； 浏览器对应模块负责判断异步任务是否满足触发条件，若满足触发条件，则将异步任务的回调推入task queue中 task queue负责保存所有已经满足触发条件可以压入call stack中执行的异步任务回调。 当call stack空闲时，会将task queue中的第一个回调压入call stack中并执行，并一直循环这一过程直到task queue为空；-&gt;event loop 所有异步任务的回调一定是在所有同步任务都执行完了后再被调用 setTimeout(fn,0)无论写在哪，它的作用都是在所有同步任务执行完后，尽可能早的执行fn 参考链接 http://www.alloyteam.com/2015/10/turning-to-javascript-series-from-settimeout-said-the-event-loop-model/http://www.ruanyifeng.com/blog/2014/10/event-loop.htmlhttps://vimeo.com/96425312http://latentflip.com/loupe/","tags":[{"name":"timer","slug":"timer","permalink":"http://yoursite.com/tags/timer/"}]},{"title":"AngularJs-todoMVC","date":"2017-07-13T03:23:52.000Z","path":"2017/07/13/AngularJs-todoMVC/","text":"AngularJs-todoMVC 源码解释 github上的todoMVC仓库是一个帮助你选择前端MVC框架的项目项目中包含了绝大多数前端MVC框架实现Todo application的范例，让你能比较不同的框架实现同一个应用的差异。进而让你做出最佳选择。Todo application的具体效果，可以看这个http://todomvc.com/examples/angularjs/#/对于新手来说，是个很不错的学习范例。本文选取的是其中的angularJs范例，对其做了简单分析。分析源码已经上传至github，https://github.com/BryanAdamss/SourceSave/tree/master/TodoMVC/angularjs源码下载后，请在服务器中打开 目录结构主要根据功能不同，放在了不同文件夹中 angularjs/ js/ controllers/ todoCtrl.js-&gt;最主要的一个控制器 directives/ todoEscape.js-&gt;实现按下esc键，恢复到原先编辑状态的指令 todoFocus.js-&gt;再编辑input显示，聚焦的指令 services/ todoStorage.js-&gt;实现本地localStorge app.js-&gt;入口文件，包含了路由配置 node_modules/ angular/ angular-resource/ angular-route/ todomvc-app-css/-&gt;页面主要样式文件 todomvc-common/-&gt;一些通用的css样式和js helper index.html index.html相关说明全部写在注释里了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta name=\"renderer\" content=\"webkit\"&gt; &lt;meta name=\"keywords\" content=\"我是关键字\"&gt; &lt;meta name=\"description\" content=\"我是网站描述\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\"&gt; &lt;meta content=\"telephone=no,email=no\" name=\"format-detection\" /&gt; &lt;meta name=\"full-screen\" content=\"yes\"&gt; &lt;meta name=\"x5-fullscreen\" content=\"true\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0,maximum-scale=1.0,minimum-scale=1.0,user-scalable=no,minimal-ui\" /&gt; &lt;link rel=\"stylesheet\" href=\"node_modules/todomvc-common/base.css\"&gt; &lt;link rel=\"stylesheet\" href=\"node_modules/todomvc-app-css/index.css\"&gt; &lt;title&gt;Angular | TodoMVC&lt;/title&gt; &lt;style&gt; [ng-cloak] &#123; /*防止闪屏*/ display: none; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body ng-app=\"todomvc\"&gt; &lt;ng-view&gt;&lt;/ng-view&gt; &lt;script type=\"text/ng-template\" id=\"todomvc-index.html\"&gt; &lt;!-- 模板 --&gt; &lt;section id=\"todoapp\"&gt; &lt;header id=\"header\"&gt; &lt;h1&gt;todos&lt;/h1&gt; &lt;!-- form提交时，触发addTodo()事件 --&gt; &lt;form id=\"todo-form\" ng-submit=\"addTodo()\"&gt; &lt;!-- 新todo的输入框，值绑定到newTodo上，根据状态saving来禁用 --&gt; &lt;input id=\"new-todo\" placeholder=\"What needs to be done?\" ng-model=\"newTodo\" ng-disabled=\"saving\" autofocus&gt; &lt;/form&gt; &lt;/header&gt; &lt;!-- #main根据todos的长度来显示隐藏 --&gt; &lt;section id=\"main\" ng-show=\"todos.length\" ng-cloak&gt; &lt;!-- #toggle-all 布尔值绑定到allChecked上，点击时触发markAll --&gt; &lt;input id=\"toggle-all\" type=\"checkbox\" ng-model=\"allChecked\" ng-click=\"markAll(allChecked)\"&gt; &lt;label for=\"toggle-all\"&gt;Mark all as complete&lt;/label&gt; &lt;ul id=\"todo-list\"&gt; &lt;!-- 遍历每个todo，并通过statusFilter进行过滤，通过todo.completed、editedTodo来切换class --&gt; &lt;li ng-repeat=\"todo in todos | filter:statusFilter track by $index\" ng-class=\"&#123;completed: todo.completed, editing: todo == editedTodo&#125;\"&gt; &lt;div class=\"view\"&gt; &lt;!-- todo前的复选框，值绑定到todo.completed，change时触发toggleCompleted事件，并传入对应todo --&gt; &lt;input class=\"toggle\" type=\"checkbox\" ng-model=\"todo.completed\" ng-change=\"toggleCompleted(todo)\"&gt; &lt;!-- 展示用label，双击时触发editTodo，并传入对应todo --&gt; &lt;label ng-dblclick=\"editTodo(todo)\"&gt;&#123;&#123;todo.title&#125;&#125;&lt;/label&gt; &lt;!-- 删除按钮，点击时，移除对应todo --&gt; &lt;button class=\"destroy\" ng-click=\"removeTodo(todo)\"&gt;&lt;/button&gt; &lt;/div&gt; &lt;!-- 隐藏的再编辑表单，在表单提交时触发saveEdits --&gt; &lt;form ng-submit=\"saveEdits(todo, 'submit')\"&gt; &lt;!-- 再编辑input，值绑定到todo.title并不去除前后空格；按下esc时触发reverEdits事件，恢复到之前状态；失去焦点时自动提交；当双击展示用label时，todo和editedTodo相等，会触发todo-focus指令，显示再编辑input--&gt; &lt;input class=\"edit\" ng-trim=\"false\" ng-model=\"todo.title\" todo-escape=\"revertEdits(todo)\" ng-blur=\"saveEdits(todo, 'blur')\" todo-focus=\"todo == editedTodo\"&gt; &lt;/form&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/section&gt; &lt;footer id=\"footer\" ng-show=\"todos.length\" ng-cloak&gt; &lt;!-- #todo-count 展示剩余待做todo数量 --&gt; &lt;span id=\"todo-count\"&gt;&lt;strong&gt;&#123;&#123;remainingCount&#125;&#125;&lt;/strong&gt; &lt;!-- 当count为1显示'item left'，否则显示'items left' --&gt; &lt;ng-pluralize count=\"remainingCount\" when=\"&#123; one: 'item left', other: 'items left' &#125;\"&gt;&lt;/ng-pluralize&gt; &lt;/span&gt; &lt;ul id=\"filters\"&gt; &lt;!-- 过滤状态，点击时触发$routeChangeSuccess事件，改变statusFilter，进而改变展示的数据 --&gt; &lt;li&gt; &lt;a ng-class=\"&#123;selected: status == ''&#125; \" href=\"#/\"&gt;All&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a ng-class=\"&#123;selected: status == 'active'&#125;\" href=\"#/active\"&gt;Active&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a ng-class=\"&#123;selected: status == 'completed'&#125;\" href=\"#/completed\"&gt;Completed&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;!-- 清除所有已完成todo，点击时触发clearCompletedTodos --&gt; &lt;button id=\"clear-completed\" ng-click=\"clearCompletedTodos()\" ng-show=\"completedCount\"&gt;Clear completed&lt;/button&gt; &lt;/footer&gt; &lt;/section&gt; &lt;/script&gt; &lt;!-- 资源文件 --&gt; &lt;script src=\"node_modules/todomvc-common/base.js\"&gt;&lt;/script&gt; &lt;script src=\"node_modules/angular/angular.js\"&gt;&lt;/script&gt; &lt;script src=\"node_modules/angular-route/angular-route.js\"&gt;&lt;/script&gt; &lt;script src=\"node_modules/angular-resource/angular-resource.js\"&gt;&lt;/script&gt; &lt;!-- 逻辑文件 --&gt; &lt;script src=\"js/app.js\"&gt;&lt;/script&gt; &lt;script src=\"js/controllers/todoCtrl.js\"&gt;&lt;/script&gt; &lt;script src=\"js/services/todoStorage.js\"&gt;&lt;/script&gt; &lt;script src=\"js/directives/todoFocus.js\"&gt;&lt;/script&gt; &lt;script src=\"js/directives/todoEscape.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; app.jsapp.js是入口文件，主要是创建了模块，并配置了路由12345678910111213141516171819202122232425262728293031/*global angular *//** * The main TodoMVC app module * * @type &#123;angular.Module&#125; */angular.module('todomvc', ['ngRoute', 'ngResource']) .config(['$routeProvider', function($routeProvider) &#123; 'use strict'; var routeConfig = &#123; controller: 'TodoCtrl', templateUrl: 'todomvc-index.html', // 指定模板 resolve: &#123; store: function(todoStorage) &#123; // 在跳转路由之前载入正确的module // Get the correct module (API or localStorage). return todoStorage.then(function(module) &#123; module.get(); // Fetch the todo records in the background. return module; &#125;); &#125; &#125; &#125;; // 路由跳转 $routeProvider .when('/', routeConfig) .when('/:status', routeConfig) .otherwise(&#123; redirectTo: '/' &#125;); &#125;]); todoStorage.js这个文件是一个服务，主要实现了数据在localStorge中的存储和读写其实这一块没怎么看懂，主要是不太理解ngResource模块的作用，不过大概知道是存储和读取数据用的123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165/*global angular *//** * Services that persists and retrieves todos from localStorage or a backend API * if available. * * They both follow the same API, returning promises for all changes to the * model. */// 这一块是懵逼的...大概就是将数据存储在localStorage中angular.module('todomvc') .factory('todoStorage', function($http, $injector) &#123; 'use strict'; // Detect if an API backend is present. If so, return the API module, else // hand off the localStorage adapter return $http.get('/api') .then(function() &#123; return $injector.get('api'); &#125;, function() &#123; return $injector.get('localStorage'); &#125;); &#125;).factory('api', function($resource) &#123; 'use strict'; var store = &#123; todos: [], api: $resource('/api/todos/:id', null, &#123; update: &#123; method: 'PUT' &#125; &#125;), clearCompleted: function() &#123; var originalTodos = store.todos.slice(0); var incompleteTodos = store.todos.filter(function(todo) &#123; return !todo.completed; &#125;); angular.copy(incompleteTodos, store.todos); return store.api.delete(function() &#123;&#125;, function error() &#123; angular.copy(originalTodos, store.todos); &#125;); &#125;, delete: function(todo) &#123; var originalTodos = store.todos.slice(0); store.todos.splice(store.todos.indexOf(todo), 1); return store.api.delete(&#123; id: todo.id &#125;, function() &#123;&#125;, function error() &#123; angular.copy(originalTodos, store.todos); &#125;); &#125;, get: function() &#123; return store.api.query(function(resp) &#123; angular.copy(resp, store.todos); &#125;); &#125;, insert: function(todo) &#123; var originalTodos = store.todos.slice(0); return store.api.save(todo, function success(resp) &#123; todo.id = resp.id; store.todos.push(todo); &#125;, function error() &#123; angular.copy(originalTodos, store.todos); &#125;) .$promise; &#125;, put: function(todo) &#123; return store.api.update(&#123; id: todo.id &#125;, todo) .$promise; &#125; &#125;; return store;&#125;).factory('localStorage', function($q) &#123; 'use strict'; var STORAGE_ID = 'todos-angularjs'; var store = &#123; todos: [], _getFromLocalStorage: function() &#123; return JSON.parse(localStorage.getItem(STORAGE_ID) || '[]'); &#125;, _saveToLocalStorage: function(todos) &#123; localStorage.setItem(STORAGE_ID, JSON.stringify(todos)); &#125;, clearCompleted: function() &#123; var deferred = $q.defer(); var incompleteTodos = store.todos.filter(function(todo) &#123; return !todo.completed; &#125;); angular.copy(incompleteTodos, store.todos); store._saveToLocalStorage(store.todos); deferred.resolve(store.todos); return deferred.promise; &#125;, delete: function(todo) &#123; var deferred = $q.defer(); store.todos.splice(store.todos.indexOf(todo), 1); store._saveToLocalStorage(store.todos); deferred.resolve(store.todos); return deferred.promise; &#125;, get: function() &#123; var deferred = $q.defer(); angular.copy(store._getFromLocalStorage(), store.todos); deferred.resolve(store.todos); return deferred.promise; &#125;, insert: function(todo) &#123; var deferred = $q.defer(); store.todos.push(todo); store._saveToLocalStorage(store.todos); deferred.resolve(store.todos); return deferred.promise; &#125;, put: function(todo, index) &#123; var deferred = $q.defer(); store.todos[index] = todo; store._saveToLocalStorage(store.todos); deferred.resolve(store.todos); return deferred.promise; &#125; &#125;; return store;&#125;); todoEscape.js这是一个指令，主要完成按下esc键，恢复再编辑input到原先状态12345678910111213141516171819202122232425/*global angular *//** * Directive that executes an expression when the element it is applied to gets * an `escape` keydown event. */// esc键绑定事件// 当按下Escape键时，执行attrs.todoEscape的表达式。angular.module('todomvc') .directive('todoEscape', function() &#123; 'use strict'; var ESCAPE_KEY = 27; return function(scope, elem, attrs) &#123; // 直接返回一个函数，实际上就是link函数；在link函数中绑定事件 elem.bind('keydown', function(event) &#123; if (event.keyCode === ESCAPE_KEY) &#123; // 按下esc，触发attrs.todoEscape对应的事件 scope.$apply(attrs.todoEscape); &#125; &#125;); scope.$on('$destroy', function() &#123; // 销毁时，解除绑定 elem.unbind('keydown'); &#125;); &#125;; &#125;); todoFocus.js这个指令主要完成再编辑input的显示和聚焦1234567891011121314151617181920/*global angular *//** * Directive that places focus on the element it is applied to when the * expression it binds to evaluates to true */angular.module('todomvc') .directive('todoFocus', function todoFocus($timeout) &#123; 'use strict'; return function(scope, elem, attrs) &#123; // 在二次编辑的input上绑定事件 scope.$watch(attrs.todoFocus, function(newVal, oldVal) &#123; // 当双击时，newVal为true if (newVal) &#123; $timeout(function() &#123; elem[0].focus(); &#125;, 0, false); &#125; &#125;); &#125;; &#125;); todoCtrl.js这是重头性，关键性逻辑全写在这123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126/*global angular *//** * The main controller for the app. The controller: * - retrieves and persists the model via the todoStorage service * - exposes the model to the template and provides event handlers */angular.module('todomvc') .controller('TodoCtrl', function TodoCtrl($scope, $routeParams, $filter, store) &#123; 'use strict'; var todos = $scope.todos = store.todos; // 从localStorge中取出所有todo $scope.newTodo = ''; // 用来保存新创建的todo $scope.editedTodo = null; // 用来保存编辑过的todo $scope.$watch('todos', function() &#123; // 深度观察todos的值 $scope.remainingCount = $filter('filter')(todos, &#123; completed: false &#125;).length; // 更新未完成的todo数量 $scope.completedCount = todos.length - $scope.remainingCount; // 更新完成的todo数量 $scope.allChecked = !$scope.remainingCount; // 是否全部完成 &#125;, true); // Monitor the current route for changes and adjust the filter accordingly. $scope.$on('$routeChangeSuccess', function() &#123; // 观察路由跳转，并更新用来过滤的statusFilter var status = $scope.status = $routeParams.status || ''; $scope.statusFilter = (status === 'active') ? &#123; completed: false &#125; : (status === 'completed') ? &#123; completed: true &#125; : &#123;&#125;; &#125;); $scope.addTodo = function() &#123; // 输入框提交时触发 var newTodo = &#123; // 创建新todo title: $scope.newTodo.trim(), //newTodo是绑定在input输入框上 completed: false &#125;; if (!newTodo.title) &#123; // 空值，则不提交 return; &#125; $scope.saving = true; // saving用来标识input的禁用状态，为true则禁用 store.insert(newTodo) // 插入新todo .then(function success() &#123; // 成功则重置newTodo $scope.newTodo = ''; &#125;) .finally(function() &#123; $scope.saving = false; // 最后取消input的禁用状态 &#125;); &#125;; $scope.editTodo = function(todo) &#123; // 已添加的todo上双击时触发，会将双击的todo传入 $scope.editedTodo = todo; // 保存正在编辑的todo // Clone the original todo to restore it on demand. $scope.originalTodo = angular.extend(&#123;&#125;, todo); // 保留原先的todo，以备不时之需 &#125;; $scope.saveEdits = function(todo, event) &#123; // 再编辑input提交或者blur时触发 // Blur events are automatically triggered after the form submit event. // This does some unfortunate logic handling to prevent saving twice. if (event === 'blur' &amp;&amp; $scope.saveEvent === 'submit') &#123; // 提交时，会自动触发一次blur，所以手动阻止 $scope.saveEvent = null; return; &#125; $scope.saveEvent = event; // 保存事件类型(blur或submit) if ($scope.reverted) &#123; // 如果编辑后按esc，取消了编辑，则不保存 // Todo edits were reverted-- don't save. $scope.reverted = null; return; &#125; todo.title = todo.title.trim(); // 保存新编辑title if (todo.title === $scope.originalTodo.title) &#123; // title未发生改变，则不保存 $scope.editedTodo = null; return; &#125; store[todo.title ? 'put' : 'delete'](todo) .then(function success() &#123;&#125;, function error() &#123; // 保存出错，则恢复title todo.title = $scope.originalTodo.title; &#125;) .finally(function() &#123; // 最后，重置editedTodo $scope.editedTodo = null; &#125;); &#125;; $scope.revertEdits = function(todo) &#123; // todoEscape时触发，将再编辑input恢复到编辑前的状态，会传入需要恢复的todo todos[todos.indexOf(todo)] = $scope.originalTodo; $scope.editedTodo = null; $scope.originalTodo = null; $scope.reverted = true; &#125;; $scope.removeTodo = function(todo) &#123; // 删除todo store.delete(todo); &#125;; $scope.saveTodo = function(todo) &#123; // 保存todo store.put(todo); &#125;; $scope.toggleCompleted = function(todo, completed) &#123; // 切换完成状态 if (angular.isDefined(completed)) &#123; // 如果completed曾经定义过，则直接使用 todo.completed = completed; &#125; // 更新localStorge上的todo的complete store.put(todo, todos.indexOf(todo)) .then(function success() &#123;&#125;, function error() &#123; // 保存出错，则恢复 todo.completed = !todo.completed; &#125;); &#125;; $scope.clearCompletedTodos = function() &#123; // 清除所有已经完成的todo store.clearCompleted(); &#125;; $scope.markAll = function(completed) &#123; // 将所有todo置为已完成 todos.forEach(function(todo) &#123; if (todo.completed !== completed) &#123; $scope.toggleCompleted(todo, completed); &#125; &#125;); &#125;; &#125;);","tags":[{"name":"Angular","slug":"Angular","permalink":"http://yoursite.com/tags/Angular/"},{"name":"todoMVC","slug":"todoMVC","permalink":"http://yoursite.com/tags/todoMVC/"}]},{"title":"Maintainable-Javascript","date":"2017-06-30T02:39:31.000Z","path":"2017/06/30/Maintainable-Javascript/","text":"本文为阅读《编写可维护的Javascript》的笔记，记录了一些个人认为重要的点，带有一定个人理解，并未深入展开，如需详细了解可阅读原书籍。这本书，是从可维护性的角度出发，介绍了如何编写可维护性的js代码，读完，还是有收获的，特别是第二部分的编程实践，很基础，但也很实用。综合来看，还是一本不错的书籍，值得一看。PS:本书主要从可维护性的角度出发，有些写法并不一定是最优解，因人而异，取其精华，去其糟粕。本人github上有很多本人学习前端时保存的demo，都带有注释，适合新手入门。如果对大家有帮助。望star~https://github.com/BryanAdamss/SourceSave 《编写可维护的Javascript》笔记编程风格基本格式化 代码缩进 使用4空格代替tab；不同编辑器对于tab的解释不一样，有的是2空格长度，有的是4空格长度； 语句结尾 总是使用分号;结尾 行的长度 单行不超过80个字符 空行 使用空行分隔语义不同的代码段 命名 驼峰命名法 变量 名词开头-&gt;count、myName 函数 动词开头-&gt;(can、has、is、get、set)isEnabled、getName 构造函数 首字母大写123function Person(name)&#123; this.name=name;&#125; 常量 全大写，下划线区分12var MAX_COUNT=10, URL='https://github.com/BryanAdamss/SourceSave'; 直接量 字符串-&gt;单双引号皆可，不过个人推荐用单引号，因为在拼接html字符串时很方便) 数字-&gt;不省略小数点前后的数字 null-&gt;当做对象占位符使用 undefined-&gt;已声明但没有赋值的变量会获得此值 对象直接量 1234567// 不好的写法var book=new Object();book.title='Javascript';// 好的写法var book=&#123; title:'Javascript'&#125;; 数组直接量 1234// 不好的写法var colors=new Array('red','green');// 好的写法var colors=['red','green']; 注释 只在需要注释的时候才添加注释-&gt;只在需要让代码变得更清晰的时候添加注释 逻辑复杂难于理解的代码 可能被误认为错误的代码 语句和表达式 switch语句 js中的switch不同于其他语言，switch的条件和case从句可以是任意类型值，其他语言必须是原始值或者常量 with语句-&gt;不要使用 循环 for-&gt;在初始化中缓存遍历次数 123for(var i=0,len=arr.length;i&lt;len;i++)&#123; doSth();&#125; for-in-&gt;配合hasOwnProperty过滤非实例属性/方法 123456for(var prop in testObj)&#123; if(testObj.hasOwnProperty(prop))&#123; console.log('属性名为:'+prop); console.log('属性名对应的属性值为:'+testObj[prop]); &#125;&#125; forEach-&gt;针对数组用forEach 总结:对象(除数组)用for-in，数组用forEach，其他用for 变量、函数和运算符 变量声明 单var声明 123var a=3, b=4, c=5; 将局部变量的定义做为函数内第一条语句 1234567891011121314151617181920 function getName()&#123; var a=3, b=4, c=5; &#125; ``` - 函数声明 - 先声明再使用 - 函数内声明函数时，可将函数声明放在变量生命之后 ```javascript function getName()&#123; var a=3, b=4, c=5; function getOtherName()&#123; doSth(); &#125; getOtherName(); &#125; 立即调用函数 使用圆括号包裹123var a=(function()&#123; doSth();&#125;)(); 严格模式-&gt;只在局部使用 相等-&gt;使用=== eval-&gt;避免使用 原始包装类型-&gt;避免使用原始包装类型构造函数 编程实践UI层的松耦合 将javascript从css中抽离 禁用css表达式1234/*不好的写法*/.box&#123; width:expression(document.body.offsetWidth+\"px\");&#125; 将css从javascript中抽离 用js控制样式类，而不是直接操纵样式 当需要控制元素位置时，可直接用js操纵样式(top,left…) 将javascript从HTML中抽离 不要在html标签上用onclick=…，改用事件addEventListener 将HTML从javascript中抽离 使用客户端模板引擎，例如handlebars 避免使用全局变量 全局变量带来的问题 命名冲突 代码脆弱性 难以测试 意外的全局变量 未声明直接赋值了 12345function ()&#123; var a=3;// 局部变量 var b;// 局部变量 c=3;// 全局变量&#125; 如何避免 总是使用var来声明变量，即时是声明全局变量 单全局变量 只声明一个全局变量，所有功能全挂载到这个全局变量上 模块 规范CommonJs、AMD、CMD 对应实现NodeJs、RequireJs、SeaJs 零全局变量 使用立即函数包裹123(function(win)&#123; // doSth&#125;)(window); 事件处理 不好的写法 1234567function handleClick(event)&#123; var popup=document.getElementById('popup'); popup.style.left=event.clientX+'px'; popup.style.top=event.clientY+'px'; popup.className='reveal';&#125;ele.addEventListener('click',handleClick,false); 事件处理规则1 隔离应用逻辑-&gt;将应用(业务)逻辑从事件处理程序中抽离 1234567891011121314var MyApp=&#123; handleClick:function(event)&#123; this.showPopup(event); &#125;, showPopup:function(event)&#123; var popup=document.getElementById('popup'); popup.style.left=event.clientX+'px'; popup.style.top=event.clientY+'px'; popup.className='reveal'; &#125;&#125;;ele.addEventListener('click',function(event)&#123; MyApp.handleClick(event);&#125;,false); 不要分发事件对象-&gt;只传需要的信息 应用逻辑不应当依赖于event对象来正确完成功能 将event对象做为参数并不能告诉你event的哪些属性是有用的 测试时，需要重建event对象 最佳实践 让事件处理程序使用event对象来处理事件，然后拿到需要的数据传给应用逻辑 1234567891011121314var MyApp=&#123; handleClick:function(event)&#123; this.showPopup(event.clientX,event.clientY);// 只传需要的信息 &#125;, showPopup:function(x,y)&#123; var popup=document.getElementById('popup'); popup.style.left=x+'px'; popup.style.top=y+'px'; popup.className='reveal'; &#125;&#125;;ele.addEventListener('click',function(event)&#123; MyApp.handleClick(event);&#125;,false); 让事件处理程序成为接触到event对象的唯一的函数，事件处理程序应当在进入应用逻辑之前针对event对象执行任何必要的操作。包括阻止默认事件和冒泡。 12345678910111213141516var MyApp=&#123; handleClick:function(event)&#123;// 在事件处理程序中针对event进行必要的处理 event.preventDefault(); event.stopPropagation(); this.showPopup(event.clientX,event.clientY);// 只传需要的信息 &#125;, showPopup:function(x,y)&#123; var popup=document.getElementById('popup'); popup.style.left=x+'px'; popup.style.top=y+'px'; popup.className='reveal'; &#125;&#125;;ele.addEventListener('click',function(event)&#123; MyApp.handleClick(event);&#125;,false); 避免空比较 检测原始值的类型 字符串、数字、布尔、undefined-&gt;typeof 1234typeof 'a';// 'string'typeof 3;// 'number'typeof true;// 'boolean'typeof undefined;// 'undefined' null-&gt;一般不用于类型检测，除非null是一种可预期的页面时可用===和!==来判断是否为null值 1234var ele=document.getElementById('my-div');if(ele!==null)&#123;// 如果DOM元素不存在，则ele就为null，此时null是一个可预期的值，所以可以===或!==来判断 // doSth &#125; 检测引用值的类型 使用value instanceof constructor 123456789if(value instance Data)&#123; // doSth&#125;if(value instance RegExp)&#123; // doSth&#125;if(value instance Object)&#123; // doSth &#125; 但函数、数组不能用instanceof来判断，因为存在跨帧问题(cross-frame) 检测函数(判断某一引用值是否是函数(是否是函数类型)) 使用typeof 12function myFn()&#123;&#125;typeof myFn;// 'function' 使用typeof检测IE8及以下DOM元素的方法时，会返回’object’;退而求其次会使用in来判断；因为DOM明确定义，了解到对象成员如果存在则意味着它是一个方法 123if('querySelectorAll' in document)&#123; var imgs=document.querySelectorAll('img');&#125; 检测数组(判断某一引用值是否是数组(是否是数组类型)) 使用ES5的isArray 不支持的则使用Object.prototype.toString.call(value)1234567function isArray(value)&#123; if(typeof Array.isArray==='function')&#123; return Array.isArray(value); &#125;else&#123; return Object.prototype.toString.call(value)==='[object Array]'; &#125;&#125; 检测属性/方法存在性 使用prop in obj 检测属性/方法是否为实例属性-&gt;obj.hasOwnProperty(‘prop’) IE8及以下判断是否为实例属性-&gt;需先判断hasOwnProperty的存在性 总结 判断数据类型 原始值 字符串、数字、布尔、undefined-&gt;typeof 如if(typeof &#39;test&#39;===&#39;string&#39;){...} null-&gt;只有在null是一个可预期的值时，才用来比较，使用===，!== 引用值 自定义、非函数、非数组对象-&gt;使用obj instanceof constructor 如obj instanceof Data 函数/方法 非DOM对象的方法/函数-&gt;typeof 如typeof myFn===&#39;function&#39; DOM对象的方法-&gt;无法使用typeof，只能通过in判断它存在，然后直接使用 数组 支持isArray-&gt;Array.isArray(value) 不支持-&gt;Object.prototype.toString.call(value)===&#39;[object Array]&#39; 判断属性/方法存在性 一般属性/方法-&gt;统一使用in 实例属性存在性-&gt;统一使用hasOwnProperty IE8及以下判断实例属性存在性-&gt;先判断hasOwnProperty的存在性，再调用hasOwnProperty 将配置数据从代码中抽离 配置数据 URL 展现给用户的字符串 重复的值 设置(每页的配置项) 任何可能发生变更的值 抽离 将配置数据抽离成一个对象 1234var config=&#123; MSG_INVALID_VALUE:'不合法的值', URL:'https://github.com/BryanAdamss/SourceSave'&#125;; 将配置数据抽离成一个对象，并放在一个单独的文件中 抛出自定义错误 如果没有通过try-catch语句捕获，抛出任何值都将引发一个错误。如直接throw &#39;message&#39;，会引发一个错误 何时抛出错误 抛出错误最佳的地方是在工具函数中，如addClass()函数，它是通用脚本的一部分，会在很多地方使用。-&gt;在javascript类库中使用 错误类型 Error、EvalError、RangeError、ReferenceError、SyntaxError、TypeError、URIError 不是你的对象不要动 不要修改原生对象以及一些类库对象 原则：将已经存在的js对象当做工具函数库那样使用 不覆盖方法 不覆盖原对象的方法 不新增方法 不在不属于你的对象上添加方法 不删除方法 不要删除一个不是你的对象上的方法 更好方法 继承原对象，在其基础上扩充 阻止修改(锁定后，将无法解锁) 防止扩展-&gt;无法新增属性和方法，可删除 Object.preventExtension(obj); Object.isExtensible(); 密封对象-&gt;已存在的属性、方法无法被删除，可修改 Object.seal(obj); Object.isSealed(); 冻结对象-&gt;防止扩展+密封，无法删除，无法修改 Object.freeze(obj); Object.isFrozen(); 浏览器嗅探 UA检测 缺点 UA可以被修改 浏览器为了兼容性，都会包含其他浏览器的UA字符串 特性检测-&gt;根据功能(特性)来检测 不要进行特性推断-&gt;不要根据一个特性的是否存在去推断另一个特性是否存在 不要进行浏览器推断-&gt;不要根据一个特性的是否存在去推断是某种浏览器 优先级:特性检测&gt;UA检测 自动化文章第三部分介绍的是前端自动化方面的知识，但用的是Ant(需要JAVA环境)，由于现在用gulp的比较多，所以这一块就只是大概扫了一下。 流程 构建-&gt;验证-&gt;合并、加工-&gt;精简、压缩-&gt;文档化-&gt;自动化测试-&gt;集成","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"Angualr-guide","date":"2017-06-07T01:19:44.000Z","path":"2017/06/07/Angualr-guide/","text":"本文为自己学习angular的笔记，带有个人理解。学习的版本为1.2.32对应的源码在https://github.com/BryanAdamss/SourceSave/tree/master/AngularJs本仓库还包含大量本人前端练习用的demo，希望对大家有帮助。望star~ Angular学习笔记Angular适用场景 适合：大量CRUD(增删改查)操作的场景，如后台管理系统 不适合：游戏、大量UI操作的场景 DataBinding 双向：view、model之间会相互同步数据 Controller 在controller中做 设置$scope的初始状态 为$scope添加一些行为 不要在controller中做 手动操作DOM：controller中应该仅包含业务逻辑；如果在controller中添加表现相关逻辑，会严重影响测试；DOM操作应该封装在directives中；另外AngularJs中也封装了一些常用DOM操作指令，如ng-show等。 格式化输入： Use AngularJS form controls instead. 过滤输出： Use AngularJS filters instead. 传递数据或状态： Use AngularJS services instead. 管理其他组件的周期：例如在controller中创建services Services 特点 lazy实例化：只有当某个services被依赖时，它才会被实例化 单例：每个依赖services的component都会得到由service factory产生的service单实例的一个引用（service都是单例的，只要创建了一个Service，那么程序都在使用这唯一的Service) 以$开头的，都是内置服务，eg：$http service可以被用来传递数据、实现代码复用 创建并使用：通过service工厂函数来创建（factory函数）123456789101112131415 angular.module('myServiceModule', []). controller('MyController', ['$scope', 'notify', function($scope, notifyInstance) &#123;//3.这里notyfy被依赖，所以立马被实例化并将2处的匿名函数赋值给了notifyInstance $scope.callNotify = function(msg) &#123; notifyInstance (msg); &#125;; &#125;]).factory('notify', ['$window', function(win) &#123;// 1.这里注册了一个notify的服务，而且还依赖另一个内置服务$winodw，注意这里还只是注册一个notify的构造函数，并没有创建notify的实例 var msgs = []; return function(msg) &#123;// 2.return里的是当服务被加载(依赖时)返回的实例对象或函数 msgs.push(msg); if (msgs.length === 3) &#123; win.alert(msgs.join('\\n')); msgs = []; &#125; &#125;; &#125;]); Scope 特点 它只是一个普通的js对象 它指向了应用的model 它是表达式的执行环境context 它拥有和DOM一样的树形结构 它能监视表达式 它能传播事件 它提供了$watch来观察模型的变化 它提供了$apply来传播模型的变化 它可以嵌套以限制对应用程序组件属性的访问，同时提供对共享模型属性的访问。 它是controller和view间的胶水 层次结构（类似DOM的树形结构） 每个angularApp都有一个根scope，$rootScope，$rootScope有一个或多个子scope 查找某属性时，会像js作用域一样，逐层向上找 angularJs会在每个绑定了scope元素的class上添加ng-scope directive可以创建scope 获取DOM元素上绑定的scope 可以通过angular.element(dom元素).scope() 在chrome中，也可以通过 angular.element($0).scope()或者在选中一个dom元素后直接在控制台中$scope，就能得到相应dom上的$scope 可以通过安装 AngularJS Batarang插件来查看 事件传播 $emit(eventName) 向上传播事件 $broadcast(eventName) 向下传播事件 生命周期： Creation-&gt; Watcher registration-&gt; Model mutation-&gt; Mutation observation-&gt; Scope destruction DependencyInjection(DI) 使用 services、directives、filter、animation可以将”services”、”value”型组件作为依赖注入 123456789angular.module('myModule', []).factory('serviceId', ['depService', function(depService) &#123; // ...&#125;]).directive('directiveName', ['depService', function(depService) &#123; // ...&#125;]).filter('filterName', ['depService', function(depService) &#123; // ...&#125;]); controller可以将”services”、”value”型组件作为依赖注入，但他们还可以注入一些特殊的依赖如$scope 1234567someModule.controller('MyController', ['$scope', 'dep1', 'dep2', function($scope, dep1, dep2) &#123;...$scope.aMethod = function() &#123;...&#125;...&#125;]); 为module提供run、config方法时，可以使用DI config接收一个函数，函数可以注入”provider”、”constant”型组件；不可将”services”、”value”型注入到config中 run接收一个函数，函数可以注入”services”、”value”以及”constant”(常数)型组件；不可将”providers”型注入到run中12345angular.module('myModule', []).config(['depProvider', function(depProvider) &#123;// ...&#125;]).run(['depService', function(depService) &#123;// ...&#125;]); 依赖声明 行内数组声明(推荐、最优) 123someModule.controller('MyController', ['$scope', 'greeter', function($scope, greeter) &#123;// ...&#125;]); 使用$inject(可让controller通过js压缩) 12345var MyController = function($scope, greeter) &#123;// ...&#125;MyController.$inject = ['$scope', 'greeter'];someModule.controller('MyController', MyController); 隐式声明依赖(压缩时，会出错)-&gt;尽量避免用此方法 123someModule.controller('MyController', function($scope, greeter) &#123;// ...&#125;); 通过在ng-app指令所在html元素上添加 ng-strict-di指令，以限制隐式声明的使用(若使用隐式声明 ，会报错) Templates angularJS中的template是由html以及angularJs声明的元素及特性组成。angularJs通过controller组合model中的信息和模板以呈现动态的view给用户 templates中可以使用 directive {{}} filter form controller 1234567891011&lt;html ng-app&gt; &lt;!-- Body tag augmented with ngController directive --&gt; &lt;body ng-controller=\"MyController\"&gt; &lt;input ng-model=\"foo\" value=\"bar\"&gt; &lt;!-- Button tag with ngClick directive, and string expression 'buttonText' wrapped in \"&#123;&#123; &#125;&#125;\" markup --&gt; &lt;button ng-click=\"changeFoo()\"&gt;&#123;&#123;buttonText&#125;&#125;&lt;/button&gt; &lt;script src=\"angular.js\"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 在复杂的app中,可以将不同的模板放在单独的html中，然后通过ng-view来引用 Expressions 主要用在插值绑定(interpolation bindings)中，但也可以直接用在指令中；如ng-click=”functionExpression()”；以下都是合法的 1+2 a+b user.name items[index] 和Js的表达式的异同 context：js中的context一般是全局变量window；angular中表达式的context则是scope js中尝试计算未定义的属性，会报错；angular则不会直接报错，而是转为undefined或null 在angular表达式中可以用filter在展示数据前进行数据格式化 在angular的表达式中没有条件控制相关语句；如if、for等，但三元操作符中可以用 在angular的表达式中不能有函数声明，及时在ng-init指令中 在angular的表达式中不能创建正则表达式 在angular的表达式中不能通过new创建对象 在angular的表达式中不能使用位运算、void、逗号等操作符 如果想解析angularJs表达式，不要用eval，使用$eval 总结：如果想使用复杂js代码，可以将其封装在controller中，然后在view中调用。不推荐直接在表达式中书写大量代码； $event 在执行ng-click、ng-focus等指令时，会在表达式范围内将$event暴露出来，$event是类似jquery Event的对象 one-time绑定(数据只绑定一次) 优势：只绑定一次，可减少监视次数 使用：在变量前添加双冒号；类似{{::name}} 何时( 当表达式被设定后，就不会被改变时 ) 用在插值文本和特性时 1&lt;div name=\"attr: &#123;&#123;::color&#125;&#125;\"&gt;text: &#123;&#123;::name | uppercase&#125;&#125;&lt;/div&gt; 当用directive双向绑定数据并且参数不会改变时 1234567891011someModule.directive('someDirective', function() &#123; return &#123; scope: &#123; name: '=', color: '@' &#125;, template: '&#123;&#123;name&#125;&#125;: &#123;&#123;color&#125;&#125;' &#125;;&#125;);&lt;div some-directive name=\"::myName\" color=\"My color is &#123;&#123;::myColor&#125;&#125;\"&gt;&lt;/div&gt; 指令中包含表达式时 123&lt;ul&gt; &lt;li ng-repeat=\"item in ::items | orderBy:'name'\"&gt;&#123;&#123;item.name&#125;&#125;;&lt;/li&gt;&lt;/ul&gt; Interpolation 针对布尔attr，如disabled、required、selected、checked、readOnly、open，不要使用原生的，使用ng-disabled、ng-required… 使用ng-attr-xxx绑定任意特性，如ng-attr-cx；若为驼峰形式，则用下划线代替，如viewBox，则使用ng-attr-view_box Filters 在view中的语法 正常语法 1&#123;&#123; expression | filterName &#125;&#125; Filter Chain-&gt;用上一个filter的输出作为下一个filter的输入 1&#123;&#123; expression | filter1Name | filter2Name | ... &#125;&#125; 带参数 12&#123;&#123; expression | filterName:argument1:argument2:... &#125;&#125;如 &#123;&#123; 1234 | number:2 &#125;&#125; 当filter用在controller、services、directives上时，需采用Filter形式 需要在controller中使用number过滤器时1234angular.module('numberFilterExample', []).controller('ExampleController', ['numberFilter', function(numFilter) &#123; // ....&#125;]); 创建自定义filter 使用filter函数123456789101112angular.module('myReverseFilterApp', []).filter('reverse', function() &#123; return function(input) &#123;// return 一个函数 input = input || ''; var out = ''; for (var i = 0; i &lt; input.length; i++) &#123; out = input.charAt(i) + out; &#125; return out; &#125;;&#125;)// html中直接&#123;&#123; data | reverse&#125;&#125; 常用filter date日期格式-&gt; {{ now | date:'yyyy-MM-dd hh:mm:ss a' }} currency货币格式化 fiter对数组、字符串、对象等进行筛选显示 1234567891011$scope.city = [&#123; id: \"001\", name: \"上海\" &#125;, &#123; id: \"002\", name: \"北京\"&#125;];// view &#123;&#123;city&#125;&#125; &#123;&#123;city|filter:'上海'&#125;&#125;// 默认筛选出所有value值为'上海'的object &#123;&#123;city|filter:&#123;name:'北京'&#125; &#125;&#125;// 筛选出name为北京的object orderBy排序 {{city |orderBy:'id'}} 默认正序 {{city |orderBy:'-id'}} 反序 json 将对象解析成json，主要用来调试 Forms angularJs对表单域做了增强，添加了很多功能 使用ng-model就可以将表单的值和model进行双向绑定 使用novalidate屏蔽浏览器原生验证 angualrJs会添加一些class类，来标识验证的状态，根据这些验证状态class类，来写不同的样式 ng-valid：model验证通过 ng-invalid：model未验证通过 ng-valid-[ruleName]：ruleName的验证规则已通过 ng-invalid-[ruleName ]：ruleName的验证规则未通过 ng-pristine：这个表单域还没有交互过(未修改过) ng-dirty：这个表单域已经交互过(修改过) ng-touched：这个表单域 失去焦点 ng-untouched：这个表单域未失去焦点 ng-pending：异步验证还未完成 可以根据表单验证的一些状态，来辅助添加帮助信息 通过ng-model-options来设置一些属性 ng-model-options=”{ updateOn: ‘blur’ }” 在blur时更新model 延时更新model ng-model-options=”{ debounce: 500 }” ng-model-options=”{ updateOn: ‘default blur’, debounce: { default: 500, blur: 0 } }” 可通过编写directive来创建自己的验证规则、表单域 可以修改内置的验证规则 相关状态 字段错误信息-&gt;formName.fieldName.$error-&gt;验证通过的规则会显示false，未通过的显示true 字段无效信息-&gt;formName.fieldName.$invalid 字段有效信息-&gt;formName.fieldName.$valid 字段是否更改-&gt;formName.fieldName.$dirty 字段是否未更改-&gt;formName.fieldName.$pristine $scope.formName.$setPristine-&gt;将表单恢复到最初状态，class、$dirty等都被恢复 Directives 匹配 12345678&lt;div ng-controller=\"Controller\"&gt;&lt;!-- 下面这几种形式，都将input和model中name绑定起来了，绑定这个指令就匹配上了 --&gt; Hello &lt;input ng-model='name'&gt; &lt;hr/&gt;&lt;!-- 建议形式 --&gt; &lt;span ng-bind=\"name\"&gt;&lt;/span&gt; &lt;br/&gt;&lt;!-- 建议形式 --&gt; &lt;span ng:bind=\"name\"&gt;&lt;/span&gt; &lt;br/&gt; &lt;span ng_bind=\"name\"&gt;&lt;/span&gt; &lt;br/&gt; &lt;span data-ng-bind=\"name\"&gt;&lt;/span&gt; &lt;br/&gt; &lt;span x-ng-bind=\"name\"&gt;&lt;/span&gt; &lt;br/&gt;&lt;/div&gt; ng-attr-xxx-&gt;所有ng-attr开头的特性，最后都会转化到原生的特性上，建议不要在原生的特性上绑定值，都用ng-attr开头(因为某些原生特性和ng配合的不好) 123&lt;svg&gt; &lt;circle ng-attr-cx=\"&#123;&#123;cx&#125;&#125;\"&gt;&lt;/circle&gt;&lt;!-- 将&#123;&#123;cx&#125;&#125;绑定到了原生的cx上 --&gt;&lt;/svg&gt; 指令类型 A（attribute）、E（element）、M（comment）、C（class）;M和C不常用，如果需要兼容IE8，建议全部用A 1234&lt;my-dir&gt;&lt;/my-dir&gt;&lt;span my-dir=\"exp\"&gt;&lt;/span&gt;&lt;!-- directive: my-dir exp --&gt;&lt;span class=\"my-dir: exp;\"&gt;&lt;/span&gt; 注意：由于历史原因，浏览器在解析html标签和标签attribute时，会自动忽略大小写，统一使用小写形式；这就导致了，用驼峰形式定义的html标签（&lt;myTag&gt;）和特性会被转换为全小写（&lt;mytag&gt;）；那么用驼峰形式定义的指令在匹配E和A时，就找不到（无法匹配），为了解决这问题，ng会在定义时用的驼峰形式directive(“myTag”,xxx)转换成my-tag，这样在html中my-tag形式的标签和特性就会被匹配到。如果定义时没用驼峰形式(全小写)，则不会转换，直接匹配。驼峰形式的指令名在匹配M和C时不会存在转换-&gt;总结:在定义指令时如果用了驼峰形式匹配EA，则在html中使用时就要转换成短横线连接的形式如myTag转换成my-tag-&gt;最佳实践：ng中指令若用驼峰则html中用短横线连接； 创建指令 module.directive(directiveName,fn); 12345678910angular.module('docsSimpleDirective', []).controller('Controller', ['$scope', function($scope) &#123; $scope.customer = &#123; name: 'Naomi', address: '1600 Amphitheatre' &#125;;&#125;]).directive('myCustomer', function() &#123; return &#123;// 尽量都返回一个object，不要只返回一个函数 template: 'Name: &#123;&#123;customer.name&#125;&#125; Address: &#123;&#123;customer.address&#125;&#125;' // 除非你的模板很小，否则使用templateUrl来引入外部单独的模板html文件 &#125;;&#125;); templateUrl-&gt;除非你的模板很小，否则使用templateUrl来引入外部单独的模板html文件 当replace为true时，tpl文件内容必须被包裹在一个标签内，也即tpl文件只能有一个根标签；即不能存在有文本未被标签包裹，也不能存在多个根标签；因为替换的时候ng找不到一个唯一的节点做为替换节点，所以必须得有一个最外层的根节点；template也存在同样情况-&gt;最佳实践，任何情况下，都让模板文件包裹在一个根标签中，这样也方便文件的组织管理 可以在模板中使用$scope中的变量 templateUrl中可以指定type=text/ng-template的script为模板，只需要在templateUrl中写上script模板的id；注意：这个script模板必须在ng-app中，而且，若replact为true，则也需要一个根标签1234567891011angular.module('docsTemplateUrlDirective', []).controller('Controller', ['$scope', function($scope) &#123; $scope.customer = &#123; name: 'Naomi', address: '1600 Amphitheatre' &#125;;&#125;]).directive('myCustomer', function() &#123; return &#123; templateUrl: 'my-customer.html' &#125;;&#125;); restrict-&gt;设置指令的匹配模式(AEMC)；默认是AE（匹配attribute、element类型指令)；M和C不常用 123456789101112131415angular.module('docsRestrictDirective', []).controller('Controller', ['$scope', function($scope) &#123; $scope.customer = &#123; name: 'Naomi', address: '1600 Amphitheatre' &#125;;&#125;]).directive('myCustomer', function() &#123; return &#123; restrict: 'E', templateUrl: 'my-customer.html' &#125;;&#125;);// 什么情况下该用元素名，什么情况下该用属性名？ 当创建一个含有自己模板的组件的时候，建议使用元素名，常见情况是，当你想为你的模板创建一个DSL（特定领域语言）的时候。如果仅仅想为已有的元素添加功能，建议使用属性名.// 当需要创建一个自己的组件时-&gt;创建E型指令// 为已有元素添加新功能-&gt;创建A型指令 isolate scope 存在原因：若无独立作用域，则在一个作用域下，多个指令无法独立执行；使用独立作用域，可以将指令限制在独立的作用域下执行，互不干扰 创建：在创建directive时指定scope属性 1234567891011angular.module('docsIsolateScopeDirective', []).controller('Controller', ['$scope', function($scope) &#123; $scope.naomi = &#123; name: 'Naomi', address: '1600 Amphitheatre' &#125;; $scope.igor = &#123; name: 'Igor', address: '123 Somewhere' &#125;;&#125;]).directive('myCustomer', function() &#123; return &#123; restrict: 'E', scope: &#123; customerInfo: '=info' // 将customerInfo绑定到指令所在元素的info特性上，如果外面的特性也叫customerInfo，则可以直接使用缩写形式\"=\" &#125;, templateUrl: 'my-customer-iso.html' &#125;;&#125;); 独立作用域会隔离除你添加到scope: {} 对象中的数据模型之外的一切东西。 因为它可以阻止除你传入的数据模型之外的一切东西改变你内部数据模型的状态。 如果要使你的组件在应用范围内可重用，那么使用scope选项去创建一个独立作用域1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" ng-app=\"myApp\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div ng-controller=\"myController\"&gt; &#123;&#123;books&#125;&#125; &lt;div book-list book-a=\"books\" book-b=\"books\" book-c=\"&#123;&#123;title&#125;&#125;\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;script type=\"text/javascript\" src=\"js/angularjs.js\"&gt;&lt;/script&gt; &lt;script&gt; angular.module('myApp', []).directive(\"bookList\", function() &#123; return &#123; restrict: \"EAMC\", template: '&lt;div&gt;&lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt;&lt;ul&gt;&lt;li ng-repeat=\"book in books\"&gt;&#123;&#123;book.name&#125;&#125;&lt;/li&gt;&lt;/ul&gt; &lt;/div&gt;', // bookList指令中包含一个booAdd指令 replace: true, // scope: false,// scope为独立作用域，当为false，表示直接使用父级作用域，为true，表示创建一个作用域并继承自父作用域；当scope为一个对象时，则表示创建了一个不继承父作用域的继承链的独立作用域(就是可以访问到父作用域，但是无法访问到父作用域之上的作用域) scope: &#123; // &amp;attr表示作用域将父作用域的属性包装成一个函数，从而以函数的形式读写父作用域的属性；一般用在执行父作用域上的某个事件处理函数；若作用域和父作用域的属性名称一要，则可以使用简写形式&amp;,@和=同理 a: \"&amp;bookA\" // 会查找当前指令匹配的元素上的bookA特性，然后取得值books，并将books做为a调用的返回值进行返回； // =attr会将作用域上的属性和父级的作用域上的属性进行双向绑定，任何一方的修改都会修改另外一方 // b: \"=bookB\" // 会查找当前指令匹配的元素上的bookB特性，会将其值和b进行双向绑定 // @attr代表只能读取父级作用域上的值，单向的，并只能读取简单值，引用值不行，因为他最终得到的只会是简单值； // c: \"@bookC\" &#125;, controller: function($scope) &#123; $scope.books = $scope.a(); console.log($scope.a()); // $scope.books = $scope.b; // $scope.b.push(&#123; // name: \"nodeJs\" // &#125;); // console.log($scope.b); // $scope.title = $scope.c; // console.log($scope.c); &#125;, &#125; &#125;).controller('myController', ['$scope', function($scope) &#123; $scope.books = [&#123; name: \"php\" &#125;, &#123; name: \"js\" &#125;, &#123; name: \"java\" &#125;]; $scope.title = \"书籍\"; &#125;]); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; compile 主要用在DOM渲染之前( link之前) 改变DOM结构，并不需要$scope参数。它必须返回一个link函数，因此如果指令中compile和link都写了，则link会被覆盖-&gt;用的比较少123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" ng-app=\"myApp\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div ng-controller=\"myController\"&gt; &lt;div ng-repeat=\"user in users\" my-tag my-tag2&gt;&lt;/div&gt; &lt;/div&gt; &lt;script type=\"text/javascript\" src=\"js/angularjs.js\"&gt;&lt;/script&gt; &lt;script&gt; angular.module('myApp', []).directive('myTag', function() &#123; return &#123; restrict: \"EAMC\", template: '&lt;div&gt;&#123;&#123;user.name&#125;&#125;&lt;/div&gt;', replace: true, compile: function(tElement, tAttrs, transclude) &#123; // 主要用来在实际渲染之前修改DOM结构，compile必须返回一个link函数 // console.log(tElement); //返回匹配的当前类jQuery对象 // console.log(tAttrs); // 返回tElement上的所有attr // console.log(transclude); // 如果指令中transclue为true，则它返回的就是被transclude的原始数据 console.log(\"myTag 编译阶段\"); // 在实际渲染前变更DOM结构 tElement.append(angular.element(\"&lt;h1&gt;test&lt;/h1&gt;\")); return &#123; // 若在compile中直接return一个函数，则返回的是postLink函数 pre: function(scope, iElement, iAttrs, controller) &#123; // preLink是在compile阶段结束后，link阶段之前触发 console.log(\"myTag preLink\"); &#125;, post: function(scope, iElement, iAttrs, controller) &#123; // postLink是指令link后触发 console.log(\"myTag postLink\"); &#125; &#125; &#125;, link: function(scope, iElement, iAttrs, controller) &#123; // 主要在link中进行绑定事件和操纵DOM；一般定义了compile，就不会定义link了;此处的link其实就是compile中postLink console.log(\"因为上面执行了，compile，所以我不会再被执行了\"); &#125; &#125; &#125;).directive('myTag2', function() &#123; return &#123; restrict: \"EAMC\", compile: function(tElement, tAttrs, transclude) &#123; console.log(\"myTag2 编译阶段\"); return &#123; pre: function() &#123; console.log(\"myTag2 preLink\"); &#125;, post: function() &#123; console.log(\"myTag2 postLink\"); &#125; &#125; &#125; &#125; &#125;).controller(\"myController\", [\"$scope\", function($scope) &#123; $scope.users = [&#123; id: 10, name: \"张三\" &#125;, &#123; id: 20, name: \"李四\" &#125;]; &#125;]); &lt;/script&gt;&lt;/body&gt; &lt;/html&gt; link 主要在这里来操作DOM和添加事件 scope-&gt;指令所处的作用域(如果有独立作用域，则为独立作用域，否则值为父级的作用域); element-&gt;指令所匹配的那个元素 attrs-&gt;指令匹配元素的所有特性的集合 controller-&gt;指令需要依赖的controller实例123456789101112131415161718192021222324252627282930angular.module('docsTimeDirective', []).controller('Controller', ['$scope', function($scope) &#123; $scope.format = 'M/d/yy h:mm:ss a';&#125;]).directive('myCurrentTime', ['$interval', 'dateFilter', function($interval, dateFilter) &#123; function link(scope, element, attrs) &#123; var format, timeoutId; function updateTime() &#123; element.text(dateFilter(new Date(), format)); &#125; scope.$watch(attrs.myCurrentTime, function(value) &#123; format = value; updateTime(); &#125;); element.on('$destroy', function() &#123; $interval.cancel(timeoutId); &#125;); // start the UI update process; save the timeoutId for canceling timeoutId = $interval(function() &#123; updateTime(); // update DOM &#125;, 1000); &#125; return &#123; link: link &#125;;&#125;]); replace-&gt;是否替换匹配的元素 若为true则在找到匹配的元素后，会用指令中的template内容替换匹配的内容(包括被匹配的元素)；默认情况下，指令会在找到匹配的元素时，会将匹配元素的内容替换为指令中template的内容； 一般在匹配E时，会选择将其设置为true，因为一般E型指令都是创建新标签，是不符合规范的，所以会选择将其替换 transclude-&gt;主要用来处理指令嵌套 默认情况下，指令会替换匹配元素内部的内容，这样就无法实现指令的相互嵌套使用(原指令的内容会被新指令全部替换掉)； 当设置transclude为true时，则可以保留原先的指令模板以及对应的作用域；注意，在新指令的模板中要用ng-transclude保留老指令的内容； 123456789101112// jsangular.module('docsTransclusionDirective', []).controller('Controller', ['$scope', function($scope) &#123; $scope.name = 'Tobias';&#125;]).directive('myDialog', function() &#123; return &#123; restrict: 'E', transclude: true, scope: &#123;&#125;, templateUrl: 'my-dialog.html' &#125;;&#125;);// my-dialog.html&lt;h1&gt;新内容&lt;/h1&gt;&lt;div class=\"alert\" ng-transclude&gt;&lt;/div&gt; &lt;!-- 指定ng-transclude --&gt; 仅当你要创建一个包裹任意内容的指令的时候使用transclude: true 创建一个包裹任意内容的dialogBox 12345678910111213141516171819202122232425262728293031323334353637// jsangular.module('docsIsoFnBindExample', []).controller('Controller', ['$scope', '$timeout', function($scope, $timeout) &#123; $scope.name = 'Tobias'; $scope.message = ''; $scope.hideDialog = function(message) &#123; $scope.message = message; $scope.dialogIsHidden = true; $timeout(function() &#123; $scope.message = ''; $scope.dialogIsHidden = false; &#125;, 2000); &#125;;&#125;]).directive('myDialog', function() &#123; return &#123; restrict: 'E', transclude: true, scope: &#123; 'close': '&amp;onClose' // &amp;prop 用来绑定一个函数到独立作用域，允许独立作用域调用它，同时保留了函数的原来作用域；当你的指令想要开放一个API去绑定特定的行为，在scope选项中使用&amp;prop。 &#125;, templateUrl: 'my-dialog-close.html' &#125;;&#125;);// html&lt;div ng-controller=\"Controller\"&gt; &#123;&#123;message&#125;&#125; &lt;my-dialog ng-hide=\"dialogIsHidden\" on-close=\"hideDialog(message)\"&gt; Check out the contents, &#123;&#123;name&#125;&#125;! &lt;/my-dialog&gt;&lt;/div&gt;// my-dialog-close.html&lt;div class=\"alert\"&gt; &lt;a href class=\"close\" ng-click=\"close(&#123;message: 'closing for now'&#125;)\"&gt;&amp;times;&lt;/a&gt; &lt;div ng-transclude&gt;&lt;/div&gt; &lt;!-- 保留原先指令内容 --&gt;&lt;/div&gt; 创建添加事件的指令 12345678910111213141516171819202122232425262728293031323334353637angular.module('dragModule', []).directive('myDraggable', ['$document', function($document) &#123; return &#123; link: function(scope, element, attr) &#123; // 在link中为指令匹配的元素element绑定事件 var startX = 0, startY = 0, x = 0, y = 0; element.css(&#123; position: 'relative', border: '1px solid red', backgroundColor: 'lightgrey', cursor: 'pointer' &#125;); element.on('mousedown', function(event) &#123; // Prevent default dragging of selected content event.preventDefault(); startX = event.pageX - x; startY = event.pageY - y; $document.on('mousemove', mousemove); $document.on('mouseup', mouseup); &#125;); function mousemove(event) &#123; y = event.pageY - startY; x = event.pageX - startX; element.css(&#123; top: y + 'px', left: x + 'px' &#125;); &#125; function mouseup() &#123; $document.off('mousemove', mousemove); $document.off('mouseup', mouseup); &#125; &#125; &#125;;&#125;]); controller-&gt;指令中的controller属性可以用来完成指令间的相互通信 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// jsangular.module('docsTabsExample', []).directive('myTabs', function() &#123; return &#123; restrict: 'E', transclude: true, scope: &#123;&#125;, controller: ['$scope', function MyTabsController($scope) &#123; var panes = $scope.panes = []; $scope.select = function(pane) &#123; angular.forEach(panes, function(pane) &#123; pane.selected = false; &#125;); pane.selected = true; &#125;; this.addPane = function(pane) &#123;// 这个方法需要暴露给其他指令用 if (panes.length === 0) &#123; $scope.select(pane); &#125; panes.push(pane); &#125;; &#125;], templateUrl: 'my-tabs.html' &#125;;&#125;).directive('myPane', function() &#123; return &#123; require: '^^myTabs', // 依赖一个myTabs控制器，并在指令的父元素上查找这个控制器 restrict: 'E', transclude: true, scope: &#123; title: '@' // 相当于@title &#125;, link: function(scope, element, attrs, tabsCtrl) &#123; tabsCtrl.addPane(scope); &#125;, templateUrl: 'my-pane.html' &#125;;&#125;);// index.html&lt;my-tabs&gt; &lt;my-pane title=\"Hello\"&gt; &lt;p&gt;Lorem ipsum dolor sit amet&lt;/p&gt; &lt;/my-pane&gt; &lt;my-pane title=\"World\"&gt; &lt;em&gt;Mauris elementum elementum enim at suscipit.&lt;/em&gt; &lt;p&gt;&lt;a href ng-click=\"i = i + 1\"&gt;counter: &#123;&#123;i || 0&#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;/my-pane&gt;&lt;/my-tabs&gt;// tabs&lt;div class=\"tabbable\"&gt; &lt;ul class=\"nav nav-tabs\"&gt; &lt;li ng-repeat=\"pane in panes\" ng-class=\"&#123;active:pane.selected&#125;\"&gt; &lt;a href=\"\" ng-click=\"select(pane)\"&gt;&#123;&#123;pane.title&#125;&#125;&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;div class=\"tab-content\" ng-transclude&gt;&lt;/div&gt;&lt;/div&gt;// panel&lt;div class=\"tab-pane\" ng-show=\"selected\"&gt; &lt;h4&gt;&#123;&#123;title&#125;&#125;&lt;/h4&gt; &lt;div ng-transclude&gt;&lt;/div&gt;&lt;/div&gt; 当你想暴露一个API给其它的指令调用那就用controller,否则用link。 controllerAs-&gt;给指令中的controller起个别名，并可做controller中的第四个参数传入 priority-&gt;设置指令执行的优先级顺序(权重)；多个指令时，ng必须知道哪个先执行；默认ng-repeat优先级很高，为1000；-&gt;不常用 terminal-&gt;是否设置当前指令的权重priority 为结束界限；若为true，则节点上小于当前指令权重priority的指令不会被执行，相同权重的会执行 require-&gt;可以将其他指令传给自己，有以下值 directiveName-&gt;默认值，会从同一个元素上查找 ^directiveName-&gt;会在父级上查找 ?directiveName-&gt;表示指令是可选的，找不到也不会抛出异常 Animations 可参考https://css-tricks.com/animations-the-angular-way/ 无需引入任何模块，直接利用切换class配合css的过渡，来实现过渡动画-&gt;无法做到全兼容；-&gt;https://codepen.io/bdsimmons/pen/NqYjaV angualr中内置了$animate服务，可以提供简单的动画操作，enter、leave…-&gt;核心方法，ngAnimate模块也依赖这个核心服务 更强大的动画-&gt;引入ngAnimate模块；angualr没有直接包含动画模块(ngAnimate)，需要在引入angular.js后引入angular-animate.js 重点：ngAnimate动画的核心都是基于css，通过变换元素的class类配合过渡和animation进而实现动画，js动画除外 如何使用ngAnimate模块 整个app没有模块，则可以直接指定ng-app=”ngAnimate”来从ngAnimate模块启动app，也能有动画效果；-&gt;不推荐-&gt;http://www.runoob.com/try/try.php?filename=try_ng_animation 当做模块依赖来使用-&gt;var app=angular.module(“myApp”,[“ngAnimate”]); 当引入ngAnimate模块后，就会自动在一些指令执行的特殊时机，为元素添加上对应的class类，可以利用这个配合css实现动画 css过渡动画-&gt;需要设置动画的起点、终点的动画属性值；例如在.ng-enter上设置过渡动画初始值，在.ng-enter-active上设置过渡动画终点值-&gt;https://codepen.io/bdsimmons/pen/OPmNxXs css3Animation-&gt;css3Animtions，无需在2个class上设置动画，只需要在一个class上设置动画，并给定动画时间即可，所以如上面的只需要在.ng-enter上设置一个animation动画即可，无需在ng-enter-active在设置动画-&gt;https://codepen.io/anon/pen/NjJLMZ JS动画-&gt;当引入ngAnimate模块后 就自动在app上添加了animation方法，app.animation()；可以通过animation方法，实现动画-&gt;https://codepen.io/bdsimmons/pen/YXLZEw Module 基本用法 创建模块-&gt;用angular.module(“moduleName”,[“依赖的模块”]); 获取已有模块-&gt;用angular.module(“moduleName”);注意获取时，没有后面的依赖数组 让模块运作起来 声明一个module,然后在ng-app中引用它，即可让app从module中开始运行 模块划分 服务模块 指令模块 过滤器模块 一个应用的模块，依赖于上述的三个模块，而且包含应用的初始化及启动代码12345678910111213141516171819202122232425262728293031323334angular.module('xmpl.service', []) // 服务 .value('greeter', &#123; salutation: 'Hello', localize: function(localization) &#123; this.salutation = localization.salutation; &#125;, greet: function(name) &#123; return this.salutation + ' ' + name + '!'; &#125; &#125;) .value('user', &#123; load: function(name) &#123; this.name = name; &#125; &#125;);angular.module('xmpl.directive', []); // directiveangular.module('xmpl.filter', []);// filterangular.module('xmpl', ['xmpl.service', 'xmpl.directive', 'xmpl.filter']) // xmpl依赖service、directive、filter .run(function(greeter, user) &#123; // 初始化 // This is effectively part of the main method initialization code greeter.localize(&#123; salutation: 'Bonjour' &#125;); user.load('World'); &#125;) .controller('XmplController', function($scope, greeter, user)&#123; $scope.greeting = greeter.greet(user.name); &#125;); 模块是配置代码块和运行代码块的集合 配置代码块config-&gt;在 provider 注册和配置阶段执行（注：provider 是 ng 服务的一种）。只有 provider 和 constant 可以被注入配置代码块。这是为了防止服务在完全配置好之前被意外地初始化。-&gt;config为配置 执行代码块run-&gt;在 injector 被创建后执行，被用来启动整个应用。只有服务的实例对象以及 constant 可以被注入到执行代码块。这是为了防止在应用执行期间系统的更进一步的配置。-&gt;run为初始化 123456789angular.module('myModule', []). config(function(injectables) &#123; // provider型注入器 // 这是配置(config)代码块的范例，你可以有任意多个配置代码块 // 配置块中你只能注入Provider类（注意：不是由Provider类生成的实例）以及`constant` &#125;). run(function(injectables) &#123; // instance型注入器 // 这是运行(run)代码块的范例，你可以有任意个运行代码块 // 运行块中你只能注入Provider实例（注意：不是Provider类） &#125;); 配置代码块的快捷方法 123456789101112131415161718192021222324angular.module('myModule', []).value('a', 123).factory('a', function() &#123; return 123; &#125;).directive('directiveName', ...).filter('filterName', ...);// 等同于angular.module('myModule', []).config(function($provide, $compileProvider, $filterProvider) &#123; $provide.value('a', 123); $provide.factory('a', function() &#123; return 123; &#125;); $compileProvider.directive('directiveName', ...); $filterProvider.register('filterName', ...);&#125;);//.config等同于设置module函数的第三个参数angular.module(\"myModule\",[],[\"$provide\",\"$compileProvider\",\"$filterProvier\",function(provide,compileProvier,filterProvider)&#123; provide.value('a', 123); provide.factory('a', function() &#123; return 123; &#125;); compileProvider.directive('directiveName', ...); filterProvider.register('filterName', ...); &#125;]); 配置语句的执行顺序就是根据它们注册的顺序而定的。唯一的例外是 constant 的定义，它会被调整到所有配置块的最前面执行。 执行代码块 执行代码块是 ng 中最接近 main 函数的一个东西。执行代码块是应用启动时运行的代码。它在所有的服务被配置好以及 注入器(injector)被创建好之后执行。通常，执行代码块包含的代码都很难进行单元测试，正因为如此，它通常应该被丢在一个单独的模块中，这样我们可以在单元测试时忽略它。 模块依赖 A依赖B，则A的配置阶段要在B的配置阶段完成后进行，执行阶段同理，A的执行要在B的执行结束后。 注意每个模块只能被加载一次，即使有多个别的模块依赖它。 IE兼容性 1.3及以上不再支持IE8-&gt;所以如果需要支持IE8，请使用ng1.2.x-&gt;1.2的最新版本为1.2.32 IE7及以下不支持JSON.stringify-&gt;使用json2.js 123&lt;!--[if lte IE 7]&gt; &lt;script src=\"/path/to/json2.js\"&gt;&lt;/script&gt;&lt;![endif]--&gt; 在根元素上添加id=”ng-app”并结合ng-app=”xxModule”来启动app 1234&lt;!doctype html&gt;&lt;html xmlns:ng=\"http://angularjs.org\" id=\"ng-app\" ng-app=\"optionalModuleName\"&gt; ...&lt;/html&gt; 不要使用自定义节点 如，用attribute方式代替如ng-view 如果你由于语义或者第三方的Angular组件需要使用tag的方式的话,那么你必须按照如下步骤 make IE happy 1234567891011121314151617181920&lt;!doctype html&gt;&lt;html xmlns:ng=\"http://angularjs.org\" id=\"ng-app\" ng-app=\"optionalModuleName\"&gt;&lt;head&gt;&lt;!--[if lte IE 8]&gt; &lt;script&gt; document.createElement('ng-include'); document.createElement('ng-pluralize'); document.createElement('ng-view'); // Optionally these for CSS document.createElement('ng:include'); document.createElement('ng:pluralize'); document.createElement('ng:view'); &lt;/script&gt;&lt;![endif]--&gt;&lt;/head&gt;&lt;body&gt;...&lt;/body&gt;&lt;/html&gt; 重要的部分: xmlns:ng- 命名空间 - 你需要为每一个将使用的自定义tag注册一个命名空间(译者注:IE作为严格xml模式解析). document.createElement(yourTagName) - 自定义节点创建 - 由于这只是老版本的IE issues，所以你需要按条件加载这些脚本(IE低版本特有的条件注释)。对于每一个需要使用的没有注册命名空间以及非HTML定义的tag你需要利用它来预申明来make IE happy。 IE在处理关于非标准HTML tag 的问题主要由两类，每种类型又其自己的修复方式. If the tag name starts with my: prefix then it is considered an XML namespace and must have corresponding namespace declaration on 以my:为前缀的tag 考虑到严格的XML命名空间，你必须有相应的命名空间申明,如。 If the tag has no : but it is not a standard HTML tag, then it must be pre-created using document.createElement(‘my-tag’) 没有:的非标准HTML tag, 你需要使用document.createElement(&#39;my-tag&#39;)来预申明改节点(译者注:ie-shv)。 If you are planning on styling the custom tag with CSS selectors, then it must be pre-created using document.createElement(&#39;my-tag&#39;) regardless of XML namespace. 如果你希望采用CSS选择器的方式，那么你需要使用document.createElement(&#39;my-tag&#39;)预申明，忽略XML命名空间。 使用ng-style代替style=;后者在&lt;IE11的版本上无法运行 Angualr会在执行的某些时间点为标签添加上一些标识用的class类 ng-scope样式类会在创建了新作用域(Scope)的HTML元素上生成 ng-binding样式类会在ng-bind 或 绑定了任何数据的元素上生成 ng-invalid、ng-valid样式类会在进行了验证操作的所有input组件元素上生成 ng-pristine、ng-dirty angular的input指令给所有新的、还没有与用户交互的input元素附加上ng-pristine类，当用户有任何输入时，则附加上 ng-dirty. 国际化I18n和本地化L10n 引入特定的语言包 12345678&lt;html ng-app&gt;&lt;head&gt;…. &lt;script src=\"angular.js\"&gt;&lt;/script&gt; &lt;script src=\"i18n/angular-locale_zh-cn.js\"&gt;&lt;/script&gt;….&lt;/head&gt;&lt;/html&gt; 启动即bootstrap(这里bootstrap并非指ui库，bootstrap本身就有启动的意思) 自动启动 在angular要控制的范围最外层元素上添加ng-app指令 若未指定ng-app的具体值，会从默认模块开始启动；若指定了则从指定模块上启动 若需支持IE7，则还上在ng-app除添加id=”ng-app” 若需支持老式ng:风格的指令，则还需要在html上添加xml命名空间 1&lt;html xmlns:ng=\"http://angularjs.org\"&gt; 手动启动 使用angular.bootstrap 1234567891011121314151617181920&lt;!doctype html&gt;&lt;html&gt;&lt;body&gt; &lt;div ng-controller=\"MyController\"&gt; Hello &#123;&#123;greetMe&#125;&#125;! &lt;/div&gt; &lt;script src=\"http://code.angularjs.org/snapshot/angular.js\"&gt;&lt;/script&gt; &lt;script&gt; angular.module('myApp', []) .controller('MyController', ['$scope', function ($scope) &#123; $scope.greetMe = 'World'; &#125;]); angular.element(document).ready(function() &#123; angular.bootstrap(document, ['myApp']); // 手动启动 &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; bootstrap要在需要的module创建或加载完成后，才能调用 当手动启动app时，就不应当在用ng-app指令了 安全性 不要混用前台和后台的模板 不要使用用户的输入动态生成模板 Do not run user input through $scope.$eval 考虑使用ngCSP模块 Providers injector可以创建两种对象 专有对象-&gt;angular框架提供的，如controller、filter、directives等 服务-&gt;服务的API由开发人员自己制定-&gt;说明服务可以自己定制 injector需要知道如何创建服务，它需要一个”图纸” 图纸provider、factory、service、value、constant 最底层的图纸是provider，其余四种图纸都是基于provider的语法糖（在provider上又封装了一层） value图纸 用来创建可在运行阶段使用的常量 1234567891011var myApp = angular.module('myApp', []);myApp.value('clientId', 'a12345654321x');myApp.controller('DemoController', ['clientId', function DemoController(clientId) &#123; this.clientId = clientId;&#125;]);&lt;html ng-app=\"myApp\"&gt; &lt;body ng-controller=\"DemoController as demo\"&gt; Client ID: &#123;&#123;demo.clientId&#125;&#125;&lt;/body&gt;&lt;/html&gt; factory图纸 可以创建任何类型的服务 factory图纸相较value图纸增加了下面功能 可以有依赖 服务初始化 延迟/惰性初始化 factory图纸通过一个拥有0～n个参数(参数表示该服务对其他服务的依赖)的函数来创建服务，而函数返回值就是factory图纸创建的服务实例。 123myApp.factory('clientId', function clientIdFactory() &#123; return 'a12345654321x';// 返回的是服务的实例，不过这里clientId是一个常量，所以还是用value靠谱&#125;); 更适合用factory的例子，计算token 12345678910111213myApp.factory('apiToken', ['clientId', function apiTokenFactory(clientId) &#123;//将工厂方法命名为\"Factory\"是最佳实践（比如，apiTokenFactory）.虽然这种命名方式不是强制性的，但是它有助于浏览代码仓库或者在调试器里跟踪调用堆栈。 var encrypt = function(data1, data2) &#123; // NSA-proof加密算法： return (data1 + ':' + data2).toUpperCase(); &#125;; var secret = window.localStorage.getItem('myApp.secret'); var apiToken = encrypt(clientId, secret); return apiToken;&#125;]);``` service图纸 必须返回引用类型 自定义类型，并携带token 1234567891011function UnicornLauncher(apiToken) &#123; this.launchedCount = 0; this.launch() &#123; // 带上apiToken来发起远程调用 ... this.launchedCount++; &#125;&#125;myApp.factory('unicornLauncher', [\"apiToken\", function(apiToken) &#123;// 使用factory图纸来实现 return new UnicornLauncher(apiToken);&#125;]);myApp.service('unicornLauncher', [\"apiToken\", UnicornLauncher]);// 使用services语法更加简介，在内部还是会像factory一样，new 一下 provider图纸 注意必须实现$get方法 其它图纸的底层都是通过provider实现的，如factory 123function factory(name, factoryFn) &#123; return provider(name, &#123; $get: factoryFn &#125;); &#125; 当你需要为在应用运行前就必须设置好的全局配置项提供API时，你才需要用到provider图纸 假设我们的unicornLauncher服务是如此棒，以至于有好多应用都用到它。默认情况下，发射器将独角兽发射到太空中不需要任何保护屏障。但是在某些星球上，由于大气层非常厚，我们在将独角兽送去做星际旅行前必须将它们包裹在铝箔里，不然它们在穿越大气层时就被烧毁了。在一些应用里，需要设置发射器在每次发射时都使用铝箔屏蔽，如果我们能按需配置这一点那就太棒了。我们可以像下面这样让它变得可配置 12345678910111213myApp.provider('unicornLauncher', function UnicornLauncherProvider() &#123; var useTinfoilShielding = false; this.useTinfoilShielding = function(value) &#123; useTinfoilShielding = !!value; &#125;; this.$get = [\"apiToken\", function unicornLauncherFactory(apiToken) &#123; // 这里我们假设UnicornLauncher的构造函数也被改造得支持useTinfoilShielding参数了 return new UnicornLauncher(apiToken, useTinfoilShielding); &#125;];&#125;);myApp.config([\"unicornLauncherProvider\", function(unicornLauncherProvider) &#123; unicornLauncherProvider.useTinfoilShielding(true);&#125;]); constant图纸 用来创建可以在配置阶段使用的图纸 在angular开始创建服务之前，angular会配置和实例化所有provider，此时服务还不能用，因为他们还没有被创建(只是provider被实例化了，由provider创建并返回的服务此时还没有被创建)；一旦配置阶段结束，与provider的交互就被禁止了，而创建服务的过程开始；-&gt;所以在配置阶段，没有服务可用，这就导致了一些没有依赖用value写的常量也无法被使用-&gt;使用constant 假设在配置阶段提供了发射独角兽的星球名称，那么我们的unicornLauncher服务就能通过这个名字来标识一个独角兽。星球名是各个应用特有的，并且在应用运行时也会被各个控制器使用。我们可以像下面的代码那样把星球名定义为一个常量 123456myApp.constant('planetName', 'Greasy Giant');myApp.config(['unicornLauncherProvider', 'planetName', function(unicornLauncherProvider, planetName) &#123;// 在配置阶段，使用constant，因为value无法使用 unicornLauncherProvider.useTinfoilShielding(true); unicornLauncherProvider.stampText(planetName);&#125;]);``` value图纸也可以在控制器、模板、指令中使用 1234567891011myApp.controller('DemoController', [\"clientId\", \"planetName\", function DemoController(clientId, planetName) &#123; this.clientId = clientId; this.planetName = planetName;&#125;]);&lt;html ng-app=\"myApp\"&gt; &lt;body ng-controller=\"DemoController as demo\"&gt; Client ID: &#123;&#123;demo.clientId&#125;&#125; &lt;br&gt; Planet Name: &#123;&#123;demo.planetName&#125;&#125; &lt;/body&gt;&lt;/html&gt; 总结 injector用五种图纸来创建服务和专有对象 provider图纸是最底层的方法，其他的图纸都是基于其之上的语法糖 provider是最复杂的图纸类型，除非你正在构建需要全局配置的可复用代码，否则不要使用它 除了控制器，其他所有专用对象都是通过factory图纸来定义的(factory定义的，都是单例对象，而controller不是单例的) factory和service是最常用的图纸。它们之间的唯一区别就是service图纸存在一个new过程，所以最好返回一个构造函数，而factory可以创建任意类型 constant用在配置时，value用在运行时 12* 有直接使用new操作符预先初始化的开销。** 在配置阶段，服务对象是不能被访问的，但Provider实例是可以被访问的。（参见我们上面列举的unicornLauncherProvider例子）。 HTML Compiler HTML compiler 让开发者可以教浏览器一些新的语法技能 Compiler是 Angular 提供的一项服务，用来遍历DOM节点，查找特定的属性。编译过程分为两个阶段： 编译compile：遍历DOM节点，收集所有的指令，返回一个连接函数（link func） 连接link：将上一步收集到的每个指令与其所在的作用域（scope）连接生成一个实时视图。任何作用域中的模型改变都会实时在视图中反映出来，同时任何用户与视图的交互则会映射到作用域的模型中。这样，作用域中的数据模型就成了唯一的数据源。 指令directive 在编译过程中，遇到特定的HTML结构（也就是指令）时，指令所声明的行为操作会被触发 指令其实就是在编译器遍历DOM时碰到就需要执行的函数。 指令是如何被编译的 知道 Angular 的编译是在DOM节点上发生而非字符串上是很重要的。如果你自己手动调用 $compile 时，如果你传给它一个字符串，显然是要报错的。所以，在你传值给 $compile 之前，用 angular.element 将字符串转化为DOM。 编译流程 $compile 遍历DOM节点，匹配指令。 如果编译器发现某个元素匹配一个指令，那么这个指令就被添加到指令列表中（该列表与DOM元素对应）。一个元素可能匹配到多个指令（译注：也就是一个元素里面可能有多个指令）。 当所有指令都匹配到相应的元素时，编译器按照指令的 priority 属性来排列指令的编译顺序。 然后依次执行每个指令的 compile 函数。每个 compile 函数有一次更改该指令所对应的DOM模板的机会。然后，每个 compile 函数返回一个 link 函数。这些函数构成一个“合并的”连接函数，它会调用每个指令返回的 link 函数。 之后，$compile 调用第二步返回的连接函数，将模板和对应的作用域连接。而这又会依次调用连接函数中包含的每个指令对应的 link 函数，进而在各个DOM元素上注册监听器以及在相应的 scope 中设置对应的 $watchs。 用代码表示大概是下面流程 1234567891011121314151617181920212223var $compile = ...; // 已经存在的编译器var scope = ...;// 作用域var parent = ...; // DOM element where the compiled template can be appended，要被追加内容的DOM元素var html = '&lt;div ng-bind=\"exp\"&gt;&lt;/div&gt;';// 指令模板字符串// Step 1: parse HTML into DOM element，将html字符串解析为DOM，因为如果传给$compile字符串会报错var template = angular.element(html);// Step 2: compile the template，遍历整个template的DOM，找到所有指令，并按priority排序，并依次执行每个指令里的compile函数，每个compile函数会返回一个link函数，以供第三部用var linkFn = $compile(template);// Step 3: link the compiled template with the scope.，$compile会依次调用第二步返回的link函数，将模板和对应的作用域连接，会依次调用连接函数中包含的每个指令对应的 link 函数，进而在各个DOM元素上注册监听器以及在相应的 scope 中设置对应的 $watchesvar element = linkFn(scope);// Step 4: Append to DOM (optional)，可选的将一切就绪的dom追加到html中parent.appendChild(element); 总结：compile(找指令、排序、依次执行指令中compile函数并返回link函数)-&gt;执行每个指令中的link(DOM和作用域进行连接，设置事件监听并添加$watch) ngModel模块 当需要对数据进行深层处理时，可以用ngModel模块-&gt;一般是指令，这个ngModel对应的就是指令匹配元素上的ng-model 主要参考http://docs.ngnice.com/guidehttps://code.angularjs.org/1.2.32/docs/guide小猫杯的angular视频教程大漠穷秋的angular实战","tags":[{"name":"MVC","slug":"MVC","permalink":"http://yoursite.com/tags/MVC/"},{"name":"framework","slug":"framework","permalink":"http://yoursite.com/tags/framework/"},{"name":"Angular","slug":"Angular","permalink":"http://yoursite.com/tags/Angular/"}]},{"title":"Graphviz","date":"2017-03-24T08:55:14.000Z","path":"2017/03/24/Graphviz/","text":"Graphviz的安装以及基本使用介绍Graphviz可通过代码的方式生成图形 安装win下，可在官网http://http://www.graphviz.org/Download_windows.php下载，安装好后，手动将bin文件夹添加到环境变量即可。cmd 下键入dot -version,能出现Graphviz相关信息，则表示安装成功 生成图片12dot 源文件 -T 图片格式 -o 输出文件dot input.dot -T png -o output.png 可利用sublimeText的编译系统，实现图片实时预览 具体可参考这篇文章https://zhuanlan.zhihu.com/p/22820399 新建*.dot文件，然后编写相应代码，再编译就能生成图 基本语法123图类型 图名&#123; //其他&#125; 无向图1234567// 无向图用--表示节点之间的关系graph graphname &#123; a -- b--e; b -- c; b -- d; d -- a;&#125; 有向图123456// 有向图用a-&gt;b表示从a节点指向b节点digraph graphname&#123; a-&gt;b b-&gt;c a-&gt;c&#125; 定义一类节点123456digraph graphname&#123; T [label=&quot;Teacher&quot;,fontcolor=&quot;red&quot;] //定义节点T，并给予属性 P [label=&quot;Pupil&quot;] //定义节点P，并给予属性 T-&gt;P [label=&quot;Instructions&quot;, fontcolor=darkgreen] //定义边T-&gt;P，并给予属性 &#125; 设置属性(样式)12345678910111213141516171819202122232425262728293031323334353637graph G &#123; // 设置当前图和子图的属性 fontname=&quot;Microsoft JhengHei&quot;; fontsize=20; label=&quot;图&quot;; fontcolor=blue; //设置当前大括号范围内所有节点和边的属性，包含子图里面节点和边，类css中标签选择器 node[fontname=&quot;Microsoft JhengHei&quot;,fontsize=16]; edge[fontname=&quot;Microsoft JhengHei&quot;,fontsize=16]; // 可针对某一类节点设置属性，类css中class选择器 &quot;黑海&quot;[fontcolor=&quot;pink&quot;,style =&quot;filled&quot;,fillcolor = &quot;black&quot;]; &quot;黑海&quot; -- &quot;亚速海&quot;; &quot;黑海&quot; -- &quot;博斯普鲁斯海峡&quot;; &quot;达达尼尔海峡&quot; -- &quot;爱琴海&quot;; // 子图，用subgraph声明，并图名字前缀必须是cluster_否则识别失败；子图和父图的类型必须一致，父图是无向则子图也必须是无向，不能是有向 subgraph cluster_T &#123; // 设置子图的label属性，它的颜色继承父图的fontcolor=blue label=&quot;黑海海峡&quot;; &quot;达达尼尔海峡&quot; -- &quot;马尔马拉海&quot; -- &quot;博斯普鲁斯海峡&quot;; &#125; subgraph cluster_M &#123; label=&quot;黑海海峡&quot;; // 一对多，空格分隔 &quot;中部地中海&quot; -- &#123; &quot;爱琴海&quot; &quot;爱奥尼亚海&quot; &quot;西西里海峡&quot; &#125;; // 一对多，并设置每对都有一个label标签说明，并把字体颜色设置为red，线条颜色设置为yellow &quot;西部地中海&quot; -- &#123; &quot;西西里海峡&quot; &quot;第勒尼安海&quot; &quot;利古里亚海&quot; &quot;伊比利海&quot; &quot;阿尔沃兰海&quot; &#125;[label=&quot;标签说明&quot;,fontcolor=&quot;red&quot;,color=&quot;yellow&quot;]; &quot;爱奥尼亚海&quot; -- &quot;亚得里亚海&quot;; &quot;阿尔沃兰海&quot; -- &quot;直布罗陀海峡&quot;; &#125;&#125; 最终生成的 中文乱码保证.dot文件是以UTF-8编码通过设置fontname为中文字体来解决 参考链接 https://zhuanlan.zhihu.com/p/21993254https://zhuanlan.zhihu.com/p/22820399http://blog.csdn.net/xiajian2010/article/details/23748557http://www.tuicool.com/articles/vy2Ajyu","tags":[{"name":"Graphviz","slug":"Graphviz","permalink":"http://yoursite.com/tags/Graphviz/"},{"name":"绘图","slug":"绘图","permalink":"http://yoursite.com/tags/绘图/"}]},{"title":"mock-js","date":"2017-03-24T02:52:19.000Z","path":"2017/03/24/mock-js/","text":"Mock.js的基本用法如何使用123456789101112131415161718192021&lt;script type=\"text/javascript\" src=\"js/jquery-2.2.4.min.js\"&gt;&lt;/script&gt;&lt;!-- 引入Mock.js --&gt;&lt;script type=\"text/javascript\" src=\"js/mock-min.js\"&gt;&lt;/script&gt;&lt;script&gt; // 根据数据模板生成模拟数据。 Mock.mock('http://test.cn', &#123; \"userName\": \"@cname\", \"sex|1\": [\"男\", \"女\"], \"avator\": Mock.Random.image('100x100', '#894FC4', '#FFF', 'png', '头像') &#125;); // 模拟请求 $.ajax(&#123; url: 'http://test.cn', dataType: 'json' &#125;).done(function(data, status, xhr) &#123; // 请求成功，do something console.log(data); &#125;);&lt;/script&gt; 语法规范 数据模板定义规范（Data Template Definition，DTD） 数据占位符定义规范（Data Placeholder Definition，DPD） 数据模板定义语法1234&apos;name|rule&apos;:valuename:属性名rule:生成规则vale:属性值 注意 属性名(name)和生成规则(value)之间要用|分隔 生成规则(rule)不是必须的 最终生成值的类型和初始值由属性值(value)确定 属性值(value)中可以包含数据占位符(@占位符) 生成规则有7种格式 ‘name|min-max’: value ‘name|count’: value ‘name|min-max.dmin-dmax’: value ‘name|min-max.dcount’: value ‘name|count.dmin-dmax’: value ‘name|count.dcount’: value ‘name|+step’: value 生成规则的具体含义还要配合属性值(value)的类型来确定 规则 属性值(value)是String ‘name |min-max’:stringValue 通过重复stringValue，生成一个字符串。重复次数在[min,max]区间取值(次数大于等于min，小于等于max) ‘name |count’:stringValue 通过重复stringValue字符串count次，生成一个字符串。 属性值(value)是Number ‘name|+1’: numberValue 属性值自动加 1，初始值为numberValue。 ‘name|min-max’:numberValue 生成一个[min,max]之间的整数，此时属性值numberValue只是用来确定类型。 ‘name|min-max.dmin-dmax’: numberValue 生成一个整数部分在[min,max]间取值,小数保留的位数在[dmin,dmax]间取值的浮点数。同理此时属性值(value)也只是用来确定最终返回的数据的类型。 属性值是Boolean ‘name|1’: booleanValue 随机生成一个布尔值，值为 booleanValue 的概率是 1/2，值为 !booleanValue 的概率同样是 1/2。 ‘name|min-max’: booleanValue 随机生成一个布尔值，值为 booleanValue 的概率是 min / (min + max)，值为 !booleanValue 的概率是 max / (min + max)。此处属性值必须是Boolean类型，若为Number,则意义不同，见2 “test|1-2”:true 生成一个布尔值，为true的概率为1/3，为false概率为2/3 属性值是对象 Object ‘name|count’: object 返回的对象只包含从属性值object中随机选取的count个属性。 ‘name|min-max’: object 返回的对象只包含从属性值object中随机选取的min到max个属性。 属性值是数组 Array ‘name|1’: array 从属性值 array 中随机选取 1 个元素，作为最终值。 ‘name|+1’: array 从属性值 array 中顺序选取 1 个元素，作为最终值。 ‘name|min-max’: array 通过重复属性值array的值生成一个新数组，重复次数大于等于 min，小于等于 max。 ‘name|count’: array 通过重复属性值array的值生成一个新数组，重复次数为 count。 属性值是函数 Function ‘name’: function 执行函数 function，取其返回值作为最终的属性值，函数的上下文为属性 ‘name’ 所在的对象。 属性值是正则表达式 RegExp ‘name’: regexp 根据正则表达式 regexp 反向生成可以匹配它的字符串。用于生成自定义格式的字符串。 数据占位符定义语法Mock中的占位符和Sass中的placeholder很像。可以直接用在数据模板的属性值中。Mock中提供了很多预先定义的占位符，当然你也可以自定义占位符。 基本调用格式1234@占位符@占位符(参数 [, 参数])或者Mock.Random.占位符(参数 [, 参数]) 注意： 用@来标识其后的字符串是占位符。 占位符引用的是Mock.Random中的方法。 通过 Mock.Random.extend() 来扩展自定义占位符。 占位符也可以引用数据模板中的属性。 占位符会优先引用数据模板中的属性。 占位符支持相对路径和绝对路径。 预定义的占位符 Basic 提供一些基础占位符，如布尔值、整数、自然数、字符串等 Date 提供日期相关的占位符 Image 提供图片相关的占位符 Color 提供色值相关的占位符 Text 提供文本相关的占位符 Name 提供英文、中文名称相关的占位符 Web 提供了url、IP、protocol等相关的占位符 Address 提供省份、城市等地域相关信息的占位符 Helper 提供一些常用工具如字母转换大小写等相关占位符 Miscellaneous 提供了guid、身份证、自增等相关占位符号 自定义扩展符1234567891011121314Mock.Random.extend(&#123; constellation: function(date) &#123; var constellations = ['白羊座', '金牛座', '双子座', '巨蟹座', '狮子座', '处女座', '天秤座', '天蝎座', '射手座', '摩羯座', '水瓶座', '双鱼座'] return this.pick(constellations) &#125;&#125;)Mock.Random.constellation()// =&gt; \"水瓶座\"Mock.mock('@CONSTELLATION')// =&gt; \"天蝎座\"Mock.mock(&#123; constellation: '@CONSTELLATION'&#125;)// =&gt; &#123; constellation: \"射手座\" &#125; 更多API请参考 https://github.com/nuysoft/Mock/wiki‘ 更多实例请参考 http://mockjs.com/examples.html 可以一边看API、一边看实例，很容易就能上手","tags":[{"name":"mock","slug":"mock","permalink":"http://yoursite.com/tags/mock/"},{"name":"模拟数据","slug":"模拟数据","permalink":"http://yoursite.com/tags/模拟数据/"}]},{"title":"Markdown-Learning","date":"2017-03-23T03:21:16.000Z","path":"2017/03/23/Markdown-Learning/","text":"Markdown-Github Flavored Markdown常用操作Markdown拥有多种语法风格 标准风格-不支持表格 扩展风格-支持表格 github风格-Github Flavored Markdown它在标准风格上做了很多改进，如对表格的支持，针对不同编程语言实现代码高亮等 因为经常使用github，所以选择了Github Flavored Markdown风格。 Hexo搭建的博客也是使用github风格来解析markdown的。 win上支持Github Flavored Markdown风格的编辑器我常用的有:markdown pad2和typora。typora最让我心动的是支持快捷键创建表格，非常的方便。 标题12345# 一级标题## 二级标题，二级标题自带下划线### 三级标题...###### 六级标题 粗体斜体1234**两个星号为粗体***一个星号为斜体***粗中带 _斜_***内部换行用&lt;br&gt;,第二行* 引用1&gt; 这样引用 无序列表12345- 无序 - 我前面有2个空格，我能缩进 - 无序- 无序- 无序 有序列表12341. 第一行 1. 我前面有2个空格2. 第二行3. 第三行 任务列表123- [x] 我代表选中- [ ] 我没选中- [ ] 我没选中 图片与链接12[链接名](链接地址)![图片alt](图片地址) 代码段1使用`包裹的区域会形成代码段,区段内的 &amp;、&lt; 和 &gt; 都会被自动的转换成HTML实体，一般用在行内 代码块1使用三个`会产生格式化好的代码块,而 &amp;、&lt; 和 &gt; 也一样会自动转成HTML实体，一般用于一大段代码 代码块高亮123function show()&#123; console.log(\"我是带语法高亮的代码块，在三个`后添加上语言类型即可高亮\");&#125; 表格12345| Tables | Are | Cool || ------------- |:-------------:| -----:|| col 3 is | right-aligned | $1600 || col 2 is | centered | $12 || zebra stripes | are neat | $1 | Markdown中表格生成较为麻烦，建议使用编辑器快速生成,如typora中使用ctrl+t 分割线1***或--- 会产生分割线 还有很多东西因为没用到，所以不做介绍。更多的可以参考这 https://help.github.com/categories/writing-on-github/","tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://yoursite.com/tags/Markdown/"}]},{"title":"Handlebars-guide","date":"2017-03-17T10:48:09.000Z","path":"2017/03/17/Handlebars-guide/","text":"#HandleBars备忘 表达式{{xxx}} {{{xxxx}}}因为双大括号默认会进行HTML转义,将&lt;转换为&amp;lt;,通过三括号可以避免 Helper默认Helper{{#if a}}如果a为真执行这个{{/if}} {{#else}}否则执行这个{{/else}} {{#unless a}}当a为假的时候执行这个{{/unless}} {{#each obj}}遍历obj的每个属性{{/each}} #each内可以用{{@index}}获取当前遍历的索引值，用{{@key}}获取当前属性的属性名，用{{this}}可以获当前属性的值 如何获取父对象 可以通过{{../父对象某属性}}来获取父对象的某个属性，{{@../index}}获取父对象当前的所引值 {{#with obj}}xxx{{/with}}类似js中with，可改变作作用域，在each中也可通过#with 父对象名 来访问父对象 {{lookup xxx}}一般用来按照索引来找兄弟变量对应的值{{lookup ../父对象某属性 @index}}，查找父对象在当前索引下值 自定义Helper行级Helper语法{{helperName [普通值参数][hash值参数]}} {{customHelper \"My Text\" class=\"my-class\" visible=true counter=4}} Handlebars.registerHelper(&apos;customHelper&apos;, function() { console.log(arguments[0]);//==&gt;&quot;My Text&quot; console.log(arguments[1].hash);//==&gt;{class:&quot;my-class&quot;,visible:true,conter:4} }); 块级Helper语法{{#helperName context [普通值参数][hash值参数]}}xxxxxxxxx{{/helperName}} {{#customHelper nav \"normalValue\" class=\"my-class\" visible=true counter=4}} {{if name}} aaaaaa {{else}} bbbbbbb {{/if}} {{/customHelper}} Handlebars.registerHelper(&apos;customHelper&apos;, function(context,options) { console.log(arguments[0]);//==&gt;context console.log(arguments[1]);//==&gt;normalValue console.log(arguments[2]);//==&gt;options //说明在registerHelper内部,第二个参数匿名函数,只会存在3个实参，第一个为当前使用的上下文，第二个如果有则为一个普通值参数，另外一个就是封装了函数相关信息的options对象，它有hash(封装好一个或多个键值对参数)、fn(传入一个上下文，并在此上下文中执行customHelper模板中的{{#if}}到{{else}}中的模板)、inverse(同fn相反执行{{else}}到{{/if}}之间的)、name、data等属性。 }); 参考:http://cnodejs.org/topic/56a2e8b1cd415452622eed2dhttp://www.cnblogs.com/iyangyuan/archive/2013/12/12/3471227.html","tags":[{"name":"Handlebars","slug":"Handlebars","permalink":"http://yoursite.com/tags/Handlebars/"}]},{"title":"break-word、word-wrap、white-space","date":"2017-03-10T09:04:18.000Z","path":"2017/03/10/break-word-word-wrap-white-space/","text":"white-spacewhite-space的定义是用来设置如何处理元素中的空白。这里的空白指的是空格、tab制表符。 默认情况下，html中连续出现的多个空格会被合并成一个空格，Tab也会被替换成一个空格。回车换行(br换行不在内)会被忽略并将其替换成一个空格。当在容器剩余空间不足以容纳一个单词时，浏览器会在单词结束处自动换行。(默认情况下，是无法在一个单词内进行自动换行的，只能在结尾处换行。) 值 是否合并空白符(空格、tab) 是否忽略回车换行 是否允许自动换行 normal 合并 忽略 允许 nowrap 合并 忽略 不允许 pre 保留 保留 不允许 pre-wrap 保留 保留 允许 pre-line 合并 保留 允许 word-wrapword-wrap的定义是用来说明当一个不能被分开的字符串太长而不能填充其包裹盒时，为防止其溢出，浏览器是否允许这样的单词中断换行。既指明是否允许浏览器在单词内进行自动换行 值 解释 normal 在单词结束处换行 break-word 如果行内没有多余空间容纳该单词到行尾，则会强制将单词截断，在单词内进行换行 word-breakword-break指定了怎样在单词内断行 值 解释 normal 默认换行规则 break-all 对于non-CJK (中文/日文/韩文) 文本，可在任意字符间断行。 keep-all CJK 文本不断行。 Non-CJK 文本表现同 normal。 在white-space、word-wrap、word-break都为normal值时，既默认情况下时。一行的剩余空间不足以容纳一个单词时，浏览器会将这个单词挪到下一行显示。挪后如果这个单词比容器还长，则这个单词会直接溢出，因为默认情况下，浏览器是无法在单词内进行换行的。中文会一行空间不足以容纳一个字时，在字后进行换行 此时如果设置word-wrap:break-word，则会将这个长单词进行截断，从截断处进行换行。 可以发现第一行仍然有一点空间没有利用，此时就需要用到word-break:break-all; 可以说word-break:break-all是word-wrap:break-word的升级版本，它不会在剩余空间不够的时候将长单词挪到下一行，它将单词放在原位，并在容器边界处直接将这个长单词进行截断，然后换行。 将这三个属性，组合使用会怎么样 当设置了white-space:nowrap;时，word-wrap:break-word;和word-break:break-all;都将失效。文本将会强制在一行内显示 当同时设置word-wrap:break-word;和word-break:break-all时，word-break:break-all的效果会生效 word-spacing规定英文单词之间的间距 letter-spacing规定英文字符之间的间距 总结: 默认情况下，当一行的剩余空间不足以容纳某一单词时，浏览器会将此单词整体挪到下一行显示。此时，若这个单词超长(长度超出容器的宽度)，则此单词会直接溢出(此时上一行会留下一段空白)。 word-wrap:指明是否允许在长单词中换行，当设置其属性为break-word，则会把超过容器长度的单词进行截断，并换行(上一行留下的空白并不会被清除) word-break:当其设置break-all时，它是word-wrap:break-word的升级版，它能解决上一行留白问题。它会让单词先在当前行显示，当单词某个字符到达容器边界时，会直接在此字符出进行截断，并换行。这样就最大限度的利用了空间。 white-space:指定处理空白符的方式，比较有用的属性为nowrap，设置文本不换行。一般配合其它css实现文本过长省略号 word-spacing:规定英文单词之间的间距 letter-spacing:规定英文单词字符之间的间距 图片引用在自http://www.cnblogs.com/2050/archive/2012/08/10/2632256.html","tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]}]