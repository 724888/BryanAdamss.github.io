<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[type-existence]]></title>
      <url>%2F2017%2F08%2F04%2Ftype-existence%2F</url>
      <content type="text"><![CDATA[本来在《编写可维护性的javascript》中已经做过总结，但最近在使用上又出现一点问题，所以推翻以前的单独写篇关于类型检测和存在性检测的文章 类型检测和存在性检测必备知识点 哪些值会被转成false “”、0、NaN、false、null、undefined会在期待布尔值的地方被转成false; 非上面提及的值都会被转成true； 注意空对象(没有任何属性/方法的对象)也会视为true1234var a=&#123;&#125;;if(a)&#123; console.log(true);// true&#125; 声明和赋值 未声明(更未赋值)的变量 直接使用，会报错 1console.log(b);// Uncaught ReferenceError: b is not defined 如果通过typeof b来使用，则不会报错；因为typeof存在一个特殊的安全防范机制； 已声明未赋值的变量 会有默认值undefined123var a;console.log(a===undefined);// trueconsole.log(typeof a);// 'undefined' 注意:当未声明的变量使用typeof检测时，并不会报错，而且返回&#39;undefined&#39;；因为typeof存在一个特殊的安全防范机制； 1console.log(typeof b);// 'undefined'，并没有报错 总结 未声明和已声明未赋值的变量使用typeof检测时，都会返回&#39;undefined&#39; 访问对象上不存在的属性/方法时，并不会报错，而是返回一个undefined 1234var obj=&#123; a:3&#125;;console.log(obj.b);// undefined 类型检测-&gt;(判断值的类型) 首先变量是没有类型的，类型本质指的是变量持有的值的类型，一般说的变量类型，实际指的是变量持有的值的类型 判断类型主要用来，检测输入的参数是否为想要的类型 12345function test(fn)&#123; if(typeof fn==='function')&#123; // xxxxx &#125;&#125; 一般值 string、number、boolean、undefined-&gt;typeof来判断 null一般不用做类型检测，只有在变量是一个可预期的null值时，才用来判断1234var obj=null;if(obj===null)&#123; // xxx&#125; 引用值 自定义、非数组、非函数-&gt;使用obj instanceof constructor 12345678function People(name)&#123; this.name=name;&#125;var p=new People();console.log(p instanceof People);// truevar date=new Date();console.log(date instanceof Date); 函数-&gt;typeof 12function fn()&#123;&#125;console.log(typeof fn==='function');// 'function' 数组 es5的isArray 12var arr=[];console.log(Array.isArray(arr));// true Object.prototype.call(this,arr); 12var arr=[];console.log(Object.prototype.toString.call(arr)==='[object Array]'); 存在性 常用检测存在性的不足 12345var obj=&#123; b:0&#125;;if(b)&#123;&#125;// 如果b存在，则xxx；当b为"",0,NaN,false,null,undefined时，就无法检测；同理b&amp;&amp;b()也会出现类似问题，所以只有在明确知道要检测的值不会是"",0,NaN,false,null,undefined中的一种时才能用 变量是否存在(是否已经声明) 全局变量的存在性 1console.log('a' in window);// false;判断变量a在全局环境下是否声明 局部变量的存在性 局部变量无法用in判断，只能退而求其次用typeof，typeof无法准确判断出是未声明还是已声明未赋值，如下123var a;console.log(typeof a==='undefined');// true;a已经声明但未赋值 console.log(typeof b==='undefined');// true;b没有声明 对象的属性是否存在 一般属性-&gt;统一使用in 实例属性存在性-&gt;统一使用hasOwnProperty IE8及以下判断实例属性存在性-&gt;先判断hasOwnProperty的存在性，再调用hasOwnProperty123456var obj_a=&#123; test:'测试'&#125;;console.log('test' in obj_a);// trueconsole.log('toString' in obj_a);// true，能检测到原型链上的方法console.log(obj_a.hasOwnProperty('toString'));//false,obj_a并没有实例属性(方法)`toString`，`toString`存在于其原型对象上，hasOwnProperty无法检测到]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Vue-guide]]></title>
      <url>%2F2017%2F08%2F01%2FVue-guide%2F</url>
      <content type="text"><![CDATA[VueJs官网教程学习笔记安装 兼容性:不支持IE8及以下版本浏览器；因为使用了IE8无法模拟的Object.defineProperty 开发版本-&gt;包含了完整的警告和调试模式 CLI-&gt;可以构建一个完整的vue项目 介绍 是一套构建用户界面的框架，本身只关注视图层，但可以和第三方库结合来构建复杂的spa Vue实例 构造器 Vue(选项对象) 123var vm = new Vue(&#123; // 选项&#125;); 可扩展Vue构造器 12345var MyComponent = Vue.extend(&#123; // 扩展选项&#125;)// 所有的 `MyComponent` 实例都将以预定义的扩展选项被创建var myComponentInstance = new MyComponent() 属性与方法 每个vue实例会代理其data对象里有所有属性，这些属性都是响应式的； $开头的为vue实例属性/方法 不要在实例属性或者回调函数中使用箭头函数，箭头函数会绑定上级context，this预期将不会是vue实例 实例生命周期 生命周期钩子-&gt;自定义事件 可以在选项对象中进行配置 生命周期钩子中的this指向实例化后的对象12345678910var vm = new Vue(&#123; data: &#123; a: 1 &#125;, created: function () &#123; // `this` 指向 vm 实例 console.log('a is: ' + this.a) &#125;&#125;)// -&gt; "a is: 1" 模板语法插值 文本 绑定文本 v-text 会将对应表达式求值后，当做字符串替换元素内的内容 {{ msg }} msg 改变时，视图也会发生改变;是v-text的简写，求值后，当做字符串替换 {{ }}处的内容;{{ }}中可以使用表达式，但不能使用语句，流程控制也不能用(使用三元表达式代替) {{ }}形式会和ng中的一样，存在首次加载闪烁的问题，如果是首屏内容，可以尝试使用v-text绑定 一次性插值 在元素上使用v-once指令，这样元素内部的所有数据绑定，只会显示第一次绑定时的数据，当数据发生变化时，它们都不会得到更新，可以用在不会发生改变的数据的绑定；1&lt;span v-once&gt;This will never change: &#123;&#123; msg &#125;&#125;,&#123;&#123; test &#125;&#125;&lt;/span&gt; 纯html v-html {{ }}和v-text会将数据当做纯文本处理，不会对其做html解析;v-html会将对应表达表达式当做html解析后，输出到元素内 属性(特性) v-bind 主要用来绑定特性 v-bind:title=&quot;test&quot; 将test绑定到元素的title特性上； 缩写 v-bind:href=&quot;url&quot;-&gt;:href=&quot;url&quot; 指令 指令是v-开头(ng中以ng-开头)，它的预期是一个单一js表达式(v-for除外) 可以带参数 1234567 &lt;a v-bind:href="url"&gt;&lt;/a&gt; &lt;a v-on:click="doSomething"&gt; ``` - 修饰符 - 指令后通过添加`.`来附加修饰符（Modifiers），用于指出一个指令应该以特殊方式绑定。 ```javascript &lt;form v-on:submit.prevent="onSubmit"&gt;&lt;/form&gt;// submit时阻止默认行为 过滤器 vue2.0中没有预定义的过滤器了，所有filter都需要自定义 主要用在{{ }}和v-bind中，达到格式化输出文本的作用 可级联使用 可带参数1234567891011121314151617181920//使用&lt;!-- in mustaches --&gt;&#123;&#123; message | capitalize &#125;&#125;&lt;!-- in v-bind --&gt;&lt;div v-bind:id="rawId | formatId"&gt;&lt;/div&gt;// 定义new Vue(&#123; // ... filters: &#123; capitalize: function (value) &#123; if (!value) return '' value = value.toString() return value.charAt(0).toUpperCase() + value.slice(1) &#125; &#125;&#125;)// 级联使用&#123;&#123; message | filterA | filterB &#125;&#125;// 带参数&#123;&#123; message | filterA('arg1', arg2) &#125;&#125;// 这里，filterA 是个拥有三个参数的函数。message 的值将会作为第一个参数传入。字符串 'arg1' 将作为第二个参数传给 filterA，表达式 arg2 的值将作为第三个参数。 缩写 v-bind 1234&lt;!-- 完整语法 --&gt;&lt;a v-bind:href="url"&gt;&lt;/a&gt;&lt;!-- 缩写 --&gt;&lt;a :href="url"&gt;&lt;/a&gt; v-on 1234&lt;!-- 完整语法 --&gt;&lt;a v-on:click="doSomething"&gt;&lt;/a&gt;&lt;!-- 缩写 --&gt;&lt;a @click="doSomething"&gt;&lt;/a&gt; 计算属性计算属性 可以将计算属性当成data中属性添加了一个getter方法，并返回一个新属性，但新属性依赖data中的属性； 123456789101112131415// jsvar vm = new Vue(&#123; el: '#example', data: &#123; message: 'Hello' &#125;, computed: &#123; // a computed getter reversedMessage: function () &#123; // `this` 指向vm实例，由于vm实例代理了所有data中的属性，所以this.message能被访问到 return this.message.split('').reverse().join('') &#125; &#125;&#125;);// 当data中的message发生变化时，reversedMessage也会重新计算 计算属性vsMethods 1&lt;p&gt;Reversed message: "&#123;&#123; reversedMessage() &#125;&#125;"&lt;/p&gt; 123456methods: &#123; reversedMessage: function () &#123; return this.message.split('').reverse().join('') &#125;&#125;// 这样也能实现反转的效果 不同点 计算属性是基于它们的依赖进行缓存的；如上面计算属性的例子，只要data中的message没有发生变化，computed中的reversedMessage都不会重新计算，每次访问reversedMessage都将会是之前缓存的数据； methods则不存在缓存一说，如上面methods例子，只要`Reversed message: "{{ reversedMessage() }}"`需要重新渲染，reversedMessage就会被重新调用并计算一次 计算setter 计算属性默认只有getter，可以提供setter方法12345678910111213141516// ...computed: &#123; fullName: &#123; // getter get: function () &#123; return this.firstName + ' ' + this.lastName &#125;, // setter set: function (newValue) &#123; var names = newValue.split(' ') this.firstName = names[0] this.lastName = names[names.length - 1] &#125; &#125;&#125;// ... watch 主要用来观测数据的变化，并进行一系列的操作 1234567&lt;div id="watch-example"&gt; &lt;p&gt; Ask a yes/no question: &lt;input v-model="question"&gt; &lt;/p&gt; &lt;p&gt;&#123;&#123; answer &#125;&#125;&lt;/p&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!-- Since there is already a rich ecosystem of ajax libraries --&gt;&lt;!-- and collections of general-purpose utility methods, Vue core --&gt;&lt;!-- is able to remain small by not reinventing them. This also --&gt;&lt;!-- gives you the freedom to just use what you're familiar with. --&gt;&lt;script src="https://unpkg.com/axios@0.12.0/dist/axios.min.js"&gt;&lt;/script&gt;&lt;script src="https://unpkg.com/lodash@4.13.1/lodash.min.js"&gt;&lt;/script&gt;&lt;script&gt;var watchExampleVM = new Vue(&#123; el: '#watch-example', data: &#123; question: '', answer: 'I cannot give you an answer until you ask a question!' &#125;, watch: &#123; // 如果 question 发生改变，这个函数就会运行 question: function (newQuestion) &#123; this.answer = 'Waiting for you to stop typing...' this.getAnswer() &#125; &#125;, methods: &#123; // _.debounce 是一个通过 lodash 限制操作频率的函数。 // 在这个例子中，我们希望限制访问yesno.wtf/api的频率 // ajax请求直到用户输入完毕才会发出 // 学习更多关于 _.debounce function (and its cousin // _.throttle), 参考: https://lodash.com/docs#debounce getAnswer: _.debounce( function () &#123; if (this.question.indexOf('?') === -1) &#123; this.answer = 'Questions usually contain a question mark. ;-)' return &#125; this.answer = 'Thinking...' var vm = this axios.get('https://yesno.wtf/api') .then(function (response) &#123; vm.answer = _.capitalize(response.data.answer) &#125;) .catch(function (error) &#123; vm.answer = 'Error! Could not reach the API. ' + error &#125;) &#125;, // 这是我们为用户停止输入等待的毫秒数 500 ) &#125;&#125;)&lt;/script&gt; 什么时候用computed、methods、watch computed主要用在根据原有属性，进行计算，返回新属性的操作；即适合用在对数据(属性)的set和get上 methods主要用来编写一些通用，没有什么依赖的方法。 watch主要用来观测数据(属性)的变化，当变化时进行一系列操作（异步操作或开销较大的操作） 总结 computed适合用来对数据进行set、get watch适合用来在数据变化时，进行大开销的操作 methods 用来编写通用的方法 Class与Style绑定绑定 HTML Class类似ng-class 对象语法 传一个对象，以动态切换class 1&lt;div v-bind:class="&#123; active: isActive &#125;"&gt;&lt;/div&gt;// isActive为true时，则添加active样式类，为false则去除 可以传多个属性，进行动态切换class；并v-bind:class可以和普通class属性共存 123&lt;div class="static" v-bind:class="&#123; active: isActive, 'text-danger': hasError &#125;"&gt;&lt;/div&gt; 可以直接绑定data里的一个对象 12345678&lt;div v-bind:class="classObject"&gt;&lt;/div&gt;// jsdata: &#123; classObject: &#123; active: true, 'text-danger': false &#125;&#125; 也可以绑定一个computed里的对象 1234567891011121314&lt;div v-bind:class="classObject"&gt;&lt;/div&gt;// jsdata: &#123; isActive: true, error: null&#125;,computed: &#123; classObject: function () &#123; return &#123; active: this.isActive &amp;&amp; !this.error, 'text-danger': this.error &amp;&amp; this.error.type === 'fatal', &#125; &#125;&#125; 数组语法 可以把数组传递给v-bind:class，以应用一个class列表 123456&lt;div v-bind:class="[activeClass, errorClass]"&gt;// jsdata: &#123; activeClass: 'active', errorClass: 'text-danger'&#125; 可以在数组中使用条件表达式 1&lt;div v-bind:class="[isActive ? activeClass : '', errorClass]"&gt; 可以在数组中使用对象语法 1&lt;div v-bind:class="[&#123; active: isActive &#125;, errorClass]"&gt; 绑定内联样式类似ng-style 对象语法 直接绑定一个对象，CSS属性名用驼峰式(camelCase) 123456&lt;div v-bind:style="&#123; color: activeColor, fontSize: fontSize + 'px' &#125;"&gt;&lt;/div&gt;// jsdata: &#123; activeColor: 'red', fontSize: 30&#125; 数组语法 v-bind:style 的数组语法可以将多个样式对象应用到一个元素上1&lt;div v-bind:style="[baseStyles, overridingStyles]"&gt; 多重值 从 2.3.0 起你可以为 style 绑定中的属性提供一个包含多个值的数组，常用于提供多个带前缀的值1&lt;div :style="&#123; display: ['-webkit-box', '-ms-flexbox', 'flex'] &#125;"&gt; 条件渲染类似ng-if v-if 条件为true时，则渲染，将元素添加到DOM中，为false，则将其从dom中删除 1&lt;h1 v-if="ok"&gt;Yes&lt;/h1&gt; 条件渲染一组 可以将需要条件渲染的元素放到&lt;template&gt;元素中，然后用v-if条件渲染12345&lt;template v-if="ok"&gt; &lt;h1&gt;Title&lt;/h1&gt; &lt;p&gt;Paragraph 1&lt;/p&gt; &lt;p&gt;Paragraph 2&lt;/p&gt;&lt;/template&gt; v-else 可以使用v-else指令来表示v-if的”else块” 123456&lt;div v-if="Math.random() &gt; 0.5"&gt; Now you see me&lt;/div&gt;&lt;div v-else&gt; Now you don't&lt;/div&gt; v-else元素必须紧跟在v-if或者v-else-if元素的后面——否则它将不会被识别 v-else-if 充当”else if块”；可链式调用 123456789101112&lt;div v-if="type === 'A'"&gt; A&lt;/div&gt;&lt;div v-else-if="type === 'B'"&gt; B&lt;/div&gt;&lt;div v-else-if="type === 'C'"&gt; C&lt;/div&gt;&lt;div v-else&gt; Not A/B/C&lt;/div&gt; 类似于 v-else，v-else-if 必须紧跟在 v-if 或者 v-else-if 元素之后 用 key 管理可复用的元素 默认情况下，vue会尽可能的高效渲染元素，通常会复用已有元素而不是从头开始渲染。 123456789&lt;template v-if="loginType === 'username'"&gt; &lt;label&gt;Username&lt;/label&gt; &lt;input placeholder="Enter your username"&gt;&lt;/template&gt;&lt;template v-else&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input placeholder="Enter your email address"&gt;&lt;/template&gt;// 这里的input会被复用，并不会因为if和else而渲染两个，只是改变placeholder，这样效率更高 有时，我们就是需要渲染两个，这是就需要使用key；如上面例子，为这两个input分别添加一个唯一的key值时，切换时，vue就不会复用他们，而是重新渲染一个 123456789&lt;template v-if="loginType === 'username'"&gt; &lt;label&gt;Username&lt;/label&gt; &lt;input placeholder="Enter your username" key="username-input"&gt;&lt;/template&gt;&lt;template v-else&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input placeholder="Enter your email address" key="email-input"&gt;&lt;/template&gt;// 注意, &lt;label&gt; 元素仍然会被高效地复用，因为它们没有添加 key 属性。 v-show 通过切换元素的display属性，元素会一直保留在DOM中，并不会因为为false，就把元素从DOM中删除，这点和v-if不同 v-if和v-show v-if是通过增加、删除元素来达到显示/隐藏 v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。 v-show通过css切换(display属性)来显示/隐藏 v-show不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。 一般来说， v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件不太可能改变，则使用 v-if 较好。 v-if和v-for一起使用 v-for 具有比 v-if 更高的优先级；先循环，再判断显示隐藏 列表渲染v-for 数组迭代 12345678910111213141516&lt;ul id="example-2"&gt; &lt;li v-for="(item, index) in items"&gt; &#123;&#123; parentMessage &#125;&#125; - &#123;&#123; index &#125;&#125; - &#123;&#123; item.message &#125;&#125; &lt;/li&gt;&lt;/ul&gt;// jsvar example2 = new Vue(&#123; el: '#example-2', data: &#123; parentMessage: 'Parent', items: [ &#123; message: 'Foo' &#125;, &#123; message: 'Bar' &#125; ] &#125;&#125;); 渲染多个元素块-&gt;使用&lt;template&gt;包裹 123456&lt;ul&gt; &lt;template v-for="item in items"&gt; &lt;li&gt;&#123;&#123; item.msg &#125;&#125;&lt;/li&gt; &lt;li class="divider"&gt;&lt;/li&gt; &lt;/template&gt;&lt;/ul&gt; 对象迭代 在遍历对象时，是按 Object.keys() 的结果遍历，但是不能保证它的结果在不同的 JavaScript 引擎下是一致的。1234567891011121314&lt;div v-for="(value, key, index) in object"&gt; &#123;&#123; index &#125;&#125;. &#123;&#123; key &#125;&#125; : &#123;&#123; value &#125;&#125;&lt;/div&gt;// jsnew Vue(&#123; el: '#repeat-object', data: &#123; object: &#123; firstName: 'John', lastName: 'Doe', age: 30 &#125; &#125;&#125;); 整数迭代 1234&lt;div&gt; &lt;!-- span会重复10次 --&gt; &lt;span v-for="n in 10"&gt;&#123;&#123; n &#125;&#125; &lt;/span&gt;&lt;/div&gt; v-for和v-if 当它们处于同一节点， v-for 的优先级比 v-if 更高，这意味着 v-if 将分别重复运行于每个 v-for 循环中。相当于在for循环中，再用if判断； 123&lt;li v-for="todo in todos" v-if="!todo.isComplete"&gt; &#123;&#123; todo &#125;&#125;&lt;/li&gt; 如果想条件判断了再循环，可以先if再for 12345&lt;ul v-if="shouldRenderTodos"&gt; &lt;li v-for="todo in todos"&gt; &#123;&#123; todo &#125;&#125; &lt;/li&gt;&lt;/ul&gt; key vue默认会采取”就地复用”的策略,如果数据项的顺序被改变，Vue将不是移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性。 1234567891011121314151617&lt;div v-for="item in items" :key="item.id"&gt; &lt;!-- 内容 --&gt;&lt;/div&gt;``` 建议尽可能使用 v-for 来提供 key ，除非迭代 DOM 内容足够简单，或者你是故意要依赖于默认行为来获得性能提升。因为它是 Vue 识别节点的一个通用机制， key 并不特别与 v-for 关联，key 还具有其他用途，我们将在后面的指南中看到其他用途。### 数组更新检测- 变异方法 - 会改变原数组的方法都为变异方法push()、pop()、shift()、unshift()、splice()、sort()、reverse()；所有变异方法(会改变原数组的方法)都会触发更新检测,若发现数组有变化，则会更新依赖它的地方- 重塑数组 - 不会改变原数组的方法为非变异方法，非变异方法会返回一个新的数组；filter(), concat(), slice()都是非变异方法；当使用新返回的数组替换原先的数组时(重塑数组)，不用担心vue会丢弃现有DOM重新渲染，vue会智能的复用DOM元素， ```javascript example1.items = example1.items.filter(function (item) &#123; return item.message.match(/Foo/) &#125;); 注意 由于js的限制，vue不能检测下面变动的数组，将不会触发更新 当你利用索引直接设置一个项时，例如： vm.items[indexOfItem] = newValue 当你修改数组的长度时，例如： vm.items.length = newLength 解决方法 第一种问题，可以使用Vue.set或者splice方法 1234// Vue.setVue.set(example1.items, indexOfItem, newValue)// splice方法example1.items.splice(indexOfItem, 1, newValue) 第二种问题可以使用splice 1example1.items.splice(newLength) 显示过滤/排序结果 我们想要显示一个数组的过滤或排序副本，而不实际改变或重置原始数据。在这种情况下，可以创建返回过滤或排序数组的计算属性。123456789101112&lt;li v-for="n in evenNumbers"&gt;&#123;&#123; n &#125;&#125;&lt;/li&gt;// jsdata: &#123; numbers: [ 1, 2, 3, 4, 5 ]&#125;,computed: &#123; evenNumbers: function () &#123; return this.numbers.filter(function (number) &#123; return number % 2 === 0 &#125;) &#125;&#125; 事件处理器监听事件 v-on 使用v-on监听事件 1234&lt;div id="example-1"&gt; &lt;button v-on:click="counter += 1"&gt;增加 1&lt;/button&gt; &lt;p&gt;这个按钮被点击了 &#123;&#123; counter &#125;&#125; 次。&lt;/p&gt;&lt;/div&gt; 缩写 v-on:click=&quot;xxx&quot;-&gt;@click=&quot;xxx&quot; 方法事件处理器 为事件指定一个处理函数123456789101112131415161718192021222324&lt;div id="example-2"&gt; &lt;!-- `greet` 是在下面定义的方法名 --&gt; &lt;button v-on:click="greet"&gt;Greet&lt;/button&gt;&lt;/div&gt;// jsvar example2 = new Vue(&#123; el: '#example-2', data: &#123; name: 'Vue.js' &#125;, // 在 `methods` 对象中定义方法 methods: &#123; greet: function (event) &#123; // `this` 在方法里指当前 Vue 实例 alert('Hello ' + this.name + '!') // `event` 是原生 DOM 事件 if (event) &#123; alert(event.target.tagName) &#125; &#125; &#125;&#125;)// 也可以用 JavaScript 直接调用方法example2.greet() // -&gt; 'Hello Vue.js!' 内联处理器方法 直接将处理逻辑写在v-on:click=之后 1234&lt;div id="example-3"&gt; &lt;button v-on:click="say('hi')"&gt;Say hi&lt;/button&gt; &lt;button v-on:click="say('what')"&gt;Say what&lt;/button&gt;&lt;/div&gt; 传递event给内联处理器需要使用$event 1234567891011&lt;button v-on:click="warn('Form cannot be submitted yet.', $event)"&gt; Submit&lt;/button&gt;// jsmethods: &#123; warn: function (message, event) &#123; // 现在我们可以访问原生事件对象 if (event) event.preventDefault() alert(message) &#125;&#125; 事件修饰符 事件中经常需要调用event.preventDefault() 或 event.stopPropagation()，为了简化操作，也为了让处理函数中只有业务逻辑没有事件相关细节，所以vue在v-on:上添加修饰符 .stop,.prevent,.capture,.self,.once 1234567891011121314&lt;!-- 阻止单击事件冒泡 --&gt;&lt;a v-on:click.stop="doThis"&gt;&lt;/a&gt;&lt;!-- 提交事件不再重载页面 --&gt;&lt;form v-on:submit.prevent="onSubmit"&gt;&lt;/form&gt;&lt;!-- 修饰符可以串联 --&gt;&lt;a v-on:click.stop.prevent="doThat"&gt;&lt;/a&gt;&lt;!-- 只有修饰符 --&gt;&lt;form v-on:submit.prevent&gt;&lt;/form&gt;&lt;!-- 添加事件侦听器时使用事件捕获模式 --&gt;&lt;div v-on:click.capture="doThis"&gt;...&lt;/div&gt;&lt;!-- 只当事件在该元素本身（比如不是子元素）触发时触发回调 --&gt;&lt;div v-on:click.self="doThat"&gt;...&lt;/div&gt;&lt;!-- 点击事件将只会触发一次 --&gt;&lt;a v-on:click.once="doThis"&gt;&lt;/a&gt; 使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 @click.prevent.self 会阻止所有的点击，而 @click.self.prevent 只会阻止元素上的点击。 键值修饰符 Vue 允许为 v-on 在监听键盘事件时添加关键修饰符 123456&lt;!-- 只有在 keyCode 是 13 时调用 vm.submit() --&gt;&lt;input v-on:keyup.13="submit"&gt;&lt;!-- 同上 --&gt;&lt;input v-on:keyup.enter="submit"&gt;&lt;!-- 缩写语法 --&gt;&lt;input @keyup.enter="submit"&gt; 按键别名 .enter,.tab,.delete(捕获“删除”和“退格”键),.esc,.space,.up,.down,.left,.right 可以通过全局 config.keyCodes 对象自定义键值修饰符别名12// 可以使用 v-on:keyup.f1Vue.config.keyCodes.f1 = 112 修饰键 .ctrl,.alt,.shift,.meta 1234&lt;!-- Alt + C --&gt;&lt;input @keyup.alt.67="clear"&gt;&lt;!-- Ctrl + Click --&gt;&lt;div @click.ctrl="doSomething"&gt;Do something&lt;/div&gt; 滑鼠按键修饰符 .left,.right,.middle 表单控件绑定基础用法 v-model v-model可以实现表单控件的双向绑定；它会根据控件类型自动选取正确的方法来更新元素；类似ng-model v-model会忽略所有表单元素的value、checked、selected特性的初始值。因为它会选择Vue实例数据来作为具体的值。应该通过data选项声明初始值。 v-model在中文输入(IME)时不会更新，可以监听input事件 简单的表单 12345678&lt;!-- 文本 --&gt;&lt;input v-model="message" placeholder="edit me"&gt;&lt;p&gt;Message is: &#123;&#123; message &#125;&#125;&lt;/p&gt;&lt;!-- 多行文本 --&gt;&lt;span&gt;Multiline message is:&lt;/span&gt;&lt;p style="white-space: pre-line"&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;&lt;br&gt;&lt;textarea v-model="message" placeholder="add multiple lines"&gt;&lt;/textarea&gt;&lt;!-- 在文本区域插值( &lt;textarea&gt;&lt;/textarea&gt; ) 并不会生效，应用 v-model 来代替 --&gt; 复选框 单个复选框，逻辑值 12&lt;input type="checkbox" id="checkbox" v-model="checked"&gt;&lt;label for="checkbox"&gt;&#123;&#123; checked &#125;&#125;&lt;/label&gt; 多个复选框，v-model需要绑定到同一个数组上 123456789101112131415&lt;input type="checkbox" id="jack" value="Jack" v-model="checkedNames"&gt;&lt;label for="jack"&gt;Jack&lt;/label&gt;&lt;input type="checkbox" id="john" value="John" v-model="checkedNames"&gt;&lt;label for="john"&gt;John&lt;/label&gt;&lt;input type="checkbox" id="mike" value="Mike" v-model="checkedNames"&gt;&lt;label for="mike"&gt;Mike&lt;/label&gt;&lt;br&gt;&lt;span&gt;Checked names: &#123;&#123; checkedNames &#125;&#125;&lt;/span&gt;// jsnew Vue(&#123; el: '...', data: &#123; checkedNames: [] &#125;&#125;); 单选按钮 同一组，v-model需要绑定到同一个数组上12345678910111213141516&lt;div id="example-4"&gt; &lt;input type="radio" id="one" value="One" v-model="picked"&gt; &lt;label for="one"&gt;One&lt;/label&gt; &lt;br&gt; &lt;input type="radio" id="two" value="Two" v-model="picked"&gt; &lt;label for="two"&gt;Two&lt;/label&gt; &lt;br&gt; &lt;span&gt;Picked: &#123;&#123; picked &#125;&#125;&lt;/span&gt;&lt;/div&gt;// jsnew Vue(&#123; el: '#example-4', data: &#123; picked: '' &#125;&#125;); select 单选 12345678910&lt;div id="example-5"&gt; &lt;select v-model="selected"&gt; &lt;option disabled value=""&gt;请选择&lt;/option&gt; &lt;option&gt;A&lt;/option&gt; &lt;option&gt;B&lt;/option&gt; &lt;option&gt;C&lt;/option&gt; &lt;/select&gt; &lt;span&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/span&gt;&lt;/div&gt;// 如果 v-model 表达初始的值不匹配任何的选项，&lt;select&gt; 元素就会以”未选中”的状态渲染。在 iOS 中，这会使用户无法选择第一个选项，因为这样的情况下，iOS 不会引发 change 事件。因此，像以上提供 disabled 选项是建议的做法。 多选列表（绑定到一个数组） 12345678910111213141516&lt;div id="example-6"&gt; &lt;select v-model="selected" multiple style="width: 50px"&gt; &lt;option&gt;A&lt;/option&gt; &lt;option&gt;B&lt;/option&gt; &lt;option&gt;C&lt;/option&gt; &lt;/select&gt; &lt;br&gt; &lt;span&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/span&gt;&lt;/div&gt;// jsnew Vue(&#123; el: '#example-6', data: &#123; selected: [] &#125;&#125;); 动态选项(使用v-for渲染) 123456789101112131415161718&lt;select v-model="selected"&gt; &lt;option v-for="option in options" v-bind:value="option.value"&gt; &#123;&#123; option.text &#125;&#125; &lt;/option&gt;&lt;/select&gt;&lt;span&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/span&gt;// jsnew Vue(&#123; el: '...', data: &#123; selected: 'A', options: [ &#123; text: 'One', value: 'A' &#125;, &#123; text: 'Two', value: 'B' &#125;, &#123; text: 'Three', value: 'C' &#125; ] &#125;&#125;); 绑定value 对于单选按钮，勾选框及选择列表选项， v-model 绑定的 value 通常是静态字符串（对于勾选框是逻辑值）;但有时我们想绑定value到Vue实例的一个动态属性上 复选框 123456&lt;input type="checkbox" v-model="toggle" v-bind:true-value="a" v-bind:false-value="b"&gt;// 当选中时vm.toggle === vm.a// 当没有选中时vm.toggle === vm.b 单选按钮 123&lt;input type="radio" v-model="pick" v-bind:value="a"&gt;// 当选中时vm.pick === vm.a select 1234567&lt;select v-model="selected"&gt; &lt;!-- 内联对象字面量 --&gt; &lt;option v-bind:value="&#123; number: 123 &#125;"&gt;123&lt;/option&gt;&lt;/select&gt;// 当选中时typeof vm.selected // -&gt; 'object'vm.selected.number // -&gt; 123 v-model的修饰符 .lazy在默认情况下， v-model 在 input 事件中同步输入框的值与数据 (除了 上述 IME 部分)，但你可以添加一个修饰符 lazy ，从而转变为在 change 事件中同步 12&lt;!-- 在 "change" 而不是 "input" 事件中更新 --&gt;&lt;input v-model.lazy="msg" &gt; .number如果想自动将用户的输入值转为 Number 类型（如果原值的转换结果为 NaN 则返回原值），可以添加一个修饰符 number 给 v-model 来处理输入值 1&lt;input v-model.number="age" type="number"&gt; .trim如果要自动过滤用户输入的首尾空格，可以添加 trim 修饰符到 v-model 上过滤输入 1&lt;input v-model.trim="msg"&gt; 组件###]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[how-does-timer-work]]></title>
      <url>%2F2017%2F07%2F31%2Fhow-does-timer-work%2F</url>
      <content type="text"><![CDATA[最近看了些关于js中定时器原理解析的文章，所以特在此做一个记录本文带有个人理解，若有错误，望指正。 JS中的定时器(setTimeout)是如何工作的?定时器js中的setTimeout主要用来完成一些超时调用的任务，可以指定函数在未来的某个时间执行。123setTimeout(function()&#123; console.log('hi');&#125;,500); 理论情况下，’hi’会在500ms后被打印出来。 考虑下面这种情况12345console.log(1);setTimeout(function()&#123; console.log(2);&#125;,1000);console.log(3); 最后输出的顺序是1,3,2，你可能在想因为2被延迟了1000ms，所以最后输出的。 再看下面的12345console.log(1);setTimeout(function()&#123; console.log(2);&#125;,0);console.log(3); 这次我们将延迟的时间从1000调成了0，这次应该输出1,2,3了吧，但实际上最后的输出结果还是1,3,2这是为什么呢？要解释清楚这个就必须了解setTimeout的工作原理了。 工作原理js是单线程的，它同一时间它只能干一件事情。那你可能会问为什么不多弄几个线程，这样多管齐下，不是执行效率更高了吗？当时js的用途(交互、操作dom)决定了它只能是单线程的，如果多线程，就会存在多线程同步的问题。我在一个线程中删除了节点a，另一个线程在节点a上添加了一些内容，这样就会导致冲突，将一个简单的问题负责化了，所以最终js是单线程的。 解释下下面代码的执行过程12345console.log(1);setTimeout(function()&#123; console.log(2);&#125;,1000);console.log(3); 首先js中存在一个callstack(调用栈)的东西，它会将函数/方法压入(push)到栈中，并依次出栈(pop)执行。 默认上面代码外围有个main函数 main入栈 console.log(1)入栈 console.log(1)出栈并调用打印出1 setTimeout入栈 发现setTimeout是个延迟执行，出栈时，将需要延迟执行的回调函数交给浏览器的timer模块，timer模块负责观察延迟执行的回调函数是否到达触发条件，此时call stack会继续将后面的方法压入栈中 console.log(3)入栈 console.log(3)出栈并调用打印出3 main出栈 timer模块观察到延迟执行的函数到达触发条件后，将延迟执行的回调函数推入任务队列(task queue)中 当调用栈处于空闲状态时，它会将任务队列中的第一个任务压入callstack中，并调用，并一直重复这个过程直到任务队列为空。这个过程称为event loop 上面的setTimeout的延迟是1000，为0的时候其实也是一样的，只不过在timer模块中，它会立即到达触发条件，并被推入任务队列中，等待call stack空闲时，再压入到call stack中并调用。 上面是关于setTimeout延迟函数的调用过程，其实js中的事件、ajax的执行流程也一样(其实你会发现他们有个共同点，都有回调函数)。只不过setTimeout有一个具体的延迟时间，延迟时间到达了触发。事件是在用户进行某种操作后(点击)，立即将回调函数推入任务队列中，call stack空闲时取第一个并执行。ajax则是在返回数据后(满足触发条件)，将回调推入任务队列中，call stack空闲时取第一个并执行。 其实js的任务(代码)可以分为同步任务和异步任务(事件、ajax、setTimeout)，异步任务的回调一定是在所有同步任务都执行完了以后再被调用;12345console.log(1);setTimeout(function()&#123; console.log(2);&#125;,0);console.log(3); 如上面，即使setTimeout的延迟时间为0，它的回调函数也没有直接被调用，而是等到console.log(3)执行完，call stack为空时，再被调用执行的。所以setTimeour(fn,0)常用来在所有同步任务执行完后，尽可能早的执行； 再看下面的代码12345var req = new XMLHttpRequest();req.open('GET', url); req.onload = function ()&#123;&#125;; req.onerror = function ()&#123;&#125;; req.send(); 和12345var req = new XMLHttpRequest();req.open('GET', url);req.send();req.onload = function ()&#123;&#125;; req.onerror = function ()&#123;&#125;; 二者效果一样。 onload和onerror的位置无关紧要，不用担心先send了,load和error不会触发。因为load和error事件都属于异步任务(事件)，他们的回调函数一定是在所有同步任务完成后再被调用的。 总结： 通过上面可以发现，js中的异步任务(事件、ajax、setTimeout)，是需要call stack、浏览器中的对应模块(DOM Binding、network、timer)、task queue三者配合来完成异步任务； call stack负责压入待执行的方法/函数，遇到异步任务时，会将异步任务交给对应模块处理； 浏览器对应模块负责判断异步任务是否满足触发条件，若满足触发条件，则将异步任务的回调推入task queue中 task queue负责保存所有已经满足触发条件可以压入call stack中执行的异步任务回调。 当call stack空闲时，会将task queue中的第一个回调压入call stack中并执行，并一直循环这一过程直到task queue为空；-&gt;event loop 所有异步任务的回调一定是在所有同步任务都执行完了后再被调用 setTimeout(fn,0)无论写在哪，它的作用都是在所有同步任务执行完后，尽可能早的执行fn 参考链接 http://www.alloyteam.com/2015/10/turning-to-javascript-series-from-settimeout-said-the-event-loop-model/http://www.ruanyifeng.com/blog/2014/10/event-loop.htmlhttps://vimeo.com/96425312http://latentflip.com/loupe/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[AngularJs-todoMVC]]></title>
      <url>%2F2017%2F07%2F13%2FAngularJs-todoMVC%2F</url>
      <content type="text"><![CDATA[AngularJs-todoMVC 源码解释 github上的todoMVC仓库是一个帮助你选择前端MVC框架的项目项目中包含了绝大多数前端MVC框架实现Todo application的范例，让你能比较不同的框架实现同一个应用的差异。进而让你做出最佳选择。Todo application的具体效果，可以看这个http://todomvc.com/examples/angularjs/#/对于新手来说，是个很不错的学习范例。本文选取的是其中的angularJs范例，对其做了简单分析。分析源码已经上传至github，https://github.com/BryanAdamss/SourceSave/tree/master/TodoMVC/angularjs源码下载后，请在服务器中打开 目录结构主要根据功能不同，放在了不同文件夹中 angularjs/ js/ controllers/ todoCtrl.js-&gt;最主要的一个控制器 directives/ todoEscape.js-&gt;实现按下esc键，恢复到原先编辑状态的指令 todoFocus.js-&gt;再编辑input显示，聚焦的指令 services/ todoStorage.js-&gt;实现本地localStorge app.js-&gt;入口文件，包含了路由配置 node_modules/ angular/ angular-resource/ angular-route/ todomvc-app-css/-&gt;页面主要样式文件 todomvc-common/-&gt;一些通用的css样式和js helper index.html index.html相关说明全部写在注释里了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta name="renderer" content="webkit"&gt; &lt;meta name="keywords" content="我是关键字"&gt; &lt;meta name="description" content="我是网站描述"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"&gt; &lt;meta content="telephone=no,email=no" name="format-detection" /&gt; &lt;meta name="full-screen" content="yes"&gt; &lt;meta name="x5-fullscreen" content="true"&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,minimum-scale=1.0,user-scalable=no,minimal-ui" /&gt; &lt;link rel="stylesheet" href="node_modules/todomvc-common/base.css"&gt; &lt;link rel="stylesheet" href="node_modules/todomvc-app-css/index.css"&gt; &lt;title&gt;Angular | TodoMVC&lt;/title&gt; &lt;style&gt; [ng-cloak] &#123; /*防止闪屏*/ display: none; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body ng-app="todomvc"&gt; &lt;ng-view&gt;&lt;/ng-view&gt; &lt;script type="text/ng-template" id="todomvc-index.html"&gt; &lt;!-- 模板 --&gt; &lt;section id="todoapp"&gt; &lt;header id="header"&gt; &lt;h1&gt;todos&lt;/h1&gt; &lt;!-- form提交时，触发addTodo()事件 --&gt; &lt;form id="todo-form" ng-submit="addTodo()"&gt; &lt;!-- 新todo的输入框，值绑定到newTodo上，根据状态saving来禁用 --&gt; &lt;input id="new-todo" placeholder="What needs to be done?" ng-model="newTodo" ng-disabled="saving" autofocus&gt; &lt;/form&gt; &lt;/header&gt; &lt;!-- #main根据todos的长度来显示隐藏 --&gt; &lt;section id="main" ng-show="todos.length" ng-cloak&gt; &lt;!-- #toggle-all 布尔值绑定到allChecked上，点击时触发markAll --&gt; &lt;input id="toggle-all" type="checkbox" ng-model="allChecked" ng-click="markAll(allChecked)"&gt; &lt;label for="toggle-all"&gt;Mark all as complete&lt;/label&gt; &lt;ul id="todo-list"&gt; &lt;!-- 遍历每个todo，并通过statusFilter进行过滤，通过todo.completed、editedTodo来切换class --&gt; &lt;li ng-repeat="todo in todos | filter:statusFilter track by $index" ng-class="&#123;completed: todo.completed, editing: todo == editedTodo&#125;"&gt; &lt;div class="view"&gt; &lt;!-- todo前的复选框，值绑定到todo.completed，change时触发toggleCompleted事件，并传入对应todo --&gt; &lt;input class="toggle" type="checkbox" ng-model="todo.completed" ng-change="toggleCompleted(todo)"&gt; &lt;!-- 展示用label，双击时触发editTodo，并传入对应todo --&gt; &lt;label ng-dblclick="editTodo(todo)"&gt;&#123;&#123;todo.title&#125;&#125;&lt;/label&gt; &lt;!-- 删除按钮，点击时，移除对应todo --&gt; &lt;button class="destroy" ng-click="removeTodo(todo)"&gt;&lt;/button&gt; &lt;/div&gt; &lt;!-- 隐藏的再编辑表单，在表单提交时触发saveEdits --&gt; &lt;form ng-submit="saveEdits(todo, 'submit')"&gt; &lt;!-- 再编辑input，值绑定到todo.title并不去除前后空格；按下esc时触发reverEdits事件，恢复到之前状态；失去焦点时自动提交；当双击展示用label时，todo和editedTodo相等，会触发todo-focus指令，显示再编辑input--&gt; &lt;input class="edit" ng-trim="false" ng-model="todo.title" todo-escape="revertEdits(todo)" ng-blur="saveEdits(todo, 'blur')" todo-focus="todo == editedTodo"&gt; &lt;/form&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/section&gt; &lt;footer id="footer" ng-show="todos.length" ng-cloak&gt; &lt;!-- #todo-count 展示剩余待做todo数量 --&gt; &lt;span id="todo-count"&gt;&lt;strong&gt;&#123;&#123;remainingCount&#125;&#125;&lt;/strong&gt; &lt;!-- 当count为1显示'item left'，否则显示'items left' --&gt; &lt;ng-pluralize count="remainingCount" when="&#123; one: 'item left', other: 'items left' &#125;"&gt;&lt;/ng-pluralize&gt; &lt;/span&gt; &lt;ul id="filters"&gt; &lt;!-- 过滤状态，点击时触发$routeChangeSuccess事件，改变statusFilter，进而改变展示的数据 --&gt; &lt;li&gt; &lt;a ng-class="&#123;selected: status == ''&#125; " href="#/"&gt;All&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a ng-class="&#123;selected: status == 'active'&#125;" href="#/active"&gt;Active&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a ng-class="&#123;selected: status == 'completed'&#125;" href="#/completed"&gt;Completed&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;!-- 清除所有已完成todo，点击时触发clearCompletedTodos --&gt; &lt;button id="clear-completed" ng-click="clearCompletedTodos()" ng-show="completedCount"&gt;Clear completed&lt;/button&gt; &lt;/footer&gt; &lt;/section&gt; &lt;/script&gt; &lt;!-- 资源文件 --&gt; &lt;script src="node_modules/todomvc-common/base.js"&gt;&lt;/script&gt; &lt;script src="node_modules/angular/angular.js"&gt;&lt;/script&gt; &lt;script src="node_modules/angular-route/angular-route.js"&gt;&lt;/script&gt; &lt;script src="node_modules/angular-resource/angular-resource.js"&gt;&lt;/script&gt; &lt;!-- 逻辑文件 --&gt; &lt;script src="js/app.js"&gt;&lt;/script&gt; &lt;script src="js/controllers/todoCtrl.js"&gt;&lt;/script&gt; &lt;script src="js/services/todoStorage.js"&gt;&lt;/script&gt; &lt;script src="js/directives/todoFocus.js"&gt;&lt;/script&gt; &lt;script src="js/directives/todoEscape.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; app.jsapp.js是入口文件，主要是创建了模块，并配置了路由12345678910111213141516171819202122232425262728293031/*global angular *//** * The main TodoMVC app module * * @type &#123;angular.Module&#125; */angular.module('todomvc', ['ngRoute', 'ngResource']) .config(['$routeProvider', function($routeProvider) &#123; 'use strict'; var routeConfig = &#123; controller: 'TodoCtrl', templateUrl: 'todomvc-index.html', // 指定模板 resolve: &#123; store: function(todoStorage) &#123; // 在跳转路由之前载入正确的module // Get the correct module (API or localStorage). return todoStorage.then(function(module) &#123; module.get(); // Fetch the todo records in the background. return module; &#125;); &#125; &#125; &#125;; // 路由跳转 $routeProvider .when('/', routeConfig) .when('/:status', routeConfig) .otherwise(&#123; redirectTo: '/' &#125;); &#125;]); todoStorage.js这个文件是一个服务，主要实现了数据在localStorge中的存储和读写其实这一块没怎么看懂，主要是不太理解ngResource模块的作用，不过大概知道是存储和读取数据用的123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165/*global angular *//** * Services that persists and retrieves todos from localStorage or a backend API * if available. * * They both follow the same API, returning promises for all changes to the * model. */// 这一块是懵逼的...大概就是将数据存储在localStorage中angular.module('todomvc') .factory('todoStorage', function($http, $injector) &#123; 'use strict'; // Detect if an API backend is present. If so, return the API module, else // hand off the localStorage adapter return $http.get('/api') .then(function() &#123; return $injector.get('api'); &#125;, function() &#123; return $injector.get('localStorage'); &#125;); &#125;).factory('api', function($resource) &#123; 'use strict'; var store = &#123; todos: [], api: $resource('/api/todos/:id', null, &#123; update: &#123; method: 'PUT' &#125; &#125;), clearCompleted: function() &#123; var originalTodos = store.todos.slice(0); var incompleteTodos = store.todos.filter(function(todo) &#123; return !todo.completed; &#125;); angular.copy(incompleteTodos, store.todos); return store.api.delete(function() &#123;&#125;, function error() &#123; angular.copy(originalTodos, store.todos); &#125;); &#125;, delete: function(todo) &#123; var originalTodos = store.todos.slice(0); store.todos.splice(store.todos.indexOf(todo), 1); return store.api.delete(&#123; id: todo.id &#125;, function() &#123;&#125;, function error() &#123; angular.copy(originalTodos, store.todos); &#125;); &#125;, get: function() &#123; return store.api.query(function(resp) &#123; angular.copy(resp, store.todos); &#125;); &#125;, insert: function(todo) &#123; var originalTodos = store.todos.slice(0); return store.api.save(todo, function success(resp) &#123; todo.id = resp.id; store.todos.push(todo); &#125;, function error() &#123; angular.copy(originalTodos, store.todos); &#125;) .$promise; &#125;, put: function(todo) &#123; return store.api.update(&#123; id: todo.id &#125;, todo) .$promise; &#125; &#125;; return store;&#125;).factory('localStorage', function($q) &#123; 'use strict'; var STORAGE_ID = 'todos-angularjs'; var store = &#123; todos: [], _getFromLocalStorage: function() &#123; return JSON.parse(localStorage.getItem(STORAGE_ID) || '[]'); &#125;, _saveToLocalStorage: function(todos) &#123; localStorage.setItem(STORAGE_ID, JSON.stringify(todos)); &#125;, clearCompleted: function() &#123; var deferred = $q.defer(); var incompleteTodos = store.todos.filter(function(todo) &#123; return !todo.completed; &#125;); angular.copy(incompleteTodos, store.todos); store._saveToLocalStorage(store.todos); deferred.resolve(store.todos); return deferred.promise; &#125;, delete: function(todo) &#123; var deferred = $q.defer(); store.todos.splice(store.todos.indexOf(todo), 1); store._saveToLocalStorage(store.todos); deferred.resolve(store.todos); return deferred.promise; &#125;, get: function() &#123; var deferred = $q.defer(); angular.copy(store._getFromLocalStorage(), store.todos); deferred.resolve(store.todos); return deferred.promise; &#125;, insert: function(todo) &#123; var deferred = $q.defer(); store.todos.push(todo); store._saveToLocalStorage(store.todos); deferred.resolve(store.todos); return deferred.promise; &#125;, put: function(todo, index) &#123; var deferred = $q.defer(); store.todos[index] = todo; store._saveToLocalStorage(store.todos); deferred.resolve(store.todos); return deferred.promise; &#125; &#125;; return store;&#125;); todoEscape.js这是一个指令，主要完成按下esc键，恢复再编辑input到原先状态12345678910111213141516171819202122232425/*global angular *//** * Directive that executes an expression when the element it is applied to gets * an `escape` keydown event. */// esc键绑定事件// 当按下Escape键时，执行attrs.todoEscape的表达式。angular.module('todomvc') .directive('todoEscape', function() &#123; 'use strict'; var ESCAPE_KEY = 27; return function(scope, elem, attrs) &#123; // 直接返回一个函数，实际上就是link函数；在link函数中绑定事件 elem.bind('keydown', function(event) &#123; if (event.keyCode === ESCAPE_KEY) &#123; // 按下esc，触发attrs.todoEscape对应的事件 scope.$apply(attrs.todoEscape); &#125; &#125;); scope.$on('$destroy', function() &#123; // 销毁时，解除绑定 elem.unbind('keydown'); &#125;); &#125;; &#125;); todoFocus.js这个指令主要完成再编辑input的显示和聚焦1234567891011121314151617181920/*global angular *//** * Directive that places focus on the element it is applied to when the * expression it binds to evaluates to true */angular.module('todomvc') .directive('todoFocus', function todoFocus($timeout) &#123; 'use strict'; return function(scope, elem, attrs) &#123; // 在二次编辑的input上绑定事件 scope.$watch(attrs.todoFocus, function(newVal, oldVal) &#123; // 当双击时，newVal为true if (newVal) &#123; $timeout(function() &#123; elem[0].focus(); &#125;, 0, false); &#125; &#125;); &#125;; &#125;); todoCtrl.js这是重头性，关键性逻辑全写在这123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126/*global angular *//** * The main controller for the app. The controller: * - retrieves and persists the model via the todoStorage service * - exposes the model to the template and provides event handlers */angular.module('todomvc') .controller('TodoCtrl', function TodoCtrl($scope, $routeParams, $filter, store) &#123; 'use strict'; var todos = $scope.todos = store.todos; // 从localStorge中取出所有todo $scope.newTodo = ''; // 用来保存新创建的todo $scope.editedTodo = null; // 用来保存编辑过的todo $scope.$watch('todos', function() &#123; // 深度观察todos的值 $scope.remainingCount = $filter('filter')(todos, &#123; completed: false &#125;).length; // 更新未完成的todo数量 $scope.completedCount = todos.length - $scope.remainingCount; // 更新完成的todo数量 $scope.allChecked = !$scope.remainingCount; // 是否全部完成 &#125;, true); // Monitor the current route for changes and adjust the filter accordingly. $scope.$on('$routeChangeSuccess', function() &#123; // 观察路由跳转，并更新用来过滤的statusFilter var status = $scope.status = $routeParams.status || ''; $scope.statusFilter = (status === 'active') ? &#123; completed: false &#125; : (status === 'completed') ? &#123; completed: true &#125; : &#123;&#125;; &#125;); $scope.addTodo = function() &#123; // 输入框提交时触发 var newTodo = &#123; // 创建新todo title: $scope.newTodo.trim(), //newTodo是绑定在input输入框上 completed: false &#125;; if (!newTodo.title) &#123; // 空值，则不提交 return; &#125; $scope.saving = true; // saving用来标识input的禁用状态，为true则禁用 store.insert(newTodo) // 插入新todo .then(function success() &#123; // 成功则重置newTodo $scope.newTodo = ''; &#125;) .finally(function() &#123; $scope.saving = false; // 最后取消input的禁用状态 &#125;); &#125;; $scope.editTodo = function(todo) &#123; // 已添加的todo上双击时触发，会将双击的todo传入 $scope.editedTodo = todo; // 保存正在编辑的todo // Clone the original todo to restore it on demand. $scope.originalTodo = angular.extend(&#123;&#125;, todo); // 保留原先的todo，以备不时之需 &#125;; $scope.saveEdits = function(todo, event) &#123; // 再编辑input提交或者blur时触发 // Blur events are automatically triggered after the form submit event. // This does some unfortunate logic handling to prevent saving twice. if (event === 'blur' &amp;&amp; $scope.saveEvent === 'submit') &#123; // 提交时，会自动触发一次blur，所以手动阻止 $scope.saveEvent = null; return; &#125; $scope.saveEvent = event; // 保存事件类型(blur或submit) if ($scope.reverted) &#123; // 如果编辑后按esc，取消了编辑，则不保存 // Todo edits were reverted-- don't save. $scope.reverted = null; return; &#125; todo.title = todo.title.trim(); // 保存新编辑title if (todo.title === $scope.originalTodo.title) &#123; // title未发生改变，则不保存 $scope.editedTodo = null; return; &#125; store[todo.title ? 'put' : 'delete'](todo) .then(function success() &#123;&#125;, function error() &#123; // 保存出错，则恢复title todo.title = $scope.originalTodo.title; &#125;) .finally(function() &#123; // 最后，重置editedTodo $scope.editedTodo = null; &#125;); &#125;; $scope.revertEdits = function(todo) &#123; // todoEscape时触发，将再编辑input恢复到编辑前的状态，会传入需要恢复的todo todos[todos.indexOf(todo)] = $scope.originalTodo; $scope.editedTodo = null; $scope.originalTodo = null; $scope.reverted = true; &#125;; $scope.removeTodo = function(todo) &#123; // 删除todo store.delete(todo); &#125;; $scope.saveTodo = function(todo) &#123; // 保存todo store.put(todo); &#125;; $scope.toggleCompleted = function(todo, completed) &#123; // 切换完成状态 if (angular.isDefined(completed)) &#123; // 如果completed曾经定义过，则直接使用 todo.completed = completed; &#125; // 更新localStorge上的todo的complete store.put(todo, todos.indexOf(todo)) .then(function success() &#123;&#125;, function error() &#123; // 保存出错，则恢复 todo.completed = !todo.completed; &#125;); &#125;; $scope.clearCompletedTodos = function() &#123; // 清除所有已经完成的todo store.clearCompleted(); &#125;; $scope.markAll = function(completed) &#123; // 将所有todo置为已完成 todos.forEach(function(todo) &#123; if (todo.completed !== completed) &#123; $scope.toggleCompleted(todo, completed); &#125; &#125;); &#125;; &#125;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Maintainable-Javascript]]></title>
      <url>%2F2017%2F06%2F30%2FMaintainable-Javascript%2F</url>
      <content type="text"><![CDATA[本文为阅读《编写可维护的Javascript》的笔记，记录了一些个人认为重要的点，带有一定个人理解，并未深入展开，如需详细了解可阅读原书籍。这本书，是从可维护性的角度出发，介绍了如何编写可维护性的js代码，读完，还是有收获的，特别是第二部分的编程实践，很基础，但也很实用。综合来看，还是一本不错的书籍，值得一看。PS:本书主要从可维护性的角度出发，有些写法并不一定是最优解，因人而异，取其精华，去其糟粕。本人github上有很多本人学习前端时保存的demo，都带有注释，适合新手入门。如果对大家有帮助。望star~https://github.com/BryanAdamss/SourceSave 《编写可维护的Javascript》笔记编程风格基本格式化 代码缩进 使用4空格代替tab；不同编辑器对于tab的解释不一样，有的是2空格长度，有的是4空格长度； 语句结尾 总是使用分号;结尾 行的长度 单行不超过80个字符 空行 使用空行分隔语义不同的代码段 命名 驼峰命名法 变量 名词开头-&gt;count、myName 函数 动词开头-&gt;(can、has、is、get、set)isEnabled、getName 构造函数 首字母大写123function Person(name)&#123; this.name=name;&#125; 常量 全大写，下划线区分12var MAX_COUNT=10, URL='https://github.com/BryanAdamss/SourceSave'; 直接量 字符串-&gt;单双引号皆可，不过个人推荐用单引号，因为在拼接html字符串时很方便) 数字-&gt;不省略小数点前后的数字 null-&gt;当做对象占位符使用 undefined-&gt;已声明但没有赋值的变量会获得此值 对象直接量 1234567// 不好的写法var book=new Object();book.title='Javascript';// 好的写法var book=&#123; title:'Javascript'&#125;; 数组直接量 1234// 不好的写法var colors=new Array('red','green');// 好的写法var colors=['red','green']; 注释 只在需要注释的时候才添加注释-&gt;只在需要让代码变得更清晰的时候添加注释 逻辑复杂难于理解的代码 可能被误认为错误的代码 语句和表达式 switch语句 js中的switch不同于其他语言，switch的条件和case从句可以是任意类型值，其他语言必须是原始值或者常量 with语句-&gt;不要使用 循环 for-&gt;在初始化中缓存遍历次数 123for(var i=0,len=arr.length;i&lt;len;i++)&#123; doSth();&#125; for-in-&gt;配合hasOwnProperty过滤非实例属性/方法 123456for(var prop in testObj)&#123; if(testObj.hasOwnProperty(prop))&#123; console.log('属性名为:'+prop); console.log('属性名对应的属性值为:'+testObj[prop]); &#125;&#125; forEach-&gt;针对数组用forEach 总结:对象(除数组)用for-in，数组用forEach，其他用for 变量、函数和运算符 变量声明 单var声明 123var a=3, b=4, c=5; 将局部变量的定义做为函数内第一条语句 1234567891011121314151617181920 function getName()&#123; var a=3, b=4, c=5; &#125; ``` - 函数声明 - 先声明再使用 - 函数内声明函数时，可将函数声明放在变量生命之后 ```javascript function getName()&#123; var a=3, b=4, c=5; function getOtherName()&#123; doSth(); &#125; getOtherName(); &#125; 立即调用函数 使用圆括号包裹123var a=(function()&#123; doSth();&#125;)(); 严格模式-&gt;只在局部使用 相等-&gt;使用=== eval-&gt;避免使用 原始包装类型-&gt;避免使用原始包装类型构造函数 编程实践UI层的松耦合 将javascript从css中抽离 禁用css表达式1234/*不好的写法*/.box&#123; width:expression(document.body.offsetWidth+"px");&#125; 将css从javascript中抽离 用js控制样式类，而不是直接操纵样式 当需要控制元素位置时，可直接用js操纵样式(top,left…) 将javascript从HTML中抽离 不要在html标签上用onclick=…，改用事件addEventListener 将HTML从javascript中抽离 使用客户端模板引擎，例如handlebars 避免使用全局变量 全局变量带来的问题 命名冲突 代码脆弱性 难以测试 意外的全局变量 未声明直接赋值了 12345function ()&#123; var a=3;// 局部变量 var b;// 局部变量 c=3;// 全局变量&#125; 如何避免 总是使用var来声明变量，即时是声明全局变量 单全局变量 只声明一个全局变量，所有功能全挂载到这个全局变量上 模块 规范CommonJs、AMD、CMD 对应实现NodeJs、RequireJs、SeaJs 零全局变量 使用立即函数包裹123(function(win)&#123; // doSth&#125;)(window); 事件处理 不好的写法 1234567function handleClick(event)&#123; var popup=document.getElementById('popup'); popup.style.left=event.clientX+'px'; popup.style.top=event.clientY+'px'; popup.className='reveal';&#125;ele.addEventListener('click',handleClick,false); 事件处理规则1 隔离应用逻辑-&gt;将应用(业务)逻辑从事件处理程序中抽离 1234567891011121314var MyApp=&#123; handleClick:function(event)&#123; this.showPopup(event); &#125;, showPopup:function(event)&#123; var popup=document.getElementById('popup'); popup.style.left=event.clientX+'px'; popup.style.top=event.clientY+'px'; popup.className='reveal'; &#125;&#125;;ele.addEventListener('click',function(event)&#123; MyApp.handleClick(event);&#125;,false); 不要分发事件对象-&gt;只传需要的信息 应用逻辑不应当依赖于event对象来正确完成功能 将event对象做为参数并不能告诉你event的哪些属性是有用的 测试时，需要重建event对象 最佳实践 让事件处理程序使用event对象来处理事件，然后拿到需要的数据传给应用逻辑 1234567891011121314var MyApp=&#123; handleClick:function(event)&#123; this.showPopup(event.clientX,event.clientY);// 只传需要的信息 &#125;, showPopup:function(x,y)&#123; var popup=document.getElementById('popup'); popup.style.left=x+'px'; popup.style.top=y+'px'; popup.className='reveal'; &#125;&#125;;ele.addEventListener('click',function(event)&#123; MyApp.handleClick(event);&#125;,false); 让事件处理程序成为接触到event对象的唯一的函数，事件处理程序应当在进入应用逻辑之前针对event对象执行任何必要的操作。包括阻止默认事件和冒泡。 12345678910111213141516var MyApp=&#123; handleClick:function(event)&#123;// 在事件处理程序中针对event进行必要的处理 event.preventDefault(); event.stopPropagation(); this.showPopup(event.clientX,event.clientY);// 只传需要的信息 &#125;, showPopup:function(x,y)&#123; var popup=document.getElementById('popup'); popup.style.left=x+'px'; popup.style.top=y+'px'; popup.className='reveal'; &#125;&#125;;ele.addEventListener('click',function(event)&#123; MyApp.handleClick(event);&#125;,false); 避免空比较 检测原始值的类型 字符串、数字、布尔、undefined-&gt;typeof 1234typeof 'a';// 'string'typeof 3;// 'number'typeof true;// 'boolean'typeof undefined;// 'undefined' null-&gt;一般不用于类型检测，除非null是一种可预期的页面时可用===和!==来判断是否为null值 1234var ele=document.getElementById('my-div');if(ele!==null)&#123;// 如果DOM元素不存在，则ele就为null，此时null是一个可预期的值，所以可以===或!==来判断 // doSth &#125; 检测引用值的类型 使用value instanceof constructor 123456789if(value instance Data)&#123; // doSth&#125;if(value instance RegExp)&#123; // doSth&#125;if(value instance Object)&#123; // doSth &#125; 但函数、数组不能用instanceof来判断，因为存在跨帧问题(cross-frame) 检测函数(判断某一引用值是否是函数(是否是函数类型)) 使用typeof 12function myFn()&#123;&#125;typeof myFn;// 'function' 使用typeof检测IE8及以下DOM元素的方法时，会返回’object’;退而求其次会使用in来判断；因为DOM明确定义，了解到对象成员如果存在则意味着它是一个方法 123if('querySelectorAll' in document)&#123; var imgs=document.querySelectorAll('img');&#125; 检测数组(判断某一引用值是否是数组(是否是数组类型)) 使用ES5的isArray 不支持的则使用Object.prototype.toString.call(value)1234567function isArray(value)&#123; if(typeof Array.isArray==='function')&#123; return Array.isArray(value); &#125;else&#123; return Object.prototype.toString.call(value)==='[object Array]'; &#125;&#125; 检测属性/方法存在性 使用prop in obj 检测属性/方法是否为实例属性-&gt;obj.hasOwnProperty(‘prop’) IE8及以下判断是否为实例属性-&gt;需先判断hasOwnProperty的存在性 总结 判断数据类型 原始值 字符串、数字、布尔、undefined-&gt;typeof 如if(typeof &#39;test&#39;===&#39;string&#39;){...} null-&gt;只有在null是一个可预期的值时，才用来比较，使用===，!== 引用值 自定义、非函数、非数组对象-&gt;使用obj instanceof constructor 如obj instanceof Data 函数/方法 非DOM对象的方法/函数-&gt;typeof 如typeof myFn===&#39;function&#39; DOM对象的方法-&gt;无法使用typeof，只能通过in判断它存在，然后直接使用 数组 支持isArray-&gt;Array.isArray(value) 不支持-&gt;Object.prototype.toString.call(value)===&#39;[object Array]&#39; 判断属性/方法存在性 一般属性/方法-&gt;统一使用in 实例属性存在性-&gt;统一使用hasOwnProperty IE8及以下判断实例属性存在性-&gt;先判断hasOwnProperty的存在性，再调用hasOwnProperty 将配置数据从代码中抽离 配置数据 URL 展现给用户的字符串 重复的值 设置(每页的配置项) 任何可能发生变更的值 抽离 将配置数据抽离成一个对象 1234var config=&#123; MSG_INVALID_VALUE:'不合法的值', URL:'https://github.com/BryanAdamss/SourceSave'&#125;; 将配置数据抽离成一个对象，并放在一个单独的文件中 抛出自定义错误 如果没有通过try-catch语句捕获，抛出任何值都将引发一个错误。如直接throw &#39;message&#39;，会引发一个错误 何时抛出错误 抛出错误最佳的地方是在工具函数中，如addClass()函数，它是通用脚本的一部分，会在很多地方使用。-&gt;在javascript类库中使用 错误类型 Error、EvalError、RangeError、ReferenceError、SyntaxError、TypeError、URIError 不是你的对象不要动 不要修改原生对象以及一些类库对象 原则：将已经存在的js对象当做工具函数库那样使用 不覆盖方法 不覆盖原对象的方法 不新增方法 不在不属于你的对象上添加方法 不删除方法 不要删除一个不是你的对象上的方法 更好方法 继承原对象，在其基础上扩充 阻止修改(锁定后，将无法解锁) 防止扩展-&gt;无法新增属性和方法，可删除 Object.preventExtension(obj); Object.isExtensible(); 密封对象-&gt;已存在的属性、方法无法被删除，可修改 Object.seal(obj); Object.isSealed(); 冻结对象-&gt;防止扩展+密封，无法删除，无法修改 Object.freeze(obj); Object.isFrozen(); 浏览器嗅探 UA检测 缺点 UA可以被修改 浏览器为了兼容性，都会包含其他浏览器的UA字符串 特性检测-&gt;根据功能(特性)来检测 不要进行特性推断-&gt;不要根据一个特性的是否存在去推断另一个特性是否存在 不要进行浏览器推断-&gt;不要根据一个特性的是否存在去推断是某种浏览器 优先级:特性检测&gt;UA检测 自动化文章第三部分介绍的是前端自动化方面的知识，但用的是Ant(需要JAVA环境)，由于现在用gulp的比较多，所以这一块就只是大概扫了一下。 流程 构建-&gt;验证-&gt;合并、加工-&gt;精简、压缩-&gt;文档化-&gt;自动化测试-&gt;集成]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Angualr-guide]]></title>
      <url>%2F2017%2F06%2F07%2FAngualr-guide%2F</url>
      <content type="text"><![CDATA[本文为自己学习angular的笔记，带有个人理解。学习的版本为1.2.32对应的源码在https://github.com/BryanAdamss/SourceSave/tree/master/AngularJs本仓库还包含大量本人前端练习用的demo，希望对大家有帮助。望star~ Angular学习笔记Angular适用场景 适合：大量CRUD(增删改查)操作的场景，如后台管理系统 不适合：游戏、大量UI操作的场景 DataBinding 双向：view、model之间会相互同步数据 Controller 在controller中做 设置$scope的初始状态 为$scope添加一些行为 不要在controller中做 手动操作DOM：controller中应该仅包含业务逻辑；如果在controller中添加表现相关逻辑，会严重影响测试；DOM操作应该封装在directives中；另外AngularJs中也封装了一些常用DOM操作指令，如ng-show等。 格式化输入： Use AngularJS form controls instead. 过滤输出： Use AngularJS filters instead. 传递数据或状态： Use AngularJS services instead. 管理其他组件的周期：例如在controller中创建services Services 特点 lazy实例化：只有当某个services被依赖时，它才会被实例化 单例：每个依赖services的component都会得到由service factory产生的service单实例的一个引用（service都是单例的，只要创建了一个Service，那么程序都在使用这唯一的Service) 以$开头的，都是内置服务，eg：$http service可以被用来传递数据、实现代码复用 创建并使用：通过service工厂函数来创建（factory函数）123456789101112131415 angular.module('myServiceModule', []). controller('MyController', ['$scope', 'notify', function($scope, notifyInstance) &#123;//3.这里notyfy被依赖，所以立马被实例化并将2处的匿名函数赋值给了notifyInstance $scope.callNotify = function(msg) &#123; notifyInstance (msg); &#125;; &#125;]).factory('notify', ['$window', function(win) &#123;// 1.这里注册了一个notify的服务，而且还依赖另一个内置服务$winodw，注意这里还只是注册一个notify的构造函数，并没有创建notify的实例 var msgs = []; return function(msg) &#123;// 2.return里的是当服务被加载(依赖时)返回的实例对象或函数 msgs.push(msg); if (msgs.length === 3) &#123; win.alert(msgs.join('\n')); msgs = []; &#125; &#125;; &#125;]); Scope 特点 它只是一个普通的js对象 它指向了应用的model 它是表达式的执行环境context 它拥有和DOM一样的树形结构 它能监视表达式 它能传播事件 它提供了$watch来观察模型的变化 它提供了$apply来传播模型的变化 它可以嵌套以限制对应用程序组件属性的访问，同时提供对共享模型属性的访问。 它是controller和view间的胶水 层次结构（类似DOM的树形结构） 每个angularApp都有一个根scope，$rootScope，$rootScope有一个或多个子scope 查找某属性时，会像js作用域一样，逐层向上找 angularJs会在每个绑定了scope元素的class上添加ng-scope directive可以创建scope 获取DOM元素上绑定的scope 可以通过angular.element(dom元素).scope() 在chrome中，也可以通过 angular.element($0).scope()或者在选中一个dom元素后直接在控制台中$scope，就能得到相应dom上的$scope 可以通过安装 AngularJS Batarang插件来查看 事件传播 $emit(eventName) 向上传播事件 $broadcast(eventName) 向下传播事件 生命周期： Creation-&gt; Watcher registration-&gt; Model mutation-&gt; Mutation observation-&gt; Scope destruction DependencyInjection(DI) 使用 services、directives、filter、animation可以将”services”、”value”型组件作为依赖注入 123456789angular.module('myModule', []).factory('serviceId', ['depService', function(depService) &#123; // ...&#125;]).directive('directiveName', ['depService', function(depService) &#123; // ...&#125;]).filter('filterName', ['depService', function(depService) &#123; // ...&#125;]); controller可以将”services”、”value”型组件作为依赖注入，但他们还可以注入一些特殊的依赖如$scope 1234567someModule.controller('MyController', ['$scope', 'dep1', 'dep2', function($scope, dep1, dep2) &#123;...$scope.aMethod = function() &#123;...&#125;...&#125;]); 为module提供run、config方法时，可以使用DI config接收一个函数，函数可以注入”provider”、”constant”型组件；不可将”services”、”value”型注入到config中 run接收一个函数，函数可以注入”services”、”value”以及”constant”(常数)型组件；不可将”providers”型注入到run中12345angular.module('myModule', []).config(['depProvider', function(depProvider) &#123;// ...&#125;]).run(['depService', function(depService) &#123;// ...&#125;]); 依赖声明 行内数组声明(推荐、最优) 123someModule.controller('MyController', ['$scope', 'greeter', function($scope, greeter) &#123;// ...&#125;]); 使用$inject(可让controller通过js压缩) 12345var MyController = function($scope, greeter) &#123;// ...&#125;MyController.$inject = ['$scope', 'greeter'];someModule.controller('MyController', MyController); 隐式声明依赖(压缩时，会出错)-&gt;尽量避免用此方法 123someModule.controller('MyController', function($scope, greeter) &#123;// ...&#125;); 通过在ng-app指令所在html元素上添加 ng-strict-di指令，以限制隐式声明的使用(若使用隐式声明 ，会报错) Templates angularJS中的template是由html以及angularJs声明的元素及特性组成。angularJs通过controller组合model中的信息和模板以呈现动态的view给用户 templates中可以使用 directive {{}} filter form controller 1234567891011&lt;html ng-app&gt; &lt;!-- Body tag augmented with ngController directive --&gt; &lt;body ng-controller="MyController"&gt; &lt;input ng-model="foo" value="bar"&gt; &lt;!-- Button tag with ngClick directive, and string expression 'buttonText' wrapped in "&#123;&#123; &#125;&#125;" markup --&gt; &lt;button ng-click="changeFoo()"&gt;&#123;&#123;buttonText&#125;&#125;&lt;/button&gt; &lt;script src="angular.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 在复杂的app中,可以将不同的模板放在单独的html中，然后通过ng-view来引用 Expressions 主要用在插值绑定(interpolation bindings)中，但也可以直接用在指令中；如ng-click=”functionExpression()”；以下都是合法的 1+2 a+b user.name items[index] 和Js的表达式的异同 context：js中的context一般是全局变量window；angular中表达式的context则是scope js中尝试计算未定义的属性，会报错；angular则不会直接报错，而是转为undefined或null 在angular表达式中可以用filter在展示数据前进行数据格式化 在angular的表达式中没有条件控制相关语句；如if、for等，但三元操作符中可以用 在angular的表达式中不能有函数声明，及时在ng-init指令中 在angular的表达式中不能创建正则表达式 在angular的表达式中不能通过new创建对象 在angular的表达式中不能使用位运算、void、逗号等操作符 如果想解析angularJs表达式，不要用eval，使用$eval 总结：如果想使用复杂js代码，可以将其封装在controller中，然后在view中调用。不推荐直接在表达式中书写大量代码； $event 在执行ng-click、ng-focus等指令时，会在表达式范围内将$event暴露出来，$event是类似jquery Event的对象 one-time绑定(数据只绑定一次) 优势：只绑定一次，可减少监视次数 使用：在变量前添加双冒号；类似{{::name}} 何时( 当表达式被设定后，就不会被改变时 ) 用在插值文本和特性时 1&lt;div name="attr: &#123;&#123;::color&#125;&#125;"&gt;text: &#123;&#123;::name | uppercase&#125;&#125;&lt;/div&gt; 当用directive双向绑定数据并且参数不会改变时 1234567891011someModule.directive('someDirective', function() &#123; return &#123; scope: &#123; name: '=', color: '@' &#125;, template: '&#123;&#123;name&#125;&#125;: &#123;&#123;color&#125;&#125;' &#125;;&#125;);&lt;div some-directive name="::myName" color="My color is &#123;&#123;::myColor&#125;&#125;"&gt;&lt;/div&gt; 指令中包含表达式时 123&lt;ul&gt; &lt;li ng-repeat="item in ::items | orderBy:'name'"&gt;&#123;&#123;item.name&#125;&#125;;&lt;/li&gt;&lt;/ul&gt; Interpolation 针对布尔attr，如disabled、required、selected、checked、readOnly、open，不要使用原生的，使用ng-disabled、ng-required… 使用ng-attr-xxx绑定任意特性，如ng-attr-cx；若为驼峰形式，则用下划线代替，如viewBox，则使用ng-attr-view_box Filters 在view中的语法 正常语法 1&#123;&#123; expression | filterName &#125;&#125; Filter Chain-&gt;用上一个filter的输出作为下一个filter的输入 1&#123;&#123; expression | filter1Name | filter2Name | ... &#125;&#125; 带参数 12&#123;&#123; expression | filterName:argument1:argument2:... &#125;&#125;如 &#123;&#123; 1234 | number:2 &#125;&#125; 当filter用在controller、services、directives上时，需采用Filter形式 需要在controller中使用number过滤器时1234angular.module('numberFilterExample', []).controller('ExampleController', ['numberFilter', function(numFilter) &#123; // ....&#125;]); 创建自定义filter 使用filter函数123456789101112angular.module('myReverseFilterApp', []).filter('reverse', function() &#123; return function(input) &#123;// return 一个函数 input = input || ''; var out = ''; for (var i = 0; i &lt; input.length; i++) &#123; out = input.charAt(i) + out; &#125; return out; &#125;;&#125;)// html中直接&#123;&#123; data | reverse&#125;&#125; 常用filter date日期格式-&gt; {{ now | date:'yyyy-MM-dd hh:mm:ss a' }} currency货币格式化 fiter对数组、字符串、对象等进行筛选显示 1234567891011$scope.city = [&#123; id: "001", name: "上海" &#125;, &#123; id: "002", name: "北京"&#125;];// view &#123;&#123;city&#125;&#125; &#123;&#123;city|filter:'上海'&#125;&#125;// 默认筛选出所有value值为'上海'的object &#123;&#123;city|filter:&#123;name:'北京'&#125; &#125;&#125;// 筛选出name为北京的object orderBy排序 {{city |orderBy:'id'}} 默认正序 {{city |orderBy:'-id'}} 反序 json 将对象解析成json，主要用来调试 Forms angularJs对表单域做了增强，添加了很多功能 使用ng-model就可以将表单的值和model进行双向绑定 使用novalidate屏蔽浏览器原生验证 angualrJs会添加一些class类，来标识验证的状态，根据这些验证状态class类，来写不同的样式 ng-valid：model验证通过 ng-invalid：model未验证通过 ng-valid-[ruleName]：ruleName的验证规则已通过 ng-invalid-[ruleName ]：ruleName的验证规则未通过 ng-pristine：这个表单域还没有交互过(未修改过) ng-dirty：这个表单域已经交互过(修改过) ng-touched：这个表单域 失去焦点 ng-untouched：这个表单域未失去焦点 ng-pending：异步验证还未完成 可以根据表单验证的一些状态，来辅助添加帮助信息 通过ng-model-options来设置一些属性 ng-model-options=”{ updateOn: ‘blur’ }” 在blur时更新model 延时更新model ng-model-options=”{ debounce: 500 }” ng-model-options=”{ updateOn: ‘default blur’, debounce: { default: 500, blur: 0 } }” 可通过编写directive来创建自己的验证规则、表单域 可以修改内置的验证规则 相关状态 字段错误信息-&gt;formName.fieldName.$error-&gt;验证通过的规则会显示false，未通过的显示true 字段无效信息-&gt;formName.fieldName.$invalid 字段有效信息-&gt;formName.fieldName.$valid 字段是否更改-&gt;formName.fieldName.$dirty 字段是否未更改-&gt;formName.fieldName.$pristine $scope.formName.$setPristine-&gt;将表单恢复到最初状态，class、$dirty等都被恢复 Directives 匹配 12345678&lt;div ng-controller="Controller"&gt;&lt;!-- 下面这几种形式，都将input和model中name绑定起来了，绑定这个指令就匹配上了 --&gt; Hello &lt;input ng-model='name'&gt; &lt;hr/&gt;&lt;!-- 建议形式 --&gt; &lt;span ng-bind="name"&gt;&lt;/span&gt; &lt;br/&gt;&lt;!-- 建议形式 --&gt; &lt;span ng:bind="name"&gt;&lt;/span&gt; &lt;br/&gt; &lt;span ng_bind="name"&gt;&lt;/span&gt; &lt;br/&gt; &lt;span data-ng-bind="name"&gt;&lt;/span&gt; &lt;br/&gt; &lt;span x-ng-bind="name"&gt;&lt;/span&gt; &lt;br/&gt;&lt;/div&gt; ng-attr-xxx-&gt;所有ng-attr开头的特性，最后都会转化到原生的特性上，建议不要在原生的特性上绑定值，都用ng-attr开头(因为某些原生特性和ng配合的不好) 123&lt;svg&gt; &lt;circle ng-attr-cx="&#123;&#123;cx&#125;&#125;"&gt;&lt;/circle&gt;&lt;!-- 将&#123;&#123;cx&#125;&#125;绑定到了原生的cx上 --&gt;&lt;/svg&gt; 指令类型 A（attribute）、E（element）、M（comment）、C（class）;M和C不常用，如果需要兼容IE8，建议全部用A 1234&lt;my-dir&gt;&lt;/my-dir&gt;&lt;span my-dir="exp"&gt;&lt;/span&gt;&lt;!-- directive: my-dir exp --&gt;&lt;span class="my-dir: exp;"&gt;&lt;/span&gt; 注意：由于历史原因，浏览器在解析html标签和标签attribute时，会自动忽略大小写，统一使用小写形式；这就导致了，用驼峰形式定义的html标签（&lt;myTag&gt;）和特性会被转换为全小写（&lt;mytag&gt;）；那么用驼峰形式定义的指令在匹配E和A时，就找不到（无法匹配），为了解决这问题，ng会在定义时用的驼峰形式directive(“myTag”,xxx)转换成my-tag，这样在html中my-tag形式的标签和特性就会被匹配到。如果定义时没用驼峰形式(全小写)，则不会转换，直接匹配。驼峰形式的指令名在匹配M和C时不会存在转换-&gt;总结:在定义指令时如果用了驼峰形式匹配EA，则在html中使用时就要转换成短横线连接的形式如myTag转换成my-tag-&gt;最佳实践：ng中指令若用驼峰则html中用短横线连接； 创建指令 module.directive(directiveName,fn); 12345678910angular.module('docsSimpleDirective', []).controller('Controller', ['$scope', function($scope) &#123; $scope.customer = &#123; name: 'Naomi', address: '1600 Amphitheatre' &#125;;&#125;]).directive('myCustomer', function() &#123; return &#123;// 尽量都返回一个object，不要只返回一个函数 template: 'Name: &#123;&#123;customer.name&#125;&#125; Address: &#123;&#123;customer.address&#125;&#125;' // 除非你的模板很小，否则使用templateUrl来引入外部单独的模板html文件 &#125;;&#125;); templateUrl-&gt;除非你的模板很小，否则使用templateUrl来引入外部单独的模板html文件 当replace为true时，tpl文件内容必须被包裹在一个标签内，也即tpl文件只能有一个根标签；即不能存在有文本未被标签包裹，也不能存在多个根标签；因为替换的时候ng找不到一个唯一的节点做为替换节点，所以必须得有一个最外层的根节点；template也存在同样情况-&gt;最佳实践，任何情况下，都让模板文件包裹在一个根标签中，这样也方便文件的组织管理 可以在模板中使用$scope中的变量 templateUrl中可以指定type=text/ng-template的script为模板，只需要在templateUrl中写上script模板的id；注意：这个script模板必须在ng-app中，而且，若replact为true，则也需要一个根标签1234567891011angular.module('docsTemplateUrlDirective', []).controller('Controller', ['$scope', function($scope) &#123; $scope.customer = &#123; name: 'Naomi', address: '1600 Amphitheatre' &#125;;&#125;]).directive('myCustomer', function() &#123; return &#123; templateUrl: 'my-customer.html' &#125;;&#125;); restrict-&gt;设置指令的匹配模式(AEMC)；默认是AE（匹配attribute、element类型指令)；M和C不常用 123456789101112131415angular.module('docsRestrictDirective', []).controller('Controller', ['$scope', function($scope) &#123; $scope.customer = &#123; name: 'Naomi', address: '1600 Amphitheatre' &#125;;&#125;]).directive('myCustomer', function() &#123; return &#123; restrict: 'E', templateUrl: 'my-customer.html' &#125;;&#125;);// 什么情况下该用元素名，什么情况下该用属性名？ 当创建一个含有自己模板的组件的时候，建议使用元素名，常见情况是，当你想为你的模板创建一个DSL（特定领域语言）的时候。如果仅仅想为已有的元素添加功能，建议使用属性名.// 当需要创建一个自己的组件时-&gt;创建E型指令// 为已有元素添加新功能-&gt;创建A型指令 isolate scope 存在原因：若无独立作用域，则在一个作用域下，多个指令无法独立执行；使用独立作用域，可以将指令限制在独立的作用域下执行，互不干扰 创建：在创建directive时指定scope属性 1234567891011angular.module('docsIsolateScopeDirective', []).controller('Controller', ['$scope', function($scope) &#123; $scope.naomi = &#123; name: 'Naomi', address: '1600 Amphitheatre' &#125;; $scope.igor = &#123; name: 'Igor', address: '123 Somewhere' &#125;;&#125;]).directive('myCustomer', function() &#123; return &#123; restrict: 'E', scope: &#123; customerInfo: '=info' // 将customerInfo绑定到指令所在元素的info特性上，如果外面的特性也叫customerInfo，则可以直接使用缩写形式"=" &#125;, templateUrl: 'my-customer-iso.html' &#125;;&#125;); 独立作用域会隔离除你添加到scope: {} 对象中的数据模型之外的一切东西。 因为它可以阻止除你传入的数据模型之外的一切东西改变你内部数据模型的状态。 如果要使你的组件在应用范围内可重用，那么使用scope选项去创建一个独立作用域1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;!DOCTYPE html&gt;&lt;html lang="en" ng-app="myApp"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div ng-controller="myController"&gt; &#123;&#123;books&#125;&#125; &lt;div book-list book-a="books" book-b="books" book-c="&#123;&#123;title&#125;&#125;"&gt;&lt;/div&gt; &lt;/div&gt; &lt;script type="text/javascript" src="js/angularjs.js"&gt;&lt;/script&gt; &lt;script&gt; angular.module('myApp', []).directive("bookList", function() &#123; return &#123; restrict: "EAMC", template: '&lt;div&gt;&lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt;&lt;ul&gt;&lt;li ng-repeat="book in books"&gt;&#123;&#123;book.name&#125;&#125;&lt;/li&gt;&lt;/ul&gt; &lt;/div&gt;', // bookList指令中包含一个booAdd指令 replace: true, // scope: false,// scope为独立作用域，当为false，表示直接使用父级作用域，为true，表示创建一个作用域并继承自父作用域；当scope为一个对象时，则表示创建了一个不继承父作用域的继承链的独立作用域(就是可以访问到父作用域，但是无法访问到父作用域之上的作用域) scope: &#123; // &amp;attr表示作用域将父作用域的属性包装成一个函数，从而以函数的形式读写父作用域的属性；一般用在执行父作用域上的某个事件处理函数；若作用域和父作用域的属性名称一要，则可以使用简写形式&amp;,@和=同理 a: "&amp;bookA" // 会查找当前指令匹配的元素上的bookA特性，然后取得值books，并将books做为a调用的返回值进行返回； // =attr会将作用域上的属性和父级的作用域上的属性进行双向绑定，任何一方的修改都会修改另外一方 // b: "=bookB" // 会查找当前指令匹配的元素上的bookB特性，会将其值和b进行双向绑定 // @attr代表只能读取父级作用域上的值，单向的，并只能读取简单值，引用值不行，因为他最终得到的只会是简单值； // c: "@bookC" &#125;, controller: function($scope) &#123; $scope.books = $scope.a(); console.log($scope.a()); // $scope.books = $scope.b; // $scope.b.push(&#123; // name: "nodeJs" // &#125;); // console.log($scope.b); // $scope.title = $scope.c; // console.log($scope.c); &#125;, &#125; &#125;).controller('myController', ['$scope', function($scope) &#123; $scope.books = [&#123; name: "php" &#125;, &#123; name: "js" &#125;, &#123; name: "java" &#125;]; $scope.title = "书籍"; &#125;]); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; compile 主要用在DOM渲染之前( link之前) 改变DOM结构，并不需要$scope参数。它必须返回一个link函数，因此如果指令中compile和link都写了，则link会被覆盖-&gt;用的比较少123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;!DOCTYPE html&gt;&lt;html lang="en" ng-app="myApp"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div ng-controller="myController"&gt; &lt;div ng-repeat="user in users" my-tag my-tag2&gt;&lt;/div&gt; &lt;/div&gt; &lt;script type="text/javascript" src="js/angularjs.js"&gt;&lt;/script&gt; &lt;script&gt; angular.module('myApp', []).directive('myTag', function() &#123; return &#123; restrict: "EAMC", template: '&lt;div&gt;&#123;&#123;user.name&#125;&#125;&lt;/div&gt;', replace: true, compile: function(tElement, tAttrs, transclude) &#123; // 主要用来在实际渲染之前修改DOM结构，compile必须返回一个link函数 // console.log(tElement); //返回匹配的当前类jQuery对象 // console.log(tAttrs); // 返回tElement上的所有attr // console.log(transclude); // 如果指令中transclue为true，则它返回的就是被transclude的原始数据 console.log("myTag 编译阶段"); // 在实际渲染前变更DOM结构 tElement.append(angular.element("&lt;h1&gt;test&lt;/h1&gt;")); return &#123; // 若在compile中直接return一个函数，则返回的是postLink函数 pre: function(scope, iElement, iAttrs, controller) &#123; // preLink是在compile阶段结束后，link阶段之前触发 console.log("myTag preLink"); &#125;, post: function(scope, iElement, iAttrs, controller) &#123; // postLink是指令link后触发 console.log("myTag postLink"); &#125; &#125; &#125;, link: function(scope, iElement, iAttrs, controller) &#123; // 主要在link中进行绑定事件和操纵DOM；一般定义了compile，就不会定义link了;此处的link其实就是compile中postLink console.log("因为上面执行了，compile，所以我不会再被执行了"); &#125; &#125; &#125;).directive('myTag2', function() &#123; return &#123; restrict: "EAMC", compile: function(tElement, tAttrs, transclude) &#123; console.log("myTag2 编译阶段"); return &#123; pre: function() &#123; console.log("myTag2 preLink"); &#125;, post: function() &#123; console.log("myTag2 postLink"); &#125; &#125; &#125; &#125; &#125;).controller("myController", ["$scope", function($scope) &#123; $scope.users = [&#123; id: 10, name: "张三" &#125;, &#123; id: 20, name: "李四" &#125;]; &#125;]); &lt;/script&gt;&lt;/body&gt; &lt;/html&gt; link 主要在这里来操作DOM和添加事件 scope-&gt;指令所处的作用域(如果有独立作用域，则为独立作用域，否则值为父级的作用域); element-&gt;指令所匹配的那个元素 attrs-&gt;指令匹配元素的所有特性的集合 controller-&gt;指令需要依赖的controller实例123456789101112131415161718192021222324252627282930angular.module('docsTimeDirective', []).controller('Controller', ['$scope', function($scope) &#123; $scope.format = 'M/d/yy h:mm:ss a';&#125;]).directive('myCurrentTime', ['$interval', 'dateFilter', function($interval, dateFilter) &#123; function link(scope, element, attrs) &#123; var format, timeoutId; function updateTime() &#123; element.text(dateFilter(new Date(), format)); &#125; scope.$watch(attrs.myCurrentTime, function(value) &#123; format = value; updateTime(); &#125;); element.on('$destroy', function() &#123; $interval.cancel(timeoutId); &#125;); // start the UI update process; save the timeoutId for canceling timeoutId = $interval(function() &#123; updateTime(); // update DOM &#125;, 1000); &#125; return &#123; link: link &#125;;&#125;]); replace-&gt;是否替换匹配的元素 若为true则在找到匹配的元素后，会用指令中的template内容替换匹配的内容(包括被匹配的元素)；默认情况下，指令会在找到匹配的元素时，会将匹配元素的内容替换为指令中template的内容； 一般在匹配E时，会选择将其设置为true，因为一般E型指令都是创建新标签，是不符合规范的，所以会选择将其替换 transclude-&gt;主要用来处理指令嵌套 默认情况下，指令会替换匹配元素内部的内容，这样就无法实现指令的相互嵌套使用(原指令的内容会被新指令全部替换掉)； 当设置transclude为true时，则可以保留原先的指令模板以及对应的作用域；注意，在新指令的模板中要用ng-transclude保留老指令的内容； 123456789101112// jsangular.module('docsTransclusionDirective', []).controller('Controller', ['$scope', function($scope) &#123; $scope.name = 'Tobias';&#125;]).directive('myDialog', function() &#123; return &#123; restrict: 'E', transclude: true, scope: &#123;&#125;, templateUrl: 'my-dialog.html' &#125;;&#125;);// my-dialog.html&lt;h1&gt;新内容&lt;/h1&gt;&lt;div class="alert" ng-transclude&gt;&lt;/div&gt; &lt;!-- 指定ng-transclude --&gt; 仅当你要创建一个包裹任意内容的指令的时候使用transclude: true 创建一个包裹任意内容的dialogBox 12345678910111213141516171819202122232425262728293031323334353637// jsangular.module('docsIsoFnBindExample', []).controller('Controller', ['$scope', '$timeout', function($scope, $timeout) &#123; $scope.name = 'Tobias'; $scope.message = ''; $scope.hideDialog = function(message) &#123; $scope.message = message; $scope.dialogIsHidden = true; $timeout(function() &#123; $scope.message = ''; $scope.dialogIsHidden = false; &#125;, 2000); &#125;;&#125;]).directive('myDialog', function() &#123; return &#123; restrict: 'E', transclude: true, scope: &#123; 'close': '&amp;onClose' // &amp;prop 用来绑定一个函数到独立作用域，允许独立作用域调用它，同时保留了函数的原来作用域；当你的指令想要开放一个API去绑定特定的行为，在scope选项中使用&amp;prop。 &#125;, templateUrl: 'my-dialog-close.html' &#125;;&#125;);// html&lt;div ng-controller="Controller"&gt; &#123;&#123;message&#125;&#125; &lt;my-dialog ng-hide="dialogIsHidden" on-close="hideDialog(message)"&gt; Check out the contents, &#123;&#123;name&#125;&#125;! &lt;/my-dialog&gt;&lt;/div&gt;// my-dialog-close.html&lt;div class="alert"&gt; &lt;a href class="close" ng-click="close(&#123;message: 'closing for now'&#125;)"&gt;&amp;times;&lt;/a&gt; &lt;div ng-transclude&gt;&lt;/div&gt; &lt;!-- 保留原先指令内容 --&gt;&lt;/div&gt; 创建添加事件的指令 12345678910111213141516171819202122232425262728293031323334353637angular.module('dragModule', []).directive('myDraggable', ['$document', function($document) &#123; return &#123; link: function(scope, element, attr) &#123; // 在link中为指令匹配的元素element绑定事件 var startX = 0, startY = 0, x = 0, y = 0; element.css(&#123; position: 'relative', border: '1px solid red', backgroundColor: 'lightgrey', cursor: 'pointer' &#125;); element.on('mousedown', function(event) &#123; // Prevent default dragging of selected content event.preventDefault(); startX = event.pageX - x; startY = event.pageY - y; $document.on('mousemove', mousemove); $document.on('mouseup', mouseup); &#125;); function mousemove(event) &#123; y = event.pageY - startY; x = event.pageX - startX; element.css(&#123; top: y + 'px', left: x + 'px' &#125;); &#125; function mouseup() &#123; $document.off('mousemove', mousemove); $document.off('mouseup', mouseup); &#125; &#125; &#125;;&#125;]); controller-&gt;指令中的controller属性可以用来完成指令间的相互通信 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// jsangular.module('docsTabsExample', []).directive('myTabs', function() &#123; return &#123; restrict: 'E', transclude: true, scope: &#123;&#125;, controller: ['$scope', function MyTabsController($scope) &#123; var panes = $scope.panes = []; $scope.select = function(pane) &#123; angular.forEach(panes, function(pane) &#123; pane.selected = false; &#125;); pane.selected = true; &#125;; this.addPane = function(pane) &#123;// 这个方法需要暴露给其他指令用 if (panes.length === 0) &#123; $scope.select(pane); &#125; panes.push(pane); &#125;; &#125;], templateUrl: 'my-tabs.html' &#125;;&#125;).directive('myPane', function() &#123; return &#123; require: '^^myTabs', // 依赖一个myTabs控制器，并在指令的父元素上查找这个控制器 restrict: 'E', transclude: true, scope: &#123; title: '@' // 相当于@title &#125;, link: function(scope, element, attrs, tabsCtrl) &#123; tabsCtrl.addPane(scope); &#125;, templateUrl: 'my-pane.html' &#125;;&#125;);// index.html&lt;my-tabs&gt; &lt;my-pane title="Hello"&gt; &lt;p&gt;Lorem ipsum dolor sit amet&lt;/p&gt; &lt;/my-pane&gt; &lt;my-pane title="World"&gt; &lt;em&gt;Mauris elementum elementum enim at suscipit.&lt;/em&gt; &lt;p&gt;&lt;a href ng-click="i = i + 1"&gt;counter: &#123;&#123;i || 0&#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;/my-pane&gt;&lt;/my-tabs&gt;// tabs&lt;div class="tabbable"&gt; &lt;ul class="nav nav-tabs"&gt; &lt;li ng-repeat="pane in panes" ng-class="&#123;active:pane.selected&#125;"&gt; &lt;a href="" ng-click="select(pane)"&gt;&#123;&#123;pane.title&#125;&#125;&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;div class="tab-content" ng-transclude&gt;&lt;/div&gt;&lt;/div&gt;// panel&lt;div class="tab-pane" ng-show="selected"&gt; &lt;h4&gt;&#123;&#123;title&#125;&#125;&lt;/h4&gt; &lt;div ng-transclude&gt;&lt;/div&gt;&lt;/div&gt; 当你想暴露一个API给其它的指令调用那就用controller,否则用link。 controllerAs-&gt;给指令中的controller起个别名，并可做controller中的第四个参数传入 priority-&gt;设置指令执行的优先级顺序(权重)；多个指令时，ng必须知道哪个先执行；默认ng-repeat优先级很高，为1000；-&gt;不常用 terminal-&gt;是否设置当前指令的权重priority 为结束界限；若为true，则节点上小于当前指令权重priority的指令不会被执行，相同权重的会执行 require-&gt;可以将其他指令传给自己，有以下值 directiveName-&gt;默认值，会从同一个元素上查找 ^directiveName-&gt;会在父级上查找 ?directiveName-&gt;表示指令是可选的，找不到也不会抛出异常 Animations 可参考https://css-tricks.com/animations-the-angular-way/ 无需引入任何模块，直接利用切换class配合css的过渡，来实现过渡动画-&gt;无法做到全兼容；-&gt;https://codepen.io/bdsimmons/pen/NqYjaV angualr中内置了$animate服务，可以提供简单的动画操作，enter、leave…-&gt;核心方法，ngAnimate模块也依赖这个核心服务 更强大的动画-&gt;引入ngAnimate模块；angualr没有直接包含动画模块(ngAnimate)，需要在引入angular.js后引入angular-animate.js 重点：ngAnimate动画的核心都是基于css，通过变换元素的class类配合过渡和animation进而实现动画，js动画除外 如何使用ngAnimate模块 整个app没有模块，则可以直接指定ng-app=”ngAnimate”来从ngAnimate模块启动app，也能有动画效果；-&gt;不推荐-&gt;http://www.runoob.com/try/try.php?filename=try_ng_animation 当做模块依赖来使用-&gt;var app=angular.module(“myApp”,[“ngAnimate”]); 当引入ngAnimate模块后，就会自动在一些指令执行的特殊时机，为元素添加上对应的class类，可以利用这个配合css实现动画 css过渡动画-&gt;需要设置动画的起点、终点的动画属性值；例如在.ng-enter上设置过渡动画初始值，在.ng-enter-active上设置过渡动画终点值-&gt;https://codepen.io/bdsimmons/pen/OPmNxXs css3Animation-&gt;css3Animtions，无需在2个class上设置动画，只需要在一个class上设置动画，并给定动画时间即可，所以如上面的只需要在.ng-enter上设置一个animation动画即可，无需在ng-enter-active在设置动画-&gt;https://codepen.io/anon/pen/NjJLMZ JS动画-&gt;当引入ngAnimate模块后 就自动在app上添加了animation方法，app.animation()；可以通过animation方法，实现动画-&gt;https://codepen.io/bdsimmons/pen/YXLZEw Module 基本用法 创建模块-&gt;用angular.module(“moduleName”,[“依赖的模块”]); 获取已有模块-&gt;用angular.module(“moduleName”);注意获取时，没有后面的依赖数组 让模块运作起来 声明一个module,然后在ng-app中引用它，即可让app从module中开始运行 模块划分 服务模块 指令模块 过滤器模块 一个应用的模块，依赖于上述的三个模块，而且包含应用的初始化及启动代码12345678910111213141516171819202122232425262728293031323334angular.module('xmpl.service', []) // 服务 .value('greeter', &#123; salutation: 'Hello', localize: function(localization) &#123; this.salutation = localization.salutation; &#125;, greet: function(name) &#123; return this.salutation + ' ' + name + '!'; &#125; &#125;) .value('user', &#123; load: function(name) &#123; this.name = name; &#125; &#125;);angular.module('xmpl.directive', []); // directiveangular.module('xmpl.filter', []);// filterangular.module('xmpl', ['xmpl.service', 'xmpl.directive', 'xmpl.filter']) // xmpl依赖service、directive、filter .run(function(greeter, user) &#123; // 初始化 // This is effectively part of the main method initialization code greeter.localize(&#123; salutation: 'Bonjour' &#125;); user.load('World'); &#125;) .controller('XmplController', function($scope, greeter, user)&#123; $scope.greeting = greeter.greet(user.name); &#125;); 模块是配置代码块和运行代码块的集合 配置代码块config-&gt;在 provider 注册和配置阶段执行（注：provider 是 ng 服务的一种）。只有 provider 和 constant 可以被注入配置代码块。这是为了防止服务在完全配置好之前被意外地初始化。-&gt;config为配置 执行代码块run-&gt;在 injector 被创建后执行，被用来启动整个应用。只有服务的实例对象以及 constant 可以被注入到执行代码块。这是为了防止在应用执行期间系统的更进一步的配置。-&gt;run为初始化 123456789angular.module('myModule', []). config(function(injectables) &#123; // provider型注入器 // 这是配置(config)代码块的范例，你可以有任意多个配置代码块 // 配置块中你只能注入Provider类（注意：不是由Provider类生成的实例）以及`constant` &#125;). run(function(injectables) &#123; // instance型注入器 // 这是运行(run)代码块的范例，你可以有任意个运行代码块 // 运行块中你只能注入Provider实例（注意：不是Provider类） &#125;); 配置代码块的快捷方法 123456789101112131415161718192021222324angular.module('myModule', []).value('a', 123).factory('a', function() &#123; return 123; &#125;).directive('directiveName', ...).filter('filterName', ...);// 等同于angular.module('myModule', []).config(function($provide, $compileProvider, $filterProvider) &#123; $provide.value('a', 123); $provide.factory('a', function() &#123; return 123; &#125;); $compileProvider.directive('directiveName', ...); $filterProvider.register('filterName', ...);&#125;);//.config等同于设置module函数的第三个参数angular.module("myModule",[],["$provide","$compileProvider","$filterProvier",function(provide,compileProvier,filterProvider)&#123; provide.value('a', 123); provide.factory('a', function() &#123; return 123; &#125;); compileProvider.directive('directiveName', ...); filterProvider.register('filterName', ...); &#125;]); 配置语句的执行顺序就是根据它们注册的顺序而定的。唯一的例外是 constant 的定义，它会被调整到所有配置块的最前面执行。 执行代码块 执行代码块是 ng 中最接近 main 函数的一个东西。执行代码块是应用启动时运行的代码。它在所有的服务被配置好以及 注入器(injector)被创建好之后执行。通常，执行代码块包含的代码都很难进行单元测试，正因为如此，它通常应该被丢在一个单独的模块中，这样我们可以在单元测试时忽略它。 模块依赖 A依赖B，则A的配置阶段要在B的配置阶段完成后进行，执行阶段同理，A的执行要在B的执行结束后。 注意每个模块只能被加载一次，即使有多个别的模块依赖它。 IE兼容性 1.3及以上不再支持IE8-&gt;所以如果需要支持IE8，请使用ng1.2.x-&gt;1.2的最新版本为1.2.32 IE7及以下不支持JSON.stringify-&gt;使用json2.js 123&lt;!--[if lte IE 7]&gt; &lt;script src="/path/to/json2.js"&gt;&lt;/script&gt;&lt;![endif]--&gt; 在根元素上添加id=”ng-app”并结合ng-app=”xxModule”来启动app 1234&lt;!doctype html&gt;&lt;html xmlns:ng="http://angularjs.org" id="ng-app" ng-app="optionalModuleName"&gt; ...&lt;/html&gt; 不要使用自定义节点 如，用attribute方式代替如ng-view 如果你由于语义或者第三方的Angular组件需要使用tag的方式的话,那么你必须按照如下步骤 make IE happy 1234567891011121314151617181920&lt;!doctype html&gt;&lt;html xmlns:ng="http://angularjs.org" id="ng-app" ng-app="optionalModuleName"&gt;&lt;head&gt;&lt;!--[if lte IE 8]&gt; &lt;script&gt; document.createElement('ng-include'); document.createElement('ng-pluralize'); document.createElement('ng-view'); // Optionally these for CSS document.createElement('ng:include'); document.createElement('ng:pluralize'); document.createElement('ng:view'); &lt;/script&gt;&lt;![endif]--&gt;&lt;/head&gt;&lt;body&gt;...&lt;/body&gt;&lt;/html&gt; 重要的部分: xmlns:ng- 命名空间 - 你需要为每一个将使用的自定义tag注册一个命名空间(译者注:IE作为严格xml模式解析). document.createElement(yourTagName) - 自定义节点创建 - 由于这只是老版本的IE issues，所以你需要按条件加载这些脚本(IE低版本特有的条件注释)。对于每一个需要使用的没有注册命名空间以及非HTML定义的tag你需要利用它来预申明来make IE happy。 IE在处理关于非标准HTML tag 的问题主要由两类，每种类型又其自己的修复方式. If the tag name starts with my: prefix then it is considered an XML namespace and must have corresponding namespace declaration on 以my:为前缀的tag 考虑到严格的XML命名空间，你必须有相应的命名空间申明,如。 If the tag has no : but it is not a standard HTML tag, then it must be pre-created using document.createElement(‘my-tag’) 没有:的非标准HTML tag, 你需要使用document.createElement(&#39;my-tag&#39;)来预申明改节点(译者注:ie-shv)。 If you are planning on styling the custom tag with CSS selectors, then it must be pre-created using document.createElement(&#39;my-tag&#39;) regardless of XML namespace. 如果你希望采用CSS选择器的方式，那么你需要使用document.createElement(&#39;my-tag&#39;)预申明，忽略XML命名空间。 使用ng-style代替style=;后者在&lt;IE11的版本上无法运行 Angualr会在执行的某些时间点为标签添加上一些标识用的class类 ng-scope样式类会在创建了新作用域(Scope)的HTML元素上生成 ng-binding样式类会在ng-bind 或 绑定了任何数据的元素上生成 ng-invalid、ng-valid样式类会在进行了验证操作的所有input组件元素上生成 ng-pristine、ng-dirty angular的input指令给所有新的、还没有与用户交互的input元素附加上ng-pristine类，当用户有任何输入时，则附加上 ng-dirty. 国际化I18n和本地化L10n 引入特定的语言包 12345678&lt;html ng-app&gt;&lt;head&gt;…. &lt;script src="angular.js"&gt;&lt;/script&gt; &lt;script src="i18n/angular-locale_zh-cn.js"&gt;&lt;/script&gt;….&lt;/head&gt;&lt;/html&gt; 启动即bootstrap(这里bootstrap并非指ui库，bootstrap本身就有启动的意思) 自动启动 在angular要控制的范围最外层元素上添加ng-app指令 若未指定ng-app的具体值，会从默认模块开始启动；若指定了则从指定模块上启动 若需支持IE7，则还上在ng-app除添加id=”ng-app” 若需支持老式ng:风格的指令，则还需要在html上添加xml命名空间 1&lt;html xmlns:ng="http://angularjs.org"&gt; 手动启动 使用angular.bootstrap 1234567891011121314151617181920&lt;!doctype html&gt;&lt;html&gt;&lt;body&gt; &lt;div ng-controller="MyController"&gt; Hello &#123;&#123;greetMe&#125;&#125;! &lt;/div&gt; &lt;script src="http://code.angularjs.org/snapshot/angular.js"&gt;&lt;/script&gt; &lt;script&gt; angular.module('myApp', []) .controller('MyController', ['$scope', function ($scope) &#123; $scope.greetMe = 'World'; &#125;]); angular.element(document).ready(function() &#123; angular.bootstrap(document, ['myApp']); // 手动启动 &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; bootstrap要在需要的module创建或加载完成后，才能调用 当手动启动app时，就不应当在用ng-app指令了 安全性 不要混用前台和后台的模板 不要使用用户的输入动态生成模板 Do not run user input through $scope.$eval 考虑使用ngCSP模块 Providers injector可以创建两种对象 专有对象-&gt;angular框架提供的，如controller、filter、directives等 服务-&gt;服务的API由开发人员自己制定-&gt;说明服务可以自己定制 injector需要知道如何创建服务，它需要一个”图纸” 图纸provider、factory、service、value、constant 最底层的图纸是provider，其余四种图纸都是基于provider的语法糖（在provider上又封装了一层） value图纸 用来创建可在运行阶段使用的常量 1234567891011var myApp = angular.module('myApp', []);myApp.value('clientId', 'a12345654321x');myApp.controller('DemoController', ['clientId', function DemoController(clientId) &#123; this.clientId = clientId;&#125;]);&lt;html ng-app="myApp"&gt; &lt;body ng-controller="DemoController as demo"&gt; Client ID: &#123;&#123;demo.clientId&#125;&#125;&lt;/body&gt;&lt;/html&gt; factory图纸 可以创建任何类型的服务 factory图纸相较value图纸增加了下面功能 可以有依赖 服务初始化 延迟/惰性初始化 factory图纸通过一个拥有0～n个参数(参数表示该服务对其他服务的依赖)的函数来创建服务，而函数返回值就是factory图纸创建的服务实例。 123myApp.factory('clientId', function clientIdFactory() &#123; return 'a12345654321x';// 返回的是服务的实例，不过这里clientId是一个常量，所以还是用value靠谱&#125;); 更适合用factory的例子，计算token 12345678910111213myApp.factory('apiToken', ['clientId', function apiTokenFactory(clientId) &#123;//将工厂方法命名为"Factory"是最佳实践（比如，apiTokenFactory）.虽然这种命名方式不是强制性的，但是它有助于浏览代码仓库或者在调试器里跟踪调用堆栈。 var encrypt = function(data1, data2) &#123; // NSA-proof加密算法： return (data1 + ':' + data2).toUpperCase(); &#125;; var secret = window.localStorage.getItem('myApp.secret'); var apiToken = encrypt(clientId, secret); return apiToken;&#125;]);``` service图纸 必须返回引用类型 自定义类型，并携带token 1234567891011function UnicornLauncher(apiToken) &#123; this.launchedCount = 0; this.launch() &#123; // 带上apiToken来发起远程调用 ... this.launchedCount++; &#125;&#125;myApp.factory('unicornLauncher', ["apiToken", function(apiToken) &#123;// 使用factory图纸来实现 return new UnicornLauncher(apiToken);&#125;]);myApp.service('unicornLauncher', ["apiToken", UnicornLauncher]);// 使用services语法更加简介，在内部还是会像factory一样，new 一下 provider图纸 注意必须实现$get方法 其它图纸的底层都是通过provider实现的，如factory 123function factory(name, factoryFn) &#123; return provider(name, &#123; $get: factoryFn &#125;); &#125; 当你需要为在应用运行前就必须设置好的全局配置项提供API时，你才需要用到provider图纸 假设我们的unicornLauncher服务是如此棒，以至于有好多应用都用到它。默认情况下，发射器将独角兽发射到太空中不需要任何保护屏障。但是在某些星球上，由于大气层非常厚，我们在将独角兽送去做星际旅行前必须将它们包裹在铝箔里，不然它们在穿越大气层时就被烧毁了。在一些应用里，需要设置发射器在每次发射时都使用铝箔屏蔽，如果我们能按需配置这一点那就太棒了。我们可以像下面这样让它变得可配置 12345678910111213myApp.provider('unicornLauncher', function UnicornLauncherProvider() &#123; var useTinfoilShielding = false; this.useTinfoilShielding = function(value) &#123; useTinfoilShielding = !!value; &#125;; this.$get = ["apiToken", function unicornLauncherFactory(apiToken) &#123; // 这里我们假设UnicornLauncher的构造函数也被改造得支持useTinfoilShielding参数了 return new UnicornLauncher(apiToken, useTinfoilShielding); &#125;];&#125;);myApp.config(["unicornLauncherProvider", function(unicornLauncherProvider) &#123; unicornLauncherProvider.useTinfoilShielding(true);&#125;]); constant图纸 用来创建可以在配置阶段使用的图纸 在angular开始创建服务之前，angular会配置和实例化所有provider，此时服务还不能用，因为他们还没有被创建(只是provider被实例化了，由provider创建并返回的服务此时还没有被创建)；一旦配置阶段结束，与provider的交互就被禁止了，而创建服务的过程开始；-&gt;所以在配置阶段，没有服务可用，这就导致了一些没有依赖用value写的常量也无法被使用-&gt;使用constant 假设在配置阶段提供了发射独角兽的星球名称，那么我们的unicornLauncher服务就能通过这个名字来标识一个独角兽。星球名是各个应用特有的，并且在应用运行时也会被各个控制器使用。我们可以像下面的代码那样把星球名定义为一个常量 123456myApp.constant('planetName', 'Greasy Giant');myApp.config(['unicornLauncherProvider', 'planetName', function(unicornLauncherProvider, planetName) &#123;// 在配置阶段，使用constant，因为value无法使用 unicornLauncherProvider.useTinfoilShielding(true); unicornLauncherProvider.stampText(planetName);&#125;]);``` value图纸也可以在控制器、模板、指令中使用 1234567891011myApp.controller('DemoController', ["clientId", "planetName", function DemoController(clientId, planetName) &#123; this.clientId = clientId; this.planetName = planetName;&#125;]);&lt;html ng-app="myApp"&gt; &lt;body ng-controller="DemoController as demo"&gt; Client ID: &#123;&#123;demo.clientId&#125;&#125; &lt;br&gt; Planet Name: &#123;&#123;demo.planetName&#125;&#125; &lt;/body&gt;&lt;/html&gt; 总结 injector用五种图纸来创建服务和专有对象 provider图纸是最底层的方法，其他的图纸都是基于其之上的语法糖 provider是最复杂的图纸类型，除非你正在构建需要全局配置的可复用代码，否则不要使用它 除了控制器，其他所有专用对象都是通过factory图纸来定义的(factory定义的，都是单例对象，而controller不是单例的) factory和service是最常用的图纸。它们之间的唯一区别就是service图纸存在一个new过程，所以最好返回一个构造函数，而factory可以创建任意类型 constant用在配置时，value用在运行时 12* 有直接使用new操作符预先初始化的开销。** 在配置阶段，服务对象是不能被访问的，但Provider实例是可以被访问的。（参见我们上面列举的unicornLauncherProvider例子）。 HTML Compiler HTML compiler 让开发者可以教浏览器一些新的语法技能 Compiler是 Angular 提供的一项服务，用来遍历DOM节点，查找特定的属性。编译过程分为两个阶段： 编译compile：遍历DOM节点，收集所有的指令，返回一个连接函数（link func） 连接link：将上一步收集到的每个指令与其所在的作用域（scope）连接生成一个实时视图。任何作用域中的模型改变都会实时在视图中反映出来，同时任何用户与视图的交互则会映射到作用域的模型中。这样，作用域中的数据模型就成了唯一的数据源。 指令directive 在编译过程中，遇到特定的HTML结构（也就是指令）时，指令所声明的行为操作会被触发 指令其实就是在编译器遍历DOM时碰到就需要执行的函数。 指令是如何被编译的 知道 Angular 的编译是在DOM节点上发生而非字符串上是很重要的。如果你自己手动调用 $compile 时，如果你传给它一个字符串，显然是要报错的。所以，在你传值给 $compile 之前，用 angular.element 将字符串转化为DOM。 编译流程 $compile 遍历DOM节点，匹配指令。 如果编译器发现某个元素匹配一个指令，那么这个指令就被添加到指令列表中（该列表与DOM元素对应）。一个元素可能匹配到多个指令（译注：也就是一个元素里面可能有多个指令）。 当所有指令都匹配到相应的元素时，编译器按照指令的 priority 属性来排列指令的编译顺序。 然后依次执行每个指令的 compile 函数。每个 compile 函数有一次更改该指令所对应的DOM模板的机会。然后，每个 compile 函数返回一个 link 函数。这些函数构成一个“合并的”连接函数，它会调用每个指令返回的 link 函数。 之后，$compile 调用第二步返回的连接函数，将模板和对应的作用域连接。而这又会依次调用连接函数中包含的每个指令对应的 link 函数，进而在各个DOM元素上注册监听器以及在相应的 scope 中设置对应的 $watchs。 用代码表示大概是下面流程 1234567891011121314151617181920212223var $compile = ...; // 已经存在的编译器var scope = ...;// 作用域var parent = ...; // DOM element where the compiled template can be appended，要被追加内容的DOM元素var html = '&lt;div ng-bind="exp"&gt;&lt;/div&gt;';// 指令模板字符串// Step 1: parse HTML into DOM element，将html字符串解析为DOM，因为如果传给$compile字符串会报错var template = angular.element(html);// Step 2: compile the template，遍历整个template的DOM，找到所有指令，并按priority排序，并依次执行每个指令里的compile函数，每个compile函数会返回一个link函数，以供第三部用var linkFn = $compile(template);// Step 3: link the compiled template with the scope.，$compile会依次调用第二步返回的link函数，将模板和对应的作用域连接，会依次调用连接函数中包含的每个指令对应的 link 函数，进而在各个DOM元素上注册监听器以及在相应的 scope 中设置对应的 $watchesvar element = linkFn(scope);// Step 4: Append to DOM (optional)，可选的将一切就绪的dom追加到html中parent.appendChild(element); 总结：compile(找指令、排序、依次执行指令中compile函数并返回link函数)-&gt;执行每个指令中的link(DOM和作用域进行连接，设置事件监听并添加$watch) ngModel模块 当需要对数据进行深层处理时，可以用ngModel模块-&gt;一般是指令，这个ngModel对应的就是指令匹配元素上的ng-model 主要参考http://docs.ngnice.com/guidehttps://code.angularjs.org/1.2.32/docs/guide小猫杯的angular视频教程大漠穷秋的angular实战]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Graphviz]]></title>
      <url>%2F2017%2F03%2F24%2FGraphviz%2F</url>
      <content type="text"><![CDATA[Graphviz的安装以及基本使用介绍Graphviz可通过代码的方式生成图形 安装win下，可在官网http://http://www.graphviz.org/Download_windows.php下载，安装好后，手动将bin文件夹添加到环境变量即可。cmd 下键入dot -version,能出现Graphviz相关信息，则表示安装成功 生成图片12dot 源文件 -T 图片格式 -o 输出文件dot input.dot -T png -o output.png 可利用sublimeText的编译系统，实现图片实时预览 具体可参考这篇文章https://zhuanlan.zhihu.com/p/22820399 新建*.dot文件，然后编写相应代码，再编译就能生成图 基本语法123图类型 图名&#123; //其他&#125; 无向图1234567// 无向图用--表示节点之间的关系graph graphname &#123; a -- b--e; b -- c; b -- d; d -- a;&#125; 有向图123456// 有向图用a-&gt;b表示从a节点指向b节点digraph graphname&#123; a-&gt;b b-&gt;c a-&gt;c&#125; 定义一类节点123456digraph graphname&#123; T [label=&quot;Teacher&quot;,fontcolor=&quot;red&quot;] //定义节点T，并给予属性 P [label=&quot;Pupil&quot;] //定义节点P，并给予属性 T-&gt;P [label=&quot;Instructions&quot;, fontcolor=darkgreen] //定义边T-&gt;P，并给予属性 &#125; 设置属性(样式)12345678910111213141516171819202122232425262728293031323334353637graph G &#123; // 设置当前图和子图的属性 fontname=&quot;Microsoft JhengHei&quot;; fontsize=20; label=&quot;图&quot;; fontcolor=blue; //设置当前大括号范围内所有节点和边的属性，包含子图里面节点和边，类css中标签选择器 node[fontname=&quot;Microsoft JhengHei&quot;,fontsize=16]; edge[fontname=&quot;Microsoft JhengHei&quot;,fontsize=16]; // 可针对某一类节点设置属性，类css中class选择器 &quot;黑海&quot;[fontcolor=&quot;pink&quot;,style =&quot;filled&quot;,fillcolor = &quot;black&quot;]; &quot;黑海&quot; -- &quot;亚速海&quot;; &quot;黑海&quot; -- &quot;博斯普鲁斯海峡&quot;; &quot;达达尼尔海峡&quot; -- &quot;爱琴海&quot;; // 子图，用subgraph声明，并图名字前缀必须是cluster_否则识别失败；子图和父图的类型必须一致，父图是无向则子图也必须是无向，不能是有向 subgraph cluster_T &#123; // 设置子图的label属性，它的颜色继承父图的fontcolor=blue label=&quot;黑海海峡&quot;; &quot;达达尼尔海峡&quot; -- &quot;马尔马拉海&quot; -- &quot;博斯普鲁斯海峡&quot;; &#125; subgraph cluster_M &#123; label=&quot;黑海海峡&quot;; // 一对多，空格分隔 &quot;中部地中海&quot; -- &#123; &quot;爱琴海&quot; &quot;爱奥尼亚海&quot; &quot;西西里海峡&quot; &#125;; // 一对多，并设置每对都有一个label标签说明，并把字体颜色设置为red，线条颜色设置为yellow &quot;西部地中海&quot; -- &#123; &quot;西西里海峡&quot; &quot;第勒尼安海&quot; &quot;利古里亚海&quot; &quot;伊比利海&quot; &quot;阿尔沃兰海&quot; &#125;[label=&quot;标签说明&quot;,fontcolor=&quot;red&quot;,color=&quot;yellow&quot;]; &quot;爱奥尼亚海&quot; -- &quot;亚得里亚海&quot;; &quot;阿尔沃兰海&quot; -- &quot;直布罗陀海峡&quot;; &#125;&#125; 最终生成的 中文乱码保证.dot文件是以UTF-8编码通过设置fontname为中文字体来解决 参考链接 https://zhuanlan.zhihu.com/p/21993254https://zhuanlan.zhihu.com/p/22820399http://blog.csdn.net/xiajian2010/article/details/23748557http://www.tuicool.com/articles/vy2Ajyu]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[mock-js]]></title>
      <url>%2F2017%2F03%2F24%2Fmock-js%2F</url>
      <content type="text"><![CDATA[Mock.js的基本用法如何使用123456789101112131415161718192021&lt;script type="text/javascript" src="js/jquery-2.2.4.min.js"&gt;&lt;/script&gt;&lt;!-- 引入Mock.js --&gt;&lt;script type="text/javascript" src="js/mock-min.js"&gt;&lt;/script&gt;&lt;script&gt; // 根据数据模板生成模拟数据。 Mock.mock('http://test.cn', &#123; "userName": "@cname", "sex|1": ["男", "女"], "avator": Mock.Random.image('100x100', '#894FC4', '#FFF', 'png', '头像') &#125;); // 模拟请求 $.ajax(&#123; url: 'http://test.cn', dataType: 'json' &#125;).done(function(data, status, xhr) &#123; // 请求成功，do something console.log(data); &#125;);&lt;/script&gt; 语法规范 数据模板定义规范（Data Template Definition，DTD） 数据占位符定义规范（Data Placeholder Definition，DPD） 数据模板定义语法1234&apos;name|rule&apos;:valuename:属性名rule:生成规则vale:属性值 注意 属性名(name)和生成规则(value)之间要用|分隔 生成规则(rule)不是必须的 最终生成值的类型和初始值由属性值(value)确定 属性值(value)中可以包含数据占位符(@占位符) 生成规则有7种格式 ‘name|min-max’: value ‘name|count’: value ‘name|min-max.dmin-dmax’: value ‘name|min-max.dcount’: value ‘name|count.dmin-dmax’: value ‘name|count.dcount’: value ‘name|+step’: value 生成规则的具体含义还要配合属性值(value)的类型来确定 规则 属性值(value)是String ‘name |min-max’:stringValue 通过重复stringValue，生成一个字符串。重复次数在[min,max]区间取值(次数大于等于min，小于等于max) ‘name |count’:stringValue 通过重复stringValue字符串count次，生成一个字符串。 属性值(value)是Number ‘name|+1’: numberValue 属性值自动加 1，初始值为numberValue。 ‘name|min-max’:numberValue 生成一个[min,max]之间的整数，此时属性值numberValue只是用来确定类型。 ‘name|min-max.dmin-dmax’: numberValue 生成一个整数部分在[min,max]间取值,小数保留的位数在[dmin,dmax]间取值的浮点数。同理此时属性值(value)也只是用来确定最终返回的数据的类型。 属性值是Boolean ‘name|1’: booleanValue 随机生成一个布尔值，值为 booleanValue 的概率是 1/2，值为 !booleanValue 的概率同样是 1/2。 ‘name|min-max’: booleanValue 随机生成一个布尔值，值为 booleanValue 的概率是 min / (min + max)，值为 !booleanValue 的概率是 max / (min + max)。此处属性值必须是Boolean类型，若为Number,则意义不同，见2 “test|1-2”:true 生成一个布尔值，为true的概率为1/3，为false概率为2/3 属性值是对象 Object ‘name|count’: object 返回的对象只包含从属性值object中随机选取的count个属性。 ‘name|min-max’: object 返回的对象只包含从属性值object中随机选取的min到max个属性。 属性值是数组 Array ‘name|1’: array 从属性值 array 中随机选取 1 个元素，作为最终值。 ‘name|+1’: array 从属性值 array 中顺序选取 1 个元素，作为最终值。 ‘name|min-max’: array 通过重复属性值array的值生成一个新数组，重复次数大于等于 min，小于等于 max。 ‘name|count’: array 通过重复属性值array的值生成一个新数组，重复次数为 count。 属性值是函数 Function ‘name’: function 执行函数 function，取其返回值作为最终的属性值，函数的上下文为属性 ‘name’ 所在的对象。 属性值是正则表达式 RegExp ‘name’: regexp 根据正则表达式 regexp 反向生成可以匹配它的字符串。用于生成自定义格式的字符串。 数据占位符定义语法Mock中的占位符和Sass中的placeholder很像。可以直接用在数据模板的属性值中。Mock中提供了很多预先定义的占位符，当然你也可以自定义占位符。 基本调用格式1234@占位符@占位符(参数 [, 参数])或者Mock.Random.占位符(参数 [, 参数]) 注意： 用@来标识其后的字符串是占位符。 占位符引用的是Mock.Random中的方法。 通过 Mock.Random.extend() 来扩展自定义占位符。 占位符也可以引用数据模板中的属性。 占位符会优先引用数据模板中的属性。 占位符支持相对路径和绝对路径。 预定义的占位符 Basic 提供一些基础占位符，如布尔值、整数、自然数、字符串等 Date 提供日期相关的占位符 Image 提供图片相关的占位符 Color 提供色值相关的占位符 Text 提供文本相关的占位符 Name 提供英文、中文名称相关的占位符 Web 提供了url、IP、protocol等相关的占位符 Address 提供省份、城市等地域相关信息的占位符 Helper 提供一些常用工具如字母转换大小写等相关占位符 Miscellaneous 提供了guid、身份证、自增等相关占位符号 自定义扩展符1234567891011121314Mock.Random.extend(&#123; constellation: function(date) &#123; var constellations = ['白羊座', '金牛座', '双子座', '巨蟹座', '狮子座', '处女座', '天秤座', '天蝎座', '射手座', '摩羯座', '水瓶座', '双鱼座'] return this.pick(constellations) &#125;&#125;)Mock.Random.constellation()// =&gt; "水瓶座"Mock.mock('@CONSTELLATION')// =&gt; "天蝎座"Mock.mock(&#123; constellation: '@CONSTELLATION'&#125;)// =&gt; &#123; constellation: "射手座" &#125; 更多API请参考 https://github.com/nuysoft/Mock/wiki‘ 更多实例请参考 http://mockjs.com/examples.html 可以一边看API、一边看实例，很容易就能上手]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Markdown-Learning]]></title>
      <url>%2F2017%2F03%2F23%2FMarkdown-Learning%2F</url>
      <content type="text"><![CDATA[Markdown-Github Flavored Markdown常用操作Markdown拥有多种语法风格 标准风格-不支持表格 扩展风格-支持表格 github风格-Github Flavored Markdown它在标准风格上做了很多改进，如对表格的支持，针对不同编程语言实现代码高亮等 因为经常使用github，所以选择了Github Flavored Markdown风格。 Hexo搭建的博客也是使用github风格来解析markdown的。 win上支持Github Flavored Markdown风格的编辑器我常用的有:markdown pad2和typora。typora最让我心动的是支持快捷键创建表格，非常的方便。 标题12345# 一级标题## 二级标题，二级标题自带下划线### 三级标题...###### 六级标题 粗体斜体1234**两个星号为粗体***一个星号为斜体***粗中带 _斜_***内部换行用&lt;br&gt;,第二行* 引用1&gt; 这样引用 无序列表12345- 无序 - 我前面有2个空格，我能缩进 - 无序- 无序- 无序 有序列表12341. 第一行 1. 我前面有2个空格2. 第二行3. 第三行 任务列表123- [x] 我代表选中- [ ] 我没选中- [ ] 我没选中 图片与链接12[链接名](链接地址)![图片alt](图片地址) 代码段1使用`包裹的区域会形成代码段,区段内的 &amp;、&lt; 和 &gt; 都会被自动的转换成HTML实体，一般用在行内 代码块1使用三个`会产生格式化好的代码块,而 &amp;、&lt; 和 &gt; 也一样会自动转成HTML实体，一般用于一大段代码 代码块高亮123function show()&#123; console.log("我是带语法高亮的代码块，在三个`后添加上语言类型即可高亮");&#125; 表格12345| Tables | Are | Cool || ------------- |:-------------:| -----:|| col 3 is | right-aligned | $1600 || col 2 is | centered | $12 || zebra stripes | are neat | $1 | Markdown中表格生成较为麻烦，建议使用编辑器快速生成,如typora中使用ctrl+t 分割线1***或--- 会产生分割线 还有很多东西因为没用到，所以不做介绍。更多的可以参考这 https://help.github.com/categories/writing-on-github/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Handlebars-guide]]></title>
      <url>%2F2017%2F03%2F17%2FHandlebars-guide%2F</url>
      <content type="text"><![CDATA[#HandleBars备忘 表达式{{xxx}} {{{xxxx}}}因为双大括号默认会进行HTML转义,将&lt;转换为&amp;lt;,通过三括号可以避免 Helper默认Helper{{#if a}}如果a为真执行这个{{/if}} {{#else}}否则执行这个{{/else}} {{#unless a}}当a为假的时候执行这个{{/unless}} {{#each obj}}遍历obj的每个属性{{/each}} #each内可以用{{@index}}获取当前遍历的索引值，用{{@key}}获取当前属性的属性名，用{{this}}可以获当前属性的值 如何获取父对象 可以通过{{../父对象某属性}}来获取父对象的某个属性，{{@../index}}获取父对象当前的所引值 {{#with obj}}xxx{{/with}}类似js中with，可改变作作用域，在each中也可通过#with 父对象名 来访问父对象 {{lookup xxx}}一般用来按照索引来找兄弟变量对应的值{{lookup ../父对象某属性 @index}}，查找父对象在当前索引下值 自定义Helper行级Helper语法{{helperName [普通值参数][hash值参数]}} {{customHelper "My Text" class="my-class" visible=true counter=4}} Handlebars.registerHelper(&apos;customHelper&apos;, function() { console.log(arguments[0]);//==&gt;&quot;My Text&quot; console.log(arguments[1].hash);//==&gt;{class:&quot;my-class&quot;,visible:true,conter:4} }); 块级Helper语法{{#helperName context [普通值参数][hash值参数]}}xxxxxxxxx{{/helperName}} {{#customHelper nav "normalValue" class="my-class" visible=true counter=4}} {{if name}} aaaaaa {{else}} bbbbbbb {{/if}} {{/customHelper}} Handlebars.registerHelper(&apos;customHelper&apos;, function(context,options) { console.log(arguments[0]);//==&gt;context console.log(arguments[1]);//==&gt;normalValue console.log(arguments[2]);//==&gt;options //说明在registerHelper内部,第二个参数匿名函数,只会存在3个实参，第一个为当前使用的上下文，第二个如果有则为一个普通值参数，另外一个就是封装了函数相关信息的options对象，它有hash(封装好一个或多个键值对参数)、fn(传入一个上下文，并在此上下文中执行customHelper模板中的{{#if}}到{{else}}中的模板)、inverse(同fn相反执行{{else}}到{{/if}}之间的)、name、data等属性。 }); 参考:http://cnodejs.org/topic/56a2e8b1cd415452622eed2dhttp://www.cnblogs.com/iyangyuan/archive/2013/12/12/3471227.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[break-word、word-wrap、white-space]]></title>
      <url>%2F2017%2F03%2F10%2Fbreak-word-word-wrap-white-space%2F</url>
      <content type="text"><![CDATA[white-spacewhite-space的定义是用来设置如何处理元素中的空白。这里的空白指的是空格、tab制表符。 默认情况下，html中连续出现的多个空格会被合并成一个空格，Tab也会被替换成一个空格。回车换行(br换行不在内)会被忽略并将其替换成一个空格。当在容器剩余空间不足以容纳一个单词时，浏览器会在单词结束处自动换行。(默认情况下，是无法在一个单词内进行自动换行的，只能在结尾处换行。) 值 是否合并空白符(空格、tab) 是否忽略回车换行 是否允许自动换行 normal 合并 忽略 允许 nowrap 合并 忽略 不允许 pre 保留 保留 不允许 pre-wrap 保留 保留 允许 pre-line 合并 保留 允许 word-wrapword-wrap的定义是用来说明当一个不能被分开的字符串太长而不能填充其包裹盒时，为防止其溢出，浏览器是否允许这样的单词中断换行。既指明是否允许浏览器在单词内进行自动换行 值 解释 normal 在单词结束处换行 break-word 如果行内没有多余空间容纳该单词到行尾，则会强制将单词截断，在单词内进行换行 word-breakword-break指定了怎样在单词内断行 值 解释 normal 默认换行规则 break-all 对于non-CJK (中文/日文/韩文) 文本，可在任意字符间断行。 keep-all CJK 文本不断行。 Non-CJK 文本表现同 normal。 在white-space、word-wrap、word-break都为normal值时，既默认情况下时。一行的剩余空间不足以容纳一个单词时，浏览器会将这个单词挪到下一行显示。挪后如果这个单词比容器还长，则这个单词会直接溢出，因为默认情况下，浏览器是无法在单词内进行换行的。中文会一行空间不足以容纳一个字时，在字后进行换行 此时如果设置word-wrap:break-word，则会将这个长单词进行截断，从截断处进行换行。 可以发现第一行仍然有一点空间没有利用，此时就需要用到word-break:break-all; 可以说word-break:break-all是word-wrap:break-word的升级版本，它不会在剩余空间不够的时候将长单词挪到下一行，它将单词放在原位，并在容器边界处直接将这个长单词进行截断，然后换行。 将这三个属性，组合使用会怎么样 当设置了white-space:nowrap;时，word-wrap:break-word;和word-break:break-all;都将失效。文本将会强制在一行内显示 当同时设置word-wrap:break-word;和word-break:break-all时，word-break:break-all的效果会生效 word-spacing规定英文单词之间的间距 letter-spacing规定英文字符之间的间距 总结: 默认情况下，当一行的剩余空间不足以容纳某一单词时，浏览器会将此单词整体挪到下一行显示。此时，若这个单词超长(长度超出容器的宽度)，则此单词会直接溢出(此时上一行会留下一段空白)。 word-wrap:指明是否允许在长单词中换行，当设置其属性为break-word，则会把超过容器长度的单词进行截断，并换行(上一行留下的空白并不会被清除) word-break:当其设置break-all时，它是word-wrap:break-word的升级版，它能解决上一行留白问题。它会让单词先在当前行显示，当单词某个字符到达容器边界时，会直接在此字符出进行截断，并换行。这样就最大限度的利用了空间。 white-space:指定处理空白符的方式，比较有用的属性为nowrap，设置文本不换行。一般配合其它css实现文本过长省略号 word-spacing:规定英文单词之间的间距 letter-spacing:规定英文单词字符之间的间距 图片引用在自http://www.cnblogs.com/2050/archive/2012/08/10/2632256.html]]></content>
    </entry>

    
  
  
</search>
